{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Tatin","text":"<p>Tatin is the community cross-platform package manager for Dyalog APL</p> <p></p> <p>The diagram illustrates an APL application defined in Linked text files, and held on a GitHub repository. It depends on APL libraries in the form of Tatin packages imported from a Tatin repository.</p> <p>In the example, the application does not just consume Tatin packages. Its working parts, excluding the tests but including the dependencies,  are also published as a new Tatin package.</p> <p>As shown, one package may depend on another, and so on. Tatin manages these dependencies.</p> <p>The Tatin Principal Registry hosts packages with minimal licence restrictions. You can also host a Tatin registry on your local machine or on a server.</p>"},{"location":"#packages","title":"Packages","text":"<p>A package should serve a particular, limited task, for example converting Markdown files into HTML. </p> <p>It may be as simple as a single source file, or multiple folders and source files. </p> <p>It may include other assets: CSS files, BAT files, icons, images, config files, documentation, DLLs, etc.</p> <p>It may depend on other packages: Tatin manages the dependencies behind the scenes.</p> <p>Tatin package licences impose few restrictions on your use of the software.</p>"},{"location":"#versions-and-dependencies","title":"Versions and dependencies","text":"<p>All things must change. In general a package exists as a series of versions.</p> <p>A package that depends on another package usually depends on either a specific or a minimum version of it. Upgrading might require newer versions of packages on which it in turn depends.</p> <p>Tatin follows the semantic versioning conventions and silently manages all this for you.</p> <p>To support this work the Principal Registry never deletes a published package. You can deprecate a package or a version, but the registry retains it for anyone who relies on it.</p>"},{"location":"#usage","title":"Usage","text":"<p>There are two ways to use Tatin.</p> <ul> <li>User commands such as <code>]TATIN.ListRegistries</code> put Tatin at your fingertips</li> <li>API functions such as <code>\u2395SE.Tatin.ListRegistries</code> let you write DevOps scripts </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Dyalog Unicode Edition Version 18.2 or better. (Classic is not supported.)</li> <li>Link Version 3.0.8 or better</li> <li>The Tatin client runs on Windows, Linux, macOS and Raspberry Pi.</li> <li>The Tatin registry runs on Windows (as a service or a Docker container) and on Linux (as a Docker container)<sup>2</sup>.</li> </ul>"},{"location":"#licences","title":"Licences","text":"<p>Tatin is a community project. Packages hosted on the Principal Registry make the software available with minimal restrictions.</p>"},{"location":"#community","title":"Community","text":"<p>You can contribute to the Principal Registry: report errors (open issues in the package repositories), or submit pull requests if you can see how to fix them.</p> <p>Please also consider publishing your own work as Tatin packages.</p> <p>Besides the Principal Registry, you can host your own Tatin registry.</p> <p>Tatin is itself a community project, hosted on GitHub. No one owns it. You are very welcome to contribute to it.</p>"},{"location":"#cider-and-tatin","title":"Cider and Tatin","text":"<p>Cider is the project manager for Dyalog APL.</p> <p>Like Tatin, it works with APL source files created and managed by Link. </p> <p>Tatin is all you need in order to consume packages. Cider extends Tatin with tools for managing versions and tests.</p> <p>If you foresee publishing software for others to use,  either as Tatin packages or as an application or Web service,  it might suit you to start with Cider and let it manage Tatin.</p> <ol> <li> <p>A package manager or package-management system is a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer in a consistent manner. \u2014 Wikipedia \u21a9</p> </li> <li> <p>The registry should also run under Docker on macOS but this has not been tested.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/","title":"API functions","text":"<p>With the Tatin API you can write DevOps scripts in APL.</p> <p>The API functions are similar to the user-commands, but not identical. Not all have equivalent user commands.</p> <p>BuildPackage InitPackageConfig CheckForLaterVersion InstallPackages ClearCache ListDeprecated CopyRegistry ListCache CreateAPIfromCFG ListLicenses CreateBuildParms ListPackages CreateCopyRegistryParms ListRegistries CreateReInstallParms ListTags DeletePackages ListVersions DeprecatePackage LoadDependencies FindDependencies LoadPackages GetDeletePolicy Ping GetDependencyTree PublishPackage GetNoCachingFlag ReInstallDependencies GetPathToPackageCache ReadPackageConfigFile GetUserHomeFolder UnInstallPackages InitialisePackage Version</p> <p>Unlike user commands, API function names are case-sensitive.</p> <p>The Tatin API is in <code>\u2395SE.Tatin</code>. Call an API function like this:</p> <pre><code>\u2395SE.Tatin.BuildPackage parms\n</code></pre> API code cache <p>The Tatin code package is loaded into <code>\u2395SE._Tatin</code>, but the API is exposed via <code>\u2395SE.Tatin</code>.</p> <p>Do not call functions in <code>\u2395SE._Tatin</code>.</p>"},{"location":"api/#build-package","title":"Build package","text":"<pre><code>zipFilename\u2190BuildPackage parms\n</code></pre> <p>Zips all files required for a package into a file at <code>parms.targetPath</code> and returns its name.</p> <p>Parameter space <code>parms</code> is typically created with <code>CreateBuildParms</code> and specifies:</p> <code>dependencyFolder</code> Path to folder with packages the project depends on. Default is <code>''</code>. <p>Tatin searches the project for dependencies in (in order of precedence)</p> <ol> <li>the folder specified in <code>dependencyFolder</code></li> <li><code>cider.config</code> (for projects managed by Cider)</li> <li><code>packages/apl-dependencies.txt</code></li> <li><code>apl-dependencies.txt</code></li> </ol> <code>projectPath</code> Path to folder from which to create the package. (Required.) <code>projectspace</code> <p>Namespace that is to contain the package contents.</p> Until version 0.118.0 this was known as <code>tatinVars</code> <p>Now, Tatin signals an error if it finds a <code>tatinVars</code> parameter.</p> <code>targetPath</code> Path to folder in which to write the ZIP file. Default is <code>''</code>: use <code>projectPath</code>. <code>version</code> <p>String. One of:</p> <ul> <li>A rule to modify the version number in the package config file:<ul> <li><code>'+0.0.1'</code> bumps the patch number</li> <li><code>'+0.1.0'</code> bumps the minor number and resets the patch number</li> <li><code>'+1.0.0'</code> bumps the major number and resets both the patch number and the minor number</li> </ul> </li> <li>An empty character vector</li> <li>A string that replaces <code>version</code> in the package config file</li> </ul> <p>See Glossary for details.</p>"},{"location":"api/#check-for-later-version","title":"Check for later version","text":"<pre><code>r\u2190{flags} CheckForLaterVersion path\n</code></pre> <p>Scans all known registries (with priority &gt;0) for later versions of the principal packages installed in <code>path</code> and returns a matrix with columns:</p> <pre><code>1 - Original package ID\n2 - Latest package ID\n3 - Original URL\n4 - Flag: whether later version is available\n5 - URL of latest version; empty if unchanged\n</code></pre> <p>By default, only principal packages and minor and patch numbers are checked. Change this with optional left argument <code>flags</code>: the sum of the following. (Defaults to 0: do neither.)</p> <pre><code>1 - List later major versions\n2 - Check package dependencies as well\n</code></pre>"},{"location":"api/#clear-cache","title":"Clear cache","text":"<pre><code>(rc report)\u2190ClearCache url\n</code></pre> <p>Clears the cache and returns FIXME.</p> <p>If <code>url</code> is</p> <ul> <li>empty all subdirectories but <code>temp\\</code> are removed</li> <li>not empty, only the given domain is removed from the cache</li> </ul> <p>The cache is the folder <code>GetPathToPackageCache</code> points to.</p>"},{"location":"api/#copy-registry","title":"Copy registry","text":"<pre><code>list\u2190CopyRegistry parms\n</code></pre> <p>Copies packages from a managed Tatin registry to a local folder and returns as a list of strings the packages copied</p> <p>Pause or stop any running local server while <code>CopyRegistry</code> is running.</p> <p>Argument <code>parms</code> is typically created with CreateCopyRegistryParms, and then amended. Required parameters are marked; others are optional.</p> <code>dry</code> <p>List all packages the user command would copy without actually doing it.</p> <p>If set you may omit both URL (defaults to <code>[tatin]</code>) and <code>path</code>.</p> <code>force</code> Copy already available packages again. By default packages already saved in the target folder are not requested again. <code>group=</code> <p>Restrict the packages to be copied to a particular group.</p> <p>Dependencies will be copied as well, no matter which group they belong to.</p> <code>latest</code> <p>Copy only the latest version of each major version of each non-deprecated package.</p> <p>By default all packages are copied, even deprecated ones.</p> <code>list=</code> <p>Packages to copy, as one of</p> <ul> <li> <p>A comma-separated list of package names</p> </li> <li> <p>A file of package names, one per row, specified with the <code>file://</code> protocol</p> </li> <li> <p>A variable name, prefixed by either <code>#.</code> or <code>\u2395SE.</code></p> </li> </ul> <p>Specify packages consistently: either <code>&lt;group&gt;-&lt;pkgName&gt;</code> or <code>&lt;group&gt;-&lt;pkgName&gt;-&lt;major&gt;</code></p> <code>noDeps</code> Flag. If set, ignore dependencies. (Useful only for test cases.) <code>path</code> A local folder in which to write the packages. Required unless <code>dry</code> set. <code>url</code> URL of the Tatin registry from which to copy. Required unless <code>dry</code> set. <code>verbose=</code> <p>By default, prints the names of all packages copied to <code>\u2395SE</code>. </p> <p>1 \u2013 print a detailed report for all packages (<code>Fetched</code> indicates success)</p> <p>2 \u2013 print a message for every package as the list is processed</p> <p><code>CopyRegistry</code> was introduced with version 0.110.0</p> <p>Tatin registries running on earlier versions will not respond to it.</p>"},{"location":"api/#create-api-from-cfg","title":"Create API from CFG","text":"<pre><code>{noOf}\u2190{names} CreateAPIfromCFG (source cfg)\n</code></pre> <p>Where</p> source reference namespace containing the package objects cfg What? package configuration names strings (optional) names of objects in the namespace to be exposed in the API <p>then Tatin creates an API space as a child of <code>source</code> (with cover functions for the package\u2019s public interface) and returns as a shy result the number of objects exposed.</p> <p>If <code>names</code> is absent, the function looks for a constant <code>source.Public</code>.</p> <p>Not for use with a scripted namespace.</p> <p>See Public Interface for more.</p>"},{"location":"api/#create-build-parms","title":"Create build parms","text":"<pre><code>parms\u2190CreateBuildParms projectPath\n</code></pre> <p>Creates a parameter space for <code>BuildPackage</code> with parameters:</p> <pre><code>dependencyFolder\nprojectPath\ntargetPath\ntatinVars\nversion\n</code></pre>"},{"location":"api/#create-copyregistry-parms","title":"Create CopyRegistry parms","text":"<pre><code>parms\u2190CreateCopyRegistryParms y\n</code></pre> <p>Where <code>y</code> is either an empty vector or a parameter space, returns a parameter space for <code>CopyRegistry</code>.</p>"},{"location":"api/#create-reinstall-parms","title":"Create ReInstall parms","text":"<pre><code>parms\u2190CreateReInstallParms\n</code></pre> <p>Returns a parameter space with default parameters for the (optional) left argument of <code>ReInstallDependencies</code>, in particular, <code>noBetas</code>, <code>update</code> and <code>dry</code>.</p>"},{"location":"api/#delete-packages","title":"Delete packages","text":"<pre><code>(statusCode errMsg)\u2190DeletePackages (regID packageIDs)\n</code></pre> <p>Deletes <code>packages</code> from Tatin registry <code>regID</code> and returns HTTP <code>statusCode</code> and <code>errMsg</code>, empty if successful.</p> <p>All packages specified are removed from the same registry. Specify <code>regID</code> as either</p> <ul> <li>a URL</li> <li>a Registry alias</li> <li>a Registry ID</li> </ul> <p>Specify <code>packages</code> as a string or list of strings, with each package and version precisely identified:</p> <pre><code>&lt;group-name&gt;-&lt;package-name&gt;-&lt;precise_version_number&gt;\n</code></pre> <p>A Tatin registry will delete packages only if its configured Delete policy permits.</p> <p>The principal Tatin server operates a <code>None</code> policy, meaning that you cannot delete anything from it.</p> Why can\u2019t I delete a package from the Tatin server? <p>The main design objective is to ensure a build that includes packages from the principal Tatin registries can always be reproduced in precisely the same way.</p> <p>If deleting a package is allowed \u2013 even when it is a beta version \u2013 then this cannot be guaranteed.</p> <p>If you happen to publish a package and realize seconds later that you made a formidable mistake? Increase the patch number, fix the problem and publish a new version: that\u2019s the only way.</p>"},{"location":"api/#deprecate-package","title":"Deprecate package","text":"<pre><code>msg\u2190DeprecatePackage (registry comment package)\n</code></pre> <p>Where</p> <ul> <li><code>registry</code> is a URL or alias</li> <li><code>comment</code> is a string, such as <code>See package xyz instead</code></li> <li><code>package</code> identifies a package with group name, package name, and (optionally) major version number</li> </ul> <p>marks the package on the registry as deprecated.</p> <p>If no major version number is provided, then all major versions of the package are deprecated.</p> <p>As the registry is defined, no scanning is done.</p>"},{"location":"api/#find-dependencies","title":"Find dependencies","text":"<pre><code>r\u2190{depth} FindDependencies (target pkgList [verbose])\n</code></pre> <p>Where</p> target string <p>one of:</p><ul><li>a Registry alias</li><li><code>'[*]'</code> for all defined registries with a priority above 0</li><li>URL of a Tatin server</li><li>path to a folder where the packages of a registry are stored</li></ul> pkgList string a list of package names separated by commas verbose flag optional: whether to include more detail in the result; default 0 depth integer optional: limit on recursive search <p>then Tatin recursively scans the registry for the packages in <code>pkgList</code> and returns a fully qualified list of all matches.</p> <p>By default only the folder containing a file <code>apl-dependencies.txt</code> with at least one of the defined packages is returned.</p> <p>If <code>verbose</code> is set the actual package folders are returned instead of the hosting folder/s, revealing the precise version/s installed.</p> <p>Specify packages in <code>pkgList</code> partially or in full. Name is required but group and version can be omitted. You can specify a major version number, but minor and patch numbers are ignored if specified.</p> <p>The function scans <code>folder</code> recursively for a file <code>apl-dependencies.txt</code>. Folders containing such a file are searched for the packages listed in <code>pkgList</code>. The search is not case-sensitive.</p> <p>Useful for discovering where packages are used.</p> <p>Set optional left argument <code>depth</code> to limit the number of levels searched. A server sets this to 1 because it knows it only needs to search the child folders of the Registry folder, which greatly reduces the search time.</p> <p>You can use it similarly if you know exactly what is stored where.</p>"},{"location":"api/#get-delete-policy","title":"Get delete policy","text":"<pre><code>r\u2190GetDeletePolicy server\n</code></pre> <p>Where <code>server</code> is the alias or URL of a Tatin server, returns its delete policy:</p> None a published package cannot be deleted Any any package can be deleted JustBetas only beta versions can be deleted <pre><code>      \u2395SE.Tatin.GetDeletePolicy 'https://tatin.dev'\nNone\n      \u2395SE.Tatin.GetDeletePolicy '[tatin]'\nNone\n</code></pre>"},{"location":"api/#get-dependency-tree","title":"Get dependency tree","text":"<pre><code>tree\u2190GetDependencyTree pkg\n</code></pre> <p>Where <code>pkg</code> is one of:</p> <ul> <li>an HTTP request</li> <li>a folder containing a package, e.g.<code>file://C:\\Temp\\{group}-{name}-{major.minor.patch}\\</code></li> <li>a path to a package in a local registry, e.g. <code>C:\\MyReg\\{packageID}</code></li> <li>a package ID (Tatin will search the registries defined in your config file)</li> </ul> <p>Tatin returns a dependency tree as a matrix:</p> col contains 1 flag: 1 \u2013 principal package; 0 \u2013 dependency 2 ID of package that required the dependency 3 full package ID 4 full URL: either a local path (without protocol) or http(s)://... <p>This function requires the version number to be fully specified.</p> <p>The function accepts an optional left argument for INTERNAL use only.</p>"},{"location":"api/#get-nocaching-flag","title":"Get NoCaching flag","text":"<pre><code>flag\u2190GetNoCachingFlag registry\n</code></pre> <p>Where <code>registry</code> is a URI or alias, Tatin searches <code>MyUserSettings</code> for it. If found the value of the <code>noCaching</code> property is returned, otherwise 0.</p> <pre><code>      \u2395SE.Tatin.GetNoCachingFlag '[tatin]'  \u235d actual\n0\n      \u2395SE.Tatin.GetNoCachingFlag '[fubar]'  \u235d default\n0\n</code></pre>"},{"location":"api/#get-path-to-package-cache","title":"Get path to package cache","text":"<pre><code>path\u2190GetPathToPackageCache\n</code></pre> <p>Returns <code>MyUserSettings.path2cache</code> if not empty, otherwise the standard path for caching, according to the operating system.</p> <pre><code>      \u2395SE.Tatin.GetPathToPackageCache     \u235d macOS\n/Applications/Dyalog/tatin-package-cache\n</code></pre>"},{"location":"api/#get-user-home-folder","title":"Get user home folder","text":"<pre><code>path\u2190{aplVersion} GetUserHomeFolder str\n</code></pre> <p>Returns the standard path for user-specific data, with string <code>str</code> appended.</p>  Windows Linux macOS <pre><code>C:\\Users\\%USERPROFILE%\\AppData\\Roaming\\Tatin\n</code></pre> <pre><code>/home/{\u2395AN}/Tatin\n</code></pre> <pre><code>/Users/{\u2395AN}/Tatin\n</code></pre> <pre><code>      \u2395SE.Tatin.GetUserHomeFolder 'foo'    \u235d macOS\n/Users/sjt/Library/Application Support/Tatin/foo\n</code></pre> <p>Optional string <code>aplVersion</code> is used by test cases to simulate different versions of APL.</p>"},{"location":"api/#initialise-package","title":"Initialise package","text":"<pre><code>config\u2190{configParms} InitialisePackage folder\n</code></pre> <p>Where <code>folder</code> is a path to a folder, and (optional) <code>configParms</code> is a parameter space, Tatin creates the folder if necessary and initializes it with a config file.</p> <p>If the folder exists and already contains a config file, Tatin signals an error.</p> <p>Optional left argument <code>configParms</code> is typically created with <code>InitPackageConfig</code> but can be made from scratch: <pre><code>  parms\u2190\u2395NS''\n  parms.(group name version)\u2190'aplteam' 'Foo' '1.0.0'\n  cfg\u2190parms \u2395SE.Tatin.InitialisePackage 'path/to/folder'\n</code></pre></p>"},{"location":"api/#initpackage-config","title":"InitPackage config","text":"<pre><code>cfg\u2190{sourcePath}  InitPackageConfig parms\n</code></pre> <p>Where</p> <code>parms</code> is a an empty vector or a parameter space <code>sourcePath</code> (optional) is a path to the package source folder <p>Tatin returns a parameter space for <code>InitialisePackage</code>.</p> <p>The <code>source</code> parameter in the result is set by (in order of precedence)</p> <ol> <li><code>sourcePath</code></li> <li><code>parms.source</code></li> <li>global default in <code>MyUserSettings</code></li> </ol> <pre><code>      showParms \u2395SE.Tatin.InitPackageConfig \u236c\napi               :\nassets            :\ndescription       :\ndocumentation     :\nfiles             :\ngroup             :\nio                : 0\nlicense           :\nlx                :\nmaintainer        :\nminimumAplVersion : 18.0\nml                : 0\nname              :\nos_lin            : 1\nos_mac            : 1\nos_win            : 1\nproject_url       :\nsource            :\ntags              :\nuserCommandScript :\nversion           : 0.1.0\n</code></pre>"},{"location":"api/#install-packages","title":"Install packages","text":"<pre><code>r\u2190{noBetas} InstallPackages (identifiers targetFolder)\n</code></pre> <p>Where</p> identifiers string comma-separated list of package identifiers noBetas flag whether to exclude beta versions; default 0 targetFolder string <code>'[MyUCMDs]'</code>, or <code>'[MyUCMDs]{pkgname}'</code>, or a path to a folder <p>Tatin creates the target folder if necessary, installs the packages in it and returns (as a list of strings) the full names of the principal packages installed. The list length will be the number of packages specified as <code>identifiers</code>.</p> <p>A package identifier is case-insensitive and one of:</p> <ul> <li>an HTTP request for a package</li> <li>a ZIP file containing a package</li> <li>a folder containing a package, e.g. <code>file://C:\\Temp\\group-name-version\\</code></li> <li>a path to a package in a registry, e.g. <code>[RegistryAlias]{group}-{name}-{major.minor.patch}</code> or <code>C:\\MyReg\\{group}-{name}-{major.minor.patch}</code></li> <li>a package ID that Tatin will search for in the registries specified in your config file</li> </ul> <p>If <code>targetFolder</code> is <code>'[MyUCMDs]'</code>, or <code>'[MyUCMDs]{pkgname}'</code> (case independent) it is replaced by the actual path to the <code>MyUCMDs/</code> folder followed by the name specified or, if none was specified, the name of the package.</p> <p>To install the latest version, omit minor+patch or even major+minor+patch.</p>"},{"location":"api/#list-cache","title":"List cache","text":"<pre><code>list\u2190{fullpath} ListCache registry [principalFlag]\n</code></pre> <p>Where</p> fullpath flag optional: report full paths; default 0 principalFlag flag optional: default 0 registry string empty, or a registry domain name or alias <p>returns the contents of the Tatin package cache as a nested list with an item for each domain represented in the cache.</p> <p>Each result item is a pair:</p> <ol> <li>URL of the domain</li> <li>package names as a list of strings: if <code>fullpath</code> is set then the full paths instead</li> </ol> <p>If the cache is empty the result is an empty list.</p>"},{"location":"api/#list-deprecated","title":"List deprecated","text":"<pre><code>list\u2190{all} ListDeprecated source\n</code></pre> <p>Where</p> all flag optional: include all versions; default 0 source string <p>is one of</p><ul><li>an alias or URL for a Tatin registry</li><li>path to an install folder (contains a file <code>apl-buildlist.json</code>)</li><li>alias, URL, or path to a Tatin registry and optionally a (possibly incomplete) package ID</li></ul> <p>returns (as a 1-column matrix of strings) a list of deprecated packages.</p> <p>Only the last published version of a major version number is included. Set the <code>all</code> flag to include all versions of any major version  marked as deprecated.</p> <pre><code>      \u2395SE.Tatin.ListDeprecated '[tatin]'\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502aplteam-APLGit-0\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2374\u2395SE.Tatin.ListDeprecated 'https://tatin.dev'\n1 1\n</code></pre>"},{"location":"api/#list-licenses","title":"List licenses","text":"<pre><code>licences\u2190{verbose} ListLicences registry\n</code></pre> <p>Where <code>registry</code> is the URL or alias of a Tatin server and <code>verbose</code> is a flag (default 0), returns a list of licences.</p> <p>The result is a list of strings \u2013 if <code>verbose</code> is set, a 2-column matrix of which the first column is licence names and the second their URLsThe result is a list of strings \u2013 if <code>verbose</code> is set, a 2-column matrix of which the first column is licence names and the second their URLs.</p> <pre><code>      \u2395SE.Tatin.ListLicenses '[tatin]'\n Unlicense  CC0  0BSD  EPL  MIT  BSL  ISC  Apache  BSD-2  BSD-3\n      1 \u2395SE.Tatin.ListLicenses 'https://tatin.dev'\n Unlicense  https://en.wikipedia.org/wiki/Unlicense\n CC0        https://en.wikipedia.org/wiki/Creative_Commons_license#Zero_/_public_domain\n ...\n</code></pre>"},{"location":"api/#list-packages","title":"List packages","text":"<pre><code>packages\u2190{parms} ListPackages source\n</code></pre> <p>Where</p> parms namespace optional: parameter space source string <p>one of</p><ul><li>alias or URL of a Tatin registry or folder</li><li>path to an install folder containg a file <code>apl-buildlist.json</code></li><li>path to a registry and optionally a (possibly incomplete) package ID</li></ul> <p>returns (as a matrix) a list of packages.</p> <p>The result matrix lists all packages at the source except those where the last package of a major version has been deprecated. (See <code>ListDeprecated</code>).</p> <p>The result matrix has 2\u20134 columns:</p> 1 package ID 2 if <code>source</code> is a folder, a <code>'*'</code> flags principal packagesif <code>source</code> is a registry, the number of major versions [3] if <code>parms.date</code> is set, publication date [3|4] if <code>parms.projectUrl</code> is set, the project URL <p>Leaving aside any filters specified in <code>parms</code>, if <code>source</code></p> specifies a: result lists: registry all packages, aggregated by major version package ID without a full version number matching packages package name without a group name matching packages <p>Argument <code>parms</code> is optional; if specified, it must contain at least the first three parameters below.</p> aggregate flag aggregate results by minor and patch numbers (default 1) group string list only packages from this group tags string (comma separated, case-insensitive) list only packages with these tags date flag append a result column with publication dates packageID string package identifier: see below project_url flag append a result column with the project URL since int | string date as e.g. <code>20220601</code> or  <code>'2022-06-01'</code> or <code>'20220601'</code>: packages published earlier are ignored userCommand flag whether to list only packages that are user commands <p>Parameter <code>aggregate</code> combines with any package ID in <code>source</code> to determine what packages get listed.</p> package ID aggregate column 1 column 2 (empty) 1 all packages # of major versions (empty) 0 all packages <code>\u236c</code> {name} 0 packages that match name(might belong to different groups) # of major versions {group}-{name} 0 all versions of the package # of major versions {group}-{name} 1 all major versions of that package # of major versions {group}-{name}-{major} \u2013 all versions (minor and patch) # of major versions {group}-{name}-{major}-{minor} \u2013 all patch versions of the package ??? <pre><code>      \u2374r\u2190\u2395SE.Tatin.ListPackages '[tatin]'\n58 2\n      3\u2191[1] r\n abrudz-sort      1\n aplteam-ADOC     1\n aplteam-APLGit2  1\n</code></pre>"},{"location":"api/#list-registries","title":"List registries","text":"<pre><code>registries\u2190ListRegistries type\n</code></pre> <p>Where <code>type</code> is a flag or <code>\u236c</code>, returns as a matrix all registries specified in your config file.</p> <p>Result <code>registries</code> has columns:</p> <pre><code> 1 \u2013 Alias\n 2 \u2013 URL\n 3 \u2013 ID\n 4 \u2013 Port\n 5 \u2013 Priority\n 6 \u2013 No-caching flag\n 7 \u2013 Proxy\n[8 \u2013 API key]\n</code></pre> <p>If <code>type</code> is set the result has an eighth column containing the API key.</p> <pre><code>      \u2395SE.Tatin.ListRegistries \u236c\n tatin       https://tatin.dev/       29fbeb21-c6a0-4691-b6b6-8a ...\n tatin-test  https://test.tatin.dev/  2a282315-bfd6-4b15-8fe7-8c ...\n</code></pre> <p>The result of the API function and the user command differ.</p> <p>If the registry does not respond, Tatin signals an error.</p>"},{"location":"api/#list-tags","title":"List tags","text":"<pre><code>list\u2190{parms} ListTags registry\n</code></pre> <p>Where <code>registry</code> is the alias or URL of a registry, and <code>parms</code> is a parameter space, returns as a 2-column matrix all tags in use there:</p> <pre><code>1 \u2013 tag name\n2 \u2013 number of occurrences\n</code></pre> <p>If optional argument <code>parms</code> contains a list of tags (comma-separated string) as parameter <code>tags</code>, then the result lists only tags shared by packages that carry all the specified tags.</p> <pre><code>      p\u2190\u2395NS ''\n      p.tags\u2190'markdown'\n      p \u2395SE.Tatin.ListTags '[tatin]'\n converter  15\n help        8\n markdown   23\n</code></pre>"},{"location":"api/#list-versions","title":"List versions","text":"<pre><code>mat\u2190{dateFlag} ListVersions pkg\n</code></pre> <p>Where (optional) <code>dateFlag</code> is a flag and <code>pkg</code> identifies a package, returns a list of all versions of the package.</p> <p>String <code>pkg</code> is case-insensitive and can be</p> <ul> <li>a package name</li> <li>a group name and a package name</li> <li>a URL pointing to a registry together with a package name</li> <li>a registry alias and a package name</li> <li>a local path to a registry together with a package name</li> </ul> <p>A package name can be just the name or the group and the name. Also, you can specify a major version number, or a major and a minor version number.</p> <p>(Specifying a patch number makes no sense; if specified, it is ignored.)</p> <p>Examples:</p> <pre><code>'example-versions'\n'example-versions-1'\n'example-versions-1.0'\n'[tatin-test]versions'\n'[tatin-test]example-versions'\n'[tatin-test]example-versions-1'\n'[tatin-test]example-versions-1.0'\n'[tatin-test]example-versions-1.0.1' \u235d same as previous\n</code></pre> <p>In the first three cases known registries with a priority above zero are scanned.</p> <p>Result <code>mat</code> has a column with full package names.</p> <ul> <li>If <code>pkg</code> does not specify a registry, the first column is registry URLs.</li> <li>If <code>dateFlag</code> is set, a last column has publication dates.</li> </ul> <p><pre><code>      1 \u2395SE.Tatin.ListVersions 'MarkAPL'\n https://tatin.dev/  aplteam-MarkAPL-11.0.0  20210427.09\n https://tatin.dev/  aplteam-MarkAPL-11.0.1  20210725.15\n https://tatin.dev/  aplteam-MarkAPL-11.0.2  20211012.07\n https://tatin.dev/  aplteam-MarkAPL-11.0.3  20220509.17\n ...\n\n      \u2374 \u2395SE.Tatin.ListVersions '[tatin]MarkAPL'\n15 1\n</code></pre> If version precedence cannot be established from the version numbers alone (often a problem with beta versions) then the publishing date is taken into account.</p>"},{"location":"api/#load-dependencies","title":"Load dependencies","text":"<pre><code>{refs}\u2190{options} LoadDependencies folder [target]\n</code></pre> <p>Where</p> options 2 flags optional: default 0 folder string path to package source folder, or <code>'[MyUCMDs]'</code> target reference optional: target namespace <p>Loads all packages into <code>target</code> according to a build list in <code>folder</code> and returns a list of references to the loaded packages. (Principal packages only, not dependencies.)</p> <p>If unspecified the <code>target</code> namespace defaults to <code>#</code>, unless <code>folder</code> is <code>'[MyUCMDs]'</code>, when it defaults to <code>\u2395SE</code>.</p> <p>The  flags in <code>options</code>:</p> <ol> <li>Overwrite if the package is already loaded</li> <li>Make home relative. See details below.</li> </ol> <p>User commands</p> <p>Case-insensitive alias <code>'[MyUCMDs]'</code> denotes the special folder <code>MyUCMDs/</code>, whose location depends on the operating system.</p> <p>So where a Tatin package has been installed as a user command (and perhaps bundled into the Dyalog runtime) you cannot use absolute paths for referring to assets.</p> <p>In that case the paths must be relative to <code>MyUCMDs/</code>. This is what the second <code>options</code> flag is for.</p> <p>The flag affects the result of <code>HOME</code> and <code>GetFullPath2AssetsFolder</code>.  Rather than returning the full path, only the folder containing the packages, and its parent are returned, making it a relative path.</p> <p>Where no name is specified after <code>[MyUCMDs]</code> the subfolder is named after the package.</p> <p>To install multiple user-command packages, specify no name after <code>[MyUCMDs]</code> \u2013 otherwise Tatin signals an error.</p>"},{"location":"api/#load-packages","title":"Load packages","text":"<pre><code>no\u2190{noBetas} LoadPackages (identifiers targetSpace)\n</code></pre> <p>Where</p> noBetas flag optional: ignore beta versions; default 0 identifiers string comma-separated list of packages targetSpace ref fully-qualified namespace: target <p>Tatin loads packages dynamically into the target space and returns the number of principal packages loaded.</p> Detail <p>Tatin actually loads the package into <code>[#|\u2395SE]._tatin.{packageName}</code> and puts a reference to it in <code>targetSpace</code>.</p> <p>Also loads any dependencies into <code>[#|\u2395SE]._tatin</code> but does not create references for them in <code>targetSpace</code>.</p> <p>In <code>identifiers</code> specify a package as one of</p> <ul> <li>an HTTP request</li> <li>a ZIP file containing a package</li> <li>a folder containing a package, e.g. <code>'file://C:/Temp/group-name-version'</code></li> <li>a path to a package in a registry, e.g. <code>'[RegistryAlias]{packageID}'</code> or <code>'C:\\MyReg\\{packageID}'</code></li> <li>a package ID</li> </ul> <p>Where a package is specified as a package ID, Tatin searches the registries it knows with a priority above 0. The first hit wins.</p> <p>If the target space already exists but is not an ordinary namespace, Tatin signals an error.</p>"},{"location":"api/#ping","title":"Ping","text":"<pre><code>flag\u2190Ping source\n</code></pre> <p>Where <code>source</code> is</p> <ul> <li>a registry alias or URL, <code>flag</code> is whether the host is up and running</li> <li>a folder, <code>flag</code> is whether it exists</li> </ul> <pre><code>      \u2395SE.Tatin.Ping '[tatin]'\n1\n      \u2395SE.Tatin.Ping 'https://tatin.dev'\n1\n\n      \u2395SE.Tatin.Ping '/Users/sjt/tmp/Foo'\n1\n</code></pre>"},{"location":"api/#publish-package","title":"Publish package","text":"<pre><code>{fn}\u2190{deps} PublishPackage (source registry)\n</code></pre> <p>Where</p> deps parm space optional: argument for <code>BuildPackage</code> source string folder from which to create the package registry string registry to which to publish the package <p>Tatin</p> <ol> <li>Confirms no package has already been published to the registry under this name (case insensitive).</li> <li>If <code>source</code> is a folder, uses <code>BuildPackage</code> to zip the package into a temp folder; <code>deps</code>, if specified, is passed as the argument.</li> <li>Moves the ZIP into the registry</li> <li>If the registry is local, updates its index</li> </ol> <p>and returns</p> rc HTTP return code (whether the registry is remote or not) emsg error message: empty if <code>rc</code> is 200 zfn zip file name: empty if <code>source</code> is a ZIP file, otherwise name of the ZIP file created <p>Delete policy</p> <p>The package is published no matter what the server\u2019s delete policy is.</p> <p>That differs from the user command, which asks you to confirm publication of a package that cannot then be deleted.</p>"},{"location":"api/#reinstall-dependencies","title":"Reinstall dependencies","text":"<pre><code>{refs}\u2190{parms} ReInstallDependencies deps folder [reg]\n</code></pre> <p>Where</p> parms parm space optional: typically created by calling <code>CreateReInstallParms</code> deps ??? ??? folder string target folder: contains <code>apl-dependencies.txt</code> reg string optional: registry alias or URL <p>Tatin, in the target folder,</p> <ol> <li>deletes file <code>apl-buildlist.json</code> and all directories</li> <li>re-installs all files listed in <code>apl-dependencies.txt</code> (ignoring lines that start with a lamp <code>\u235d</code>)</li> </ol> <p>and returns a list of references to the principal packages installed.</p> <p>Packages originally installed from ZIP files are just re-installed from their ZIP files without further ado.</p> <p>If <code>reg</code> is omitted Tatin scans all known registries with a priority above <code>0</code>. (Packages with different major version numbers are considered as different packages.)</p> <p>Optional argument <code>parms</code> can specify three flags. All default to 0,</p> noBetas Ignore beta versions update Update to a later version if available dry Report what the function would do but don\u2019t do it Registry scans <p>For each dependency Tatin scans known registries, even if <code>reg</code> was specified.</p> <p>Tatin queries every known registry with a priority above 0, highest priority number first. First hit wins.</p> <p>If you installed a package from a Tatin registry and later removed that registry from your user settings, or set its priority to 0, then <code>ReInstallDependencies</code> will not scan it, despite knowing perfectly well where the package came from.</p>"},{"location":"api/#read-package-config-file","title":"Read package config file","text":"<pre><code>cfg\u2190ReadPackageConfigFile path\n</code></pre> <p>Where <code>path</code> is a path to a package Tatin returns its config file as a parameter namespace.</p> <p>The <code>path</code> argument may optionally include the config file name <code>apl-package.json</code>.</p> <pre><code>      path\u2190'path/to/packages/aplteam-APLTreeUtils2-1.4.0'\n      q\u2190\u2395SE.Tatin.ReadPackageConfigFile path\n      showParms q\napi               : APLTreeUtils2\nassets            :\ndate              : 20240325.14\ndescription       : General utilities required by most members of the APLTree library\ndocumentation     :\nfiles             :\ngroup             : aplteam\nio                : 1\nlicense           : MIT\nlx                :\nmaintainer        : kai@aplteam.com\nminimumAplVersion : 18.0\nml                : 1\nname              : APLTreeUtils2\nos_lin            : 1\nos_mac            : 1\nos_win            : 1\nproject_url       : https://github.com/aplteam/APLTreeUtils2\nsource            : APLSource/APLTreeUtils2.aplc\ntags              : tools,utilities\nuri               : https://tatin.dev/\nuserCommandScript :\nversion           : 1.4.0+78\n</code></pre>"},{"location":"api/#uninstall-packages","title":"Uninstall packages","text":"<pre><code>(list emsg)\u2190UnInstallPackage (packageID folder)\n</code></pre> <p>Where</p> packageID string a full package ID or an alias folder string <p>either</p><ul><li>path to a package folder with a Tatin dependency file<code>apl-dependencies.txt</code></li><li><code>'[MyUCMDs]'</code> (case-insensitive)</li></ul> <p>Tatin attempts to un-install the package <code>packageID</code> and any of its dependencies (that are neither principal packages nor required by other packages) and returns:</p> list strings Fully qualified names of all removed packages. (Might include aliases.) emsg string Error message, ideally empty. <p>If the package was installed with an alias then <code>packageID</code> must be its alias.</p> <p>If <code>packageID</code> matches more than one package, Tatin signals an error</p> <p>If <code>packageID</code> is empty, Tatin attempts to clean up: remove any packages that are neither principal packages nor required by other packages</p> <p>Deleting parent folders</p> <p>Removing the folders hosting the packages might fail for all sorts of reasons, even after successfully removing the package and any dependencies from both the dependency file and the build list. </p>"},{"location":"api/#version","title":"Version","text":"<pre><code>r\u2190Version\n</code></pre> <p>Returns as strings Tatin\u2019s name, version and date.</p> <pre><code>      \u2395SE.Tatin.Version\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Tatin\u25020.112.1+1942\u25022024-08-16\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"contribute/","title":"Contribute to Tatin","text":"<p>Tatin is published under the MIT licence, and you are welcome to contribute to it.</p> <p>Tatin is not owned by anybody; it is a community project.</p>"},{"location":"contribute/#requirements","title":"Requirements","text":"<p>To work on Tatin you need</p> <p> How to contribute to a GitHub project</p> <ul> <li>Git and a GitHub account</li> <li>Dyalog 18.2 Unicode or better (Classic is not supported)</li> <li>.NET installed and Link activated</li> <li>Cider</li> </ul> <p>Operating system Linux, macOS, or Windows. AIX is not supported.  The Raspberry Pi is not officially supported but might work anyway.</p> <p>You can develop on any operating system, but building a new version is currently supported only on Windows.</p>"},{"location":"contribute/#managed-by-cider","title":"Managed by Cider","text":"<p>Tatin is managed by the Cider project management tool. If you are new to Cider, spend some time playing with it before using it for serious work. (Thirty minutes should suffice.)</p> Working without Cider <p>While it is possible to make changes or add code to Tatin without Cider, using Cider makes it significantly easier. And the build process requires Cider.</p> <p>That said, you are not required to build a new version before submitting a pull request, so you might get away without Cider, but using Cider is certainly recommended.</p>"},{"location":"contribute/#get-started","title":"Get started","text":"<ol> <li> <p>On GitHub make your own fork of Tatin and clone it to your local machine, say at <code>C:\\Tatin</code>.</p> </li> <li> <p>Launch Dyalog and open the project</p> <pre><code>]CIDER.OpenProject C:\\Tatin\n</code></pre> </li> </ol> <p>Now you have a working version of Tatin on your machine and you can start contributing.</p> <p>No need to save a workspace</p> <p>Every function, operator, class, interface or namespace script changed in <code>#.Tatin</code> is automatically saved to disk by Link.</p>"},{"location":"contribute/#code","title":"Code","text":"<p>To modify the source code:</p> <ol> <li> <p>Open an issue on the GitHub repository and declare what you intend to do.     GitHub will assign an ID number to your issue.</p> </li> <li> <p>On your local machine, create a branch of <code>main</code> and name it after your issue.      For example, if your issue is Foo is failing in bar and has ID 123, name your branch <code>123-fix-foo-bar</code>.</p> </li> <li> <p>Before finishing, confirm your branch <code>123-fix-foo-bar</code> passes the Tatin tests.</p> </li> <li> <p>On GitHub, synch your fork with the source repo.     On your local machine, pull the <code>main</code> branch from your GitHub fork; then merge <code>main</code> into <code>123-fix-foo-bar</code>.      Confirm  your branch <code>123-fix-foo-bar</code> passes the Tatin tests.</p> </li> </ol> <p>If your changes pass the tests, push <code>123-fix-foo-bar</code> to your fork, and submit a pull request.</p>"},{"location":"contribute/#documentation","title":"Documentation","text":"<p>If you find parts of this guide confusing, outdated, unclear or missing bits and pieces, change it. That might well be your first valuable contribution.</p> <p>A minor edit to the documentation does not require its own issue and branch; it can be made in the <code>main</code> branch.</p>"},{"location":"contribute/#submit-your-changes","title":"Submit your changes","text":"<p>When you have improved the documentation, fixed a bug, or added a feature, create a pull request (PR). The project team will check your contribution.</p>"},{"location":"create-version/","title":"Create a new version of Tatin","text":"<p>How to create a new version of Tatin.</p> <p>A contributor\u2019s job is done once they have submitted a Pull Request (PR) on GitHub.</p> <p>This article is about what an administrator of the Tatin project on GitHub does after accepting a PR or finishing work on a branch.</p>"},{"location":"create-version/#check-version-history-and-documentation","title":"Check version, history and documentation","text":"<p>A version comprehends both server and client, so the version number is always the same for both.</p> <ol> <li>Check <code>#.Tatin.Registry.Version</code> is correct</li> <li>Check <code>#.Tatin.Registry.History</code> is correct</li> <li>Check the document <code>docs/source/release-notes.md</code> is correct</li> <li>Proofread the documentation</li> </ol> <p>A function creates a single HTML file from all the Markdown documentation, making proofreading much easier:</p> <pre><code>      htmlFilename\u2190#.Tatin.Admin.CreateProofReadDocument 1\n</code></pre> <p>Open that file with the word processor of your choice and use its spell-checking capabilities.</p>"},{"location":"create-version/#run-the-make-function","title":"Run the <code>Make</code> function","text":"<pre><code>#.Tatin.Admin.Make 0\n</code></pre> <p>Ask Cider</p> <p>You can ask Cider how to create a new version of Tatin:</p> <pre><code>]CIDER.Make\n</code></pre> <p>The <code>Make</code> function launches two instances of Dyalog, one for creating the client version, one for creating the server version:</p> <ol> <li>runs <code>#.Tatin.Admin.MakeClient</code></li> <li>compiles the documentation from Markdown into HTML files and distributes them</li> <li>runs <code>#.Tatin.Admin.MakeServer</code></li> </ol> <p>The build ID is always bumped when you create a new version.</p>"},{"location":"create-version/#arguments","title":"Arguments","text":"<p>The arguments to <code>Make</code> are both flags:</p> right Suppress user prompts: 1 is suitable for, say, a batch script.If 0, <code>Make</code> will ask whether you want to try updating the packages Tatin itself depends on, and whether to copy the new version of the Tatin Client to the <code>MyUCMDs/</code> folder. left (optional) Block the <code>load</code> and <code>lx</code> command-line options in instances of Dyalog started to create the Client and the Server, thus preventing the interpreter from immediately running the code, and allowing you to run the code in the Tracer. (Defaults to zero.)"},{"location":"create-version/#distribution-files","title":"Distribution files","text":"<p>The <code>Dist/</code> folder gets replaced. It contains the ZIPs to be released on GitHub; <code>.gitignore</code> prevents the folder appearing on GitHub.</p> <p>The ZIPs:</p> <pre><code>Tatin-Client-{major}.{minor}.{patch}.zip\nTatin-Documentation-{major}.{minor}.{patch}.zip\nTatin-Server-{major}.{minor}.{patch}.zip\n</code></pre>"},{"location":"develop/","title":"Developing","text":"<p>To make changes or add new features you need a good understanding of the basic design of Tatin.</p>"},{"location":"develop/#tatin-code","title":"Tatin code","text":"<p>Four ordinary namespaces contain the Tatin code.</p> <code>Admin</code> Helpers useful to administrate Tatin, for example creating a new version, performing maintenance tasks etc. <code>Client</code> The code executed on the Client side of Tatin. <code>Registry</code> All code shared by a Tatin client and a Tatin server. <code>Server</code> The code to run a Tatin Server"},{"location":"develop/#dependencies","title":"Dependencies","text":"<code>Plodder</code> A fully-fledged HTTP server based on Rumba and Conga <code>RumbaLean</code> An implementation of HTTP 1.1 in APL <p>These two packages are used by, but do not form part of, the Tatin project.</p>"},{"location":"develop/#server-handlers","title":"Server handlers","text":"<p>The main server handlers are:</p> <pre><code>#.Tatin.Server.OnRequest\n#.Tatin.Server.OnHouseKeeping\n</code></pre> <p><code>OnRequest</code> will eventually call one of these:</p> <pre><code>Handle_GET\nHandle_PUT_And_POST\nHandle_Delete\n</code></pre> <p>These call the Tatin functions that perform the real actions.</p>"},{"location":"develop/#server-certificates","title":"Server certificates","text":"<p>The Tatin server comes with test certificates.</p> <p>GitHub prohibits downloading certificates, so the certificate files have an additional extension <code>.RemoveMe</code> which needs, well\u2026 removing.</p> <p>Check the folder <code>TestServer/Server/Assets/Runtime/Certificates</code>.</p>"},{"location":"develop/#set-the-development-flag","title":"Set the DEVELOPMENT flag","text":"<p>By default, code for user commands and API calls is stored and executed in <code>\u2395SE</code> \u2013 but</p> <p>Link does not save changes to code in <code>\u2395SE</code>.</p> <p>This stumbling block was addressed in version 0.106.0 with the <code>\u2395SE._Tatin.DEVELOPMENT</code> variable. Now, when Cider opens the Tatin project it asks:</p> <pre><code>Set DEVELOPMENT\u21901 in \u2395SE._Tatin?\n(Allows executing user command code in # rather than \u2395SE)\n(Y/n)\n</code></pre> <p>Setting the flag tells Tatin to execute user commands and API calls using the code in <code>#</code>, where Link will save any changes you make.</p> <p>If the flag is not set Cider  will execute code in <code>\u2395SE</code> as usual.</p> <p>If the flag is already set to zero, Cider will not ask if you want to change it.</p>"},{"location":"develop/#developing-with-a-running-server","title":"Developing with a running server","text":"<p>You could run a Tatin server as an open Cider project and investigate what the code in the running server is doing, with Link saving any changes and additions you make.</p> <p>You might even want to run the server in one workspace as an opened Cider project, while running the test cases in another workspace, also as an opened Cider project.</p> <p>You would need to be very careful lest you lose code. (See warning box below.)</p> <p>Suppose you want to run the Tatin server that is part of the Tatin project. When the Tatin test cases are executed, Tatin would ask you whether you want to start this server automatically. (Not <code>https://test.tatin.dev</code>.)</p> <p>However, when the server is started as part of the tests it is NOT opened as a Cider project, and changes would not be tracked by Link. To link the running server code to its source files:</p> <ol> <li>Open the Tatin project with <code>]CIDER.OpenProject</code> with the <code>watch</code> parameter set to <code>'both'</code>.</li> <li>Run the function <code>#.Tatin.TestCasesServer.RunTests</code></li> </ol>"},{"location":"develop/#opening-tatin-as-a-project-in-two-workspaces","title":"Opening Tatin as a project in two workspaces","text":"<p>In developing Tatin it is natural to have two Dyalog instances running: one each for the client and server code.</p> <p>The test server must be run in its own instance: you cannot run both the client and the server in the same workspace.</p> <p>Opening Tatin as a project in two different workspaces, and changing code in both is dangerous!</p> <p>With .NET you can limit the danger:</p> <ul> <li>Set Link\u2019s <code>Notify</code> parameter to 1. That makes Link print to the session whenever it updates a file or the workspace, so you get some feedback on what is happening. Ensure you watch this!</li> <li>Set Link\u2019s <code>watch</code> parameter to <code>'both'</code> in both workspaces.</li> </ul> <p>Without .NET</p> <p>On non-Windows platforms with no .NET available, <code>watch=both</code> is not an option, so that is particularly dangerous.</p> <p>Then when you change an APL object in one workspace, it will not only be written to disk: Link will also bring that change into the other workspace.</p> <p>This is particularly important when you change code in the <code>Tatin.Registry</code> namespace, because that code is shared between the client and the server.</p> <p>Watching Link\u2019s reports in the session is important: the .NET mechanism used by Dyalog works most of the time but not always, so it is important to watch for problems.</p> <p>If you just want to run the test server, close the project before executing</p> <pre><code>#.Tatin.TestCasesServer.RunTests\n</code></pre>"},{"location":"develop/#trapping-errors","title":"Trapping errors","text":"<p>Error trapping is active, so if you change a function and inject a typo, it will trigger error trapping when the code gets executed.</p> <p><code>\u235dTODO\u235d</code> reminders</p> <p><code>\u235dTODO\u235d</code> is a reminder that won\u2019t go unnoticed: a test case detects and reports these markers and reports them.</p> <p>To avoid locking horns with error trapping, you could put into <code>OnRequest</code></p> <pre><code>\u2395TRAP\u21900 'S'  \u235dTODO\u235d\n</code></pre> <p>Also, make <code>\u2395TRAP</code> a local variable in <code>OnRequest</code>.</p>"},{"location":"develop/#updating-tatins-own-dependencies","title":"Updating Tatin\u2019s own dependencies","text":"<p>Tatin depends on a couple of Tatin packages, but it cannot be used to load them \u2013 the classic bootstrap problem.</p> <p>To update a package installed in the <code>packages/</code> folder, bring it into the <code>APLSource/</code> folder by other means:</p> <ul> <li>A single class or namespace script can simply be copied over; for example, the <code>Tester2</code> class.</li> <li>An ordinary namespace needs to be copied over as a folder; for example, <code>CommTools</code>.</li> </ul>"},{"location":"develop/#special-rest-commands","title":"Special REST commands","text":"<p>A Tatin server can support several special REST commands for developing and testing.</p> <p>These commands are enabled (or not) by the INI entry <code>[CONFIG]SpecialCommands</code>. They should never be supported on a production server.</p> <p>For example, one command returns an HTML page with all the available commands: navigate to <code>https://localhost:5001/v1/list-commands</code>.</p> <p>The other commands do not return HTML but trigger actions.</p>"},{"location":"get-started/","title":"Get started with Tatin","text":"<p>Install, load and use a Tatin package</p>"},{"location":"get-started/#install","title":"Install","text":"Dyalog 19.0Dyalog 18.2 <p>Tatin is already installed. Activate it.</p> <pre><code>]Activate Tatin\n</code></pre> <p>See Older Versions.</p>"},{"location":"get-started/#look-for-registries","title":"Look for registries","text":"<p>Initially Tatin knows only the principal and test Tatin registries.</p> <pre><code>      ]TATIN.ListRegistries\n Alias       URL                      ID          \n ----------  -----------------------  -------     \n tatin       https://tatin.dev/       29fbeb2 ... \n tatin-test  https://test.tatin.dev/  2a28231 ... \n</code></pre> <p>When you want to start using other Tatin registries, remote or on your local machine, edit the user settings.</p>"},{"location":"get-started/#look-for-packages","title":"Look for packages","text":"<p>List all the packages on the principal registry.</p> <p><pre><code>      ]TATIN.ListPackages\n Registry: https://tatin.dev              \u2262 60\n Group &amp; Name                 # major versions\n ------------                 ----------------\n abrudz-sort                                 1\n aplteam-ADOC                                1\n aplteam-APLGit2                             1\n aplteam-APLGUI                              1\n aplteam-APLProcess                          1\n ...\n</code></pre> Each package is identifed by a name and group name. The listing shows the number of major versions of the package.</p> <p> Semantic versioning</p> <p>You can restrict the listing to a single group.</p> <pre><code>]TATIN.ListPackages -group=davin\n</code></pre> <p>Packages are tagged. <pre><code>      ]TATIN.ListTags\n All tags from https://tatin.dev\n -------------------------------\n  data\n  grid\n  import\n  page\n  read\n  ...\n\n      ]TATIN.ListPackages -tag=markdown\n Registry: https://tatin.dev               \u2262 4\n Group &amp; Name                 # major versions\n ------------                 ----------------\n aplteam-Laguntza                            2\n aplteam-MarkAPL                             3\n</code></pre></p>"},{"location":"get-started/#install-packages","title":"Install packages","text":"<p>Suppose you want to use the <code>MarkAPL</code> package in an application you are developing, which we will call a project. Suppose the project lives in <code>/Foo</code>.</p> <p>Install the package as part of the Foo project. <pre><code>      ]TATIN.InstallPackages MarkAPL /Foo/packages\n\nSure you want to create and install into\n/Foo/packages ? (Y/n) Y\n Installed into /Foo/packages:\n  aplteam-MarkAPL-13.1.0\n In order to load all dependecies (including newly installed ones) into the WS execute:\n       ]TATIN.LoadDependencies \"/Foo/packages\"\n</code></pre> <code>MarkAPL</code> specifies neither group nor version number. The name is unique on the principal registry; the latest version is installed by default.</p> <p>The <code>/Foo/packages</code> folder has been created and contains:</p> <pre><code>apl-buildlist.json\napl-dependencies.txt\naplteam-APLTreeUtils2-1.4.0\naplteam-CommTools-1.8.1\naplteam-FilesAndDirs-5.8.0\naplteam-MarkAPL-13.1.0\naplteam-OS-3.1.1\n</code></pre> <p>(You might see different version numbers.)</p>"},{"location":"get-started/#load-packages","title":"Load packages","text":"<p>MarkAPL has been installed in the project. Now load it into the active workspace.</p> <p>MarkAPL is one (the only one) of the dependencies of Foo. <pre><code>      ]tatin.LoadDependencies /Foo/packages #.Foo\n#._tatin.aplteam_MarkAPL_11_0_1\n</code></pre></p> <p>Tatin is taciturn</p> <p>Tatin works quietly by default. Use the <code>-verbose</code> flag if you need to see more of what is going on when packages are loaded.</p>"},{"location":"get-started/#documentation","title":"Documentation","text":"<p>We now have <code>#.Foo.MarkAPL</code> loaded \u2013 but how do we use it?</p> <p>The ADoc convention lets Tatin packages include their own documentation.</p> <p><pre><code>      ]ADoc #.Foo.MarkAPL\n]Open /private/tmp/sjt_114214886.html\nWatch your browser\n</code></pre> Executing the <code>]Open</code> user command pops a browser window. <pre><code>      ]Open /private/tmp/sjt_114214886.html\n</code></pre></p> <p></p>"},{"location":"get-started/#test","title":"Test","text":"<p>Test an example from the documentation. <pre><code>      MyMarkdown\u2190'# MarkAPL' 'All about **_MarkAPL_**'\n      (html ns)\u2190#.Foo.MarkAPL.Markdown2HTML MyMarkdown\n      \u2191html\n&lt;div class=\"h_tag\"&gt;\n&lt;a href=\"#markapl\" id=\"markapl\" class=\"autoheader_anchor\"&gt;\n&lt;h1 data-id=\"MarkAPL\"&gt;MarkAPL&lt;/h1&gt;\n&lt;/a&gt;\n&lt;/div&gt;\n&lt;p&gt;All about &lt;strong&gt;&lt;em&gt;MarkAPL&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n      ns\n#._tatin.aplteam_MarkAPL_13_1_0.[Namespace]\n</code></pre> Congratulations You have installed a Tatin package in your project, loaded it into your active workspace, and confirmed you can use it.</p> <p>Cider depends on Tatin</p> <p>If you use Cider:</p> <ul> <li>Deactivate and remove it before Tatin</li> <li>Re/Install Tatin before Cider.</li> </ul>"},{"location":"get-started/#deactivate","title":"Deactivate","text":"<p>To remove Tatin and/or Cider from the installation folder:</p> <pre><code>]Deactivate [all|cider|tatin] [-versionagnostic]\n</code></pre>"},{"location":"github/","title":"Tatin &amp; GitHub","text":"<p>Tatin is version-controlled by Git and hosted on GitHub.</p> <p>There is no limit for accessing GitHub with a browser, but there are limits for what you can do when accessing GitHub via its API.</p>"},{"location":"github/#githubs-limit-policy","title":"GitHub\u2019s limit policy","text":"<p>GitHub has a fairly complex limit policy, which means that above a certain threshold further requests will be rejected for a period of time, typically one hour.</p> <p>It is very unlikely that an ordinary Tatin user could hit this limit, because with a Tatin client, the only command that accesses GitHub via the API is <code>UpdateTatin</code>. With a Tatin server, it does not matter at all.</p> <p>However, there might be circumstances where you hit this anyway because other parts of your workflow also access GitHub. You can overcome the limitation by specifying a GitHub personal access token (PAT).</p> <p>Save the PAT in the Tatin client folder in a file named <code>GitHub-personal-token.txt</code>, and the problem is solved: the restrictions get relaxed to where they affect only abusers.</p>"},{"location":"glossary/","title":"Glossary","text":"<p>Some terms used in the Tatin documentation</p> beta <p>A package with a text description in its patch.</p> <p>(See version and examples of full package ID.)</p> build number <p>Tatin assigns each version a build number, in chronological sequence.</p> <p>This is not part of the version. Tatin treats two packages that differ only in build number as the same version of the same package.</p> <p>(See examples of full package ID.)</p> constant A niladic function or a variable. (Same syntax, but the former is immutable.) dependency Contrary to normal usage, a dependency of a package <code>foo</code> is another package on which <code>foo</code> depends. flag <p>The meaning depends on context:</p> <ul> <li>In the API or configuration, a boolean; a flag is \u2018set\u2019 with 1.</li> <li>In the user commands, a parameter without a corresponding value: for example in <code>]TATIN.PackageConfig -edit</code>, the <code>edit</code> flag is set.</li> </ul> full package ID <p>A package is uniquely identified by its full package ID: group, name, and version.</p> <p>Group, name and version are separated by hyphens. When shown, a build number is separated from the patch by a plus sign.</p> <p>Some examples:</p> <pre><code>apltree-Foo-1.0.0\napltree-Foo-1.0.1+123\napltree-Foo-1.0.1-alpha-1         \u235d beta\napltree-Foo-1.0.2-alpha-1+127     \u235d beta\n</code></pre> fully qualified namespace A reference beginning with <code>#.</code> or <code>\u2395SE.</code> Known Registries <p>Registries specified in your user settings</p> <p>A registry scan searches known registries with a priority above zero, in descending order of priority.</p> Maintenance Library A child folder <code>Maintenance/</code> of the the Tatin server installation folder, containing maintenance scripts. package alias A short name you can use locally as an alternative to a full package ID. (Allows you to work with multiple versions of the same package.) package cache <p>A namespace that holds the contents of a package.</p> <p>By convention there are two: <code>#._tatin</code> and <code>\u2395SE._tatin</code>. Both are referred to by objects in the workspace; neither should be named in your code.</p> package ID <p>A case-insensitive pattern for matching against full package names: the name of a package, possibly also including its group; major version number; major and minor version numbers; or major and minor version and patch numbers. Examples:</p> <pre><code>'MarkAPL'                  \u235d name\n'aplteam-MarkAPL'          \u235d group-name\n'MarkAPL-11'               \u235d name-major\n'APLTEAM-MARKAPL-12.1'     \u235d group-name-major-minor\n'MarkAPL-13.1.2'           \u235d name-major-minor-patch\n'aplteam-MarkAPL-13.1.2'   \u235d group-name-major-minor-patch\n</code></pre> package space <p>The namespace in which the package is actually stored.</p> <p>For example, if Tatin loads package MarkAPL 13.1.0, it creates a namespace <code>#.MarkAPL</code> containing references to the objects in MarkAPL\u2019s API. Those references point to objects in the package space, where Tatin puts the actual MarkAPL objects, e.g. <pre><code>#._tatin.aplteam_MarkAPL_13_1_0\n</code></pre></p> parameter space A namespace of variables representing parameters Plodder <p>A generalized HTTP server, used by Tatin, based on Rumba and Conga.</p> <p>For details see https://github.com/aplteam/Plodder</p> registry alias A short name you can use locally as an alternative to its URL. <p>Tatin is installed with <code>tatin</code> and <code>tatin-test</code> as aliases for the Principal Registry and the Test Server.</p> string A character vector, e.g. <code>'abc def'</code> strings A vector of strings, e.g. <code>'abc' 'def'</code> version <p>A version follows the conventions of Semantic Versioning: and comprises major and minor versions (integers) and a patch, separated by periods, e.g. <code>1.0.3</code></p> <p>A patch is also an integer, but may be followed by a hyphen and a text description, indicating a beta version, e.g. <code>1.0.3-trial</code>.</p> <p>A new</p> <ul> <li>major version marks a breaking change</li> <li>minor version marks a non-breaking change</li> <li>patch marks a change in implementation</li> </ul> <p>(See examples of full package ID.)</p>"},{"location":"host/","title":"Host a Tatin registry","text":"<p>Host a personal, team, corporate, or public Tatin registry.</p> <p>You can host a Tatin registry server on your local machine, an intranet, or on a public server.</p>"},{"location":"host/#requirements","title":"Requirements","text":"<ul> <li>Dyalog Unicode 18.2 or better</li> <li>Linux or Windows</li> </ul> <p>The server should run under macOS in a Docker container, but this has not been tested.</p>"},{"location":"host/#plodder","title":"Plodder","text":"<p>Tatin uses Plodder as an HTTP/S server. Its INI file is a Plodder INI file with some extra settings.</p>"},{"location":"install-server/","title":"Install a registry server","text":"<p>How to install and update your own Tatin registry server</p>"},{"location":"install-server/#download","title":"Download","text":"<p>Download the Tatin Server ZIP from the Releases page and unzip it into the installation folder.</p>"},{"location":"install-server/#configure","title":"Configure","text":"<p>Local variable</p> <p>Before the first section declaration (<code>[CONFIG]</code>), local variable <code>home</code> is assigned <code>'&lt;INIFILE&gt;/'</code>.</p> <p>References to <code>{home}</code> get replaced by its value.</p> <p>Edit the configuration file <code>Server/server.ini</code>.</p> <p>Plodder INI files have unusual features.<sup>1</sup> The most important are</p> <ul> <li>typed data: put text in quotes; anything else is numeric</li> <li>you can define local variables</li> </ul> <p>When the Tatin Server loads the INI file, it replaces <code>&lt;INIFILE&gt;</code> with the fully qualified path of the INI file.</p> <p>See  aplteam/Plodder for INI file settings. Here are those you are likely to change for your Tatin server.</p>"},{"location":"install-server/#app","title":"<code>APP</code>","text":"<p>Connect Plodder to the Tatin logic: see Plodder documentation.</p> <p>The <code>On*</code> handlers are Tatin-specific entry points. You might want to add something to <code>OnHouseKeeping</code>, or add a handler <code>OnHeader</code>, but that is pretty unusual.</p>"},{"location":"install-server/#certificates","title":"<code>CERTIFICATES</code>","text":"<p>A certificate is required to use HTTPS. (Recommended for public-facing servers.)</p> <p>On the Web, use a reverse proxy to hide Tatin behind a Web server</p> <p>If you use a reverse proxy, you might not need encryption (HTTPS) and certificates.</p>"},{"location":"install-server/#config","title":"<code>CONFIG</code>","text":"AppName Name used by Tatin for logging into the Windows Event Log.The setting has no meaning on non-Windows platforms, and is ignored if <code>[LOGGING]WindowsEventLog</code> is 0. BaseBaseTagPort (Ignored from version 0.104.0.) Caption <code>H1</code> element for HTML pages. DeletePackages Deleting packages is: 0 \u2013 not allowed; 1 \u2013 allowed; 2 \u2013 allowed only for betas.The Principal Registry will not delete anything. A build can always be reproduced. Registry Path to the the registry. ReloadWS Flag: whether Tatin frequently checks for and reloads new versions of workspace <code>Server.dws</code>, meaning it will (kind of) restart itself.Not recommended in production, but can be helpful in development. Secure Flag: whether certificates are used (HTTPS) or not (HTTP). Title Browser window or tab title for HTML pages."},{"location":"install-server/#email","title":"<code>EMAIL</code>","text":"<p>Your Tatin server can send alerts by email.</p>"},{"location":"install-server/#license","title":"<code>LICENSE</code>","text":"<p>Names of the licences (and URLs to their definitions) the server accepts.</p> <p>The INI section is optional. if absent, the website shows no Licensing menu item, and the server accepts any license, including packages that lack a <code>license</code> property.</p> <p>By convention, <code>BuildPackage</code> copies any file <code>LICENSE</code> in the root of the project to the root of a package. This convention is independent of the INI file.</p> <p>The text on the server web page is defined in <code>Assets/snippets/Licensing.md</code>.</p>"},{"location":"install-server/#logging","title":"<code>LOGGING</code>","text":"<p>Control how much information Tatin logs.</p> Log Flag: log at high level. Keep set. LogHTTPLogCongaLogRumba Flags: log at low level. WindowsEventLog Flag: write to the Windows Event Log. (Recommended, but Windows only.) <p>IP addresses are not logged at the high level. They are logged at the low level, which can be useful for development, but in some jurisdictions may not be legal on internet servers.</p>"},{"location":"install-server/#msg","title":"<code>MSG</code>","text":"<p>Inject a message into every HTML page; for example to announce downtime due to maintenance.</p> Text Unless empty, inject as <code>&lt;div&gt;&lt;p&gt;{text}&lt;/p&gt;&lt;/div&gt;</code> CSS Unless empty, inject into the Text <code>&lt;div&gt;</code> as <code>style=\"{css}\"</code>"},{"location":"install-server/#start-a-local-tatin-server","title":"Start a local Tatin server","text":"<p>Start an instance of Dyalog with ample memory, and load the workspace <code>Server.dws</code>. The Latent Expression starts the server.</p> <p>Most foreseeable errors (bugs in Tatin etc.) are trapped and return a 500 (Internal Server Error) response but do not stop the server. However, errors such as an aplcore or a WS FULL could bring the server down.</p> <p>On Windows </p> <p>Running the server as a Windows Service gives you the best performance, but running it in a Docker container is still surprisingly fast, given that it runs a (very basic) version of Linux in a virtual machine.</p> <p>To have the server restarted automatically after a failure, run it</p> <ul> <li>on Windows as a Windows Service</li> <li>on Linux and Windows in a Docker container</li> </ul> <p>To run the Tatin server as a Windows Service, use the workspace <code>InstallAsWindowsService.dws</code>, which installs Tatin as a Windows service. (Requires admin rights.)</p>"},{"location":"install-server/#configure-docker","title":"Configure Docker","text":"<p>To run Tatin in a Docker container, first adjust the Docker configuration to your environment and needs.</p>"},{"location":"install-server/#dockerfile","title":"<code>Dockerfile</code>","text":"<p>This file defines what Docker should put into the container.</p> <p>In particular, it must point to the desired version of Dyalog APL, so check the variables <code>DYALOG_RELEASE</code>, <code>DYALOG_VERSION</code> and <code>DYALOG_DEBFILE</code>. Copy the appropriate version of Dyalog APL into the folder that holds the Docker-related files.</p> FROM Name of the desired Linux distribution and the version number. MAINTAINER Your Docker username and email address. WORKDIR Do not change this! DYALOG_SERIAL Do not change this! The licence number is explicitly reserved for Tatin servers."},{"location":"install-server/#entrypoint","title":"<code>entrypoint</code>","text":"<p>Environment variables <code>TRACE_ON_ERROR</code>, <code>SINGLETRACE</code> and <code>CLASSICMODE</code> might need adjusting to your taste.</p>"},{"location":"install-server/#createtatindockercontainersh","title":"<code>CreateTatinDockerContainer.sh</code>","text":"<p>Change the <code>source</code> to the folder that hosts the Tatin server data.</p> <p>Ports 80 and 443 respectively are the standard ports for HTTP and HTTPS.</p> <p>The server listens to port 9090, which the default configuration exposes. It is unsafe to remap this to ports 80 or 443 except on an isolated machine: run a public Tatin server on the Web behind a webserver such as Apache or Nginx.</p> <p>The second port exposed in the script is for connecting to the interpreter with Ride, if permitted by the INI file.</p>"},{"location":"install-server/#docker-workflow","title":"Docker workflow","text":"<p>Call:</p> <ol> <li><code>./BuildImage.sh</code> to create the image</li> <li><code>./CreateTatinDockerContainer.sh</code> to create the container from the image</li> <li><code>start-tatin.sh</code> to start the container; the script ensures the container is restarted after a crash or auto-started after a reboot</li> </ol>"},{"location":"install-server/#testing-and-debugging","title":"Testing and debugging","text":"<p>For testing and debugging you might want to change in <code>server.ini</code> the settings in the <code>LOGFILE</code> section, and these flags in <code>CONFIG</code>:</p> DisplayRequests Make Rumba display every request. LogHTTPToSession Print HTTP requests to the session. TestFlag Accept extra commands as REST requests. ReloadWS Reload the server workspace if you detect a new one. <ol> <li> <p>See  aplteam/IniFiles.\u00a0\u21a9</p> </li> </ol>"},{"location":"load-and-update-strategy/","title":"Tatin\u2019s load and update strategy","text":"<p>How Tatin deals with conflicting requirements for package versions</p> <p>As you incorporate packages and their dependencies into your application, you see different packages sometimes specify as dependencies different versions of the same package. As a package manager, Tatin has policies for resolving these conflicts.</p> <p>You can get started without grasping these policies, but they have important consequences you will eventually need to understand.</p>"},{"location":"load-and-update-strategy/#minimum-version-selection","title":"Minimum version selection","text":"<p>Suppose you need packages, <code>Foo</code> and <code>Goo</code>. Both rely on package <code>Zoo</code>; but while <code>Foo</code> requests <code>Zoo</code> 1.1.1, <code>Goo</code> requires version 1.2.0.</p> <pre><code>         Zoo-1.0.0\n         Zoo-1.1.0\nFoo ---&gt; Zoo-1.1.1\nGoo ---&gt; Zoo-1.2.0\n         Zoo-1.3.0\n         Zoo-2.0.0\n</code></pre> <p>The best available version 1 of <code>Zoo</code> is 1.3.0. There is also a later major version: 2.0.0.</p> <p>Version 2.0.0 is not an option, because it is considered a completely different package and so ignored.</p> <p>From semantic versioning we know <code>Goo</code> relies on features of <code>Zoo</code> new in version 1.2.0, and would break on version 1.1.1, which doesn\u2019t have them.</p>"},{"location":"load-and-update-strategy/#strategy-options","title":"Strategy options","text":"<p>Several strategies are possible:</p> <ol> <li>Load both versions of <code>Zoo</code>: let <code>Foo</code> use 1.1.1 and <code>Goo</code> 1.2.0.</li> <li>Load <code>Zoo</code> version 1.2.0 and let <code>Zoo</code> and <code>Goo</code> both use it.</li> <li>Check the server, load the latest version available (1.3.0) and use that.</li> </ol> <p>Each of these options is used by different package managers in the wild. There is no consensus on what is best.</p> <p>Strategy (3) appeals to many programmers: you are always up-to-date, and you always get the latest fixes when you build your application. Great!</p> <p>But on reflection it looks much less appealing:</p> <ol> <li>Build your application, including updated dependencies</li> <li>Run your test cases; they all pass </li> <li>Rebuild your application without changing anything</li> <li>Rerun your test cases; but this time they fail </li> </ol> <p>This situation arises if, between the first and second build, the author of a dependency releases a new version with bugs in it. The second build fetches it, producing a different outcome \u2013 even though you haven\u2019t made any changes.</p>"},{"location":"load-and-update-strategy/#tatins-strategy","title":"Tatin\u2019s strategy","text":"<p>As appealing as an automated update mechanism might seem, you\u2019d want your builds to be 100% reproducible, right?</p> <p>So, when asked to load installed packages, Tatin will do exactly that:</p> <ul> <li>load the packages defined as required by the configuration files of the main packages <code>Foo</code> and <code>Goo</code></li> <li>except when a package is requested more than once, and with different minor and/or patch numbers, Tatin uses the latest installed version (which might or might not be the latest one available)</li> </ul> <p>Updating dependencies</p> <p>Tatin does not update dependencies for you, but helps you discover whether later packages are available.</p> <p> <code>]CheckForLaterVersions</code> <code>]ReInstallDependencies</code> <code>ReInstallDependencies</code></p> <p>In our example</p> <ul> <li><code>Zoo</code> is requested and installed twice</li> <li>Tatin loads 1.2.0 just once (because it is requested by <code>Goo</code>)</li> <li>1.3.0 is ignored because it is not requested and so not installed</li> </ul> <p>This means <code>Foo</code> will also use version 1.2.0 of <code>Zoo</code>.</p> <p>This strategy is called Minimal Version Selection (MVS). It guarantees that when you rebuild you get the same result, but it will grab the latest installed version.</p>"},{"location":"load-and-update-strategy/#forcing-updates","title":"Forcing updates","text":"<p>Suppose a package of yours depends on someone else\u2019s package <code>Foo</code>, which in turn depends on <code>Goo</code> 1.1.0 \u2013 and while using <code>Foo</code> you discover <code>Goo</code> 1.1.0 has a bug.</p> <p>You write to the author of <code>Foo</code>, saying <code>Goo</code> 1.1.1 is available and fixes that very bug, but you get no reply, and you have only two weeks to your deadline.</p> <p>Solution Create a package <code>Dummy</code> that does nothing, but declares a dependency on <code>Goo</code> 1.1.1. Voila! Thanks to MVS, everything works.</p>"},{"location":"load-and-update-strategy/#comparing-versions","title":"Comparing versions","text":"<p>As long as the patch is a digit, precedence is easy to determine.</p> <p>Precedence is obvious for</p> <pre><code>group-name-1.0.0\ngroup-name-1.1.0\n</code></pre> <p>less so for</p> <pre><code>group-name-1.0.0-alpha\ngroup-name-1.1.0-beta\n</code></pre> <p>and cannot be determined with</p> <pre><code>group-name-1.0.0-TryFeature1\ngroup-name-1.1.0-FixFor234\n</code></pre> <p>Packages, once published, cannot be altered. So if the patch contains a text description, Tatin uses publication date to determine the correct order.</p>"},{"location":"load-and-update-strategy/#loading-dependencies","title":"Loading dependencies","text":"<p>Imagine these packages all hosted by a Tatin server with alias <code>MyTatin</code>.</p> <pre><code>mygroup-Foo-1.0.0 ---&gt; Zoo-1.1.1\nmygroup-Goo-2.1.0 ---&gt; Zoo-1.2.0\n                       Zoo-1.3.0\n</code></pre> <p>While <code>Foo</code> relies on <code>Zoo</code> 1.1.1, <code>Goo</code> needs <code>Zoo</code> 1.2.0. What does Tatin do about this?</p> <p>It depends on what you do. Let\u2019s first load <code>Zoo</code> and <code>Goo</code> into the workspace, the usual way to inspect a package:</p> <pre><code>      ]TATIN.LoadPackages [MyTatin]/mygroup-Foo-1.0.0 #.MyPkgs\n#.MyPkgs.Foo\n      ]TATIN.LoadPackages [MyTatin]/mygroup-Goo-2.1.0 #.MyPkgs\n#.MyPkgs.Goo\n      #.MyPkgs.\u2395NL \u237316\nFoo\nGoo\n</code></pre>"},{"location":"load-and-update-strategy/#getting-the-latest-version","title":"Getting the latest version","text":"<p>Suppose version 1.3.0 of <code>Foo</code> is the latest available with major number\u00a01, then this would have been sufficient:</p> <pre><code>]TATIN.LoadPackages [MyTatin]/mygroup-Foo-1 #.MyPkgs\n</code></pre> <p>Note neither the minor nor the patch number has been specified.</p> <p>Suppose version 2.1.0 of <code>Goo</code> is the very latest version available, and that\u2019s the version you want to use, then this would have been sufficient:</p> <pre><code>]TATIN.LoadPackages [MyTatin]/mygroup-Goo #.MyPkgs\n</code></pre> <p>In this case not even the major number has been specified.</p> <p>You wanted <code>Foo</code> and <code>Goo</code> loaded into <code>#.MyPkgs</code>, and that's exactly what Tatin did. But where are the dependencies?</p> <p>Where Tatin really keeps packages</p> <p><code>#.MyPkgs</code> just contains references to where the packages have been loaded into, the namespace <code>#._tatin</code>.</p> <p>Looking under the covers:</p> <pre><code>      #._tatin.\u2395NL 9\nmygroup_Foo_1_0_0\nmygroup_Goo_2_1_3\nmygroup_Zoo_1_1_1\nmygroup_Zoo_1_2_0\n</code></pre> <p>Both versions of <code>Zoo</code> have been loaded. That\u2019s because the two <code>Load</code> operations are independent, so minimal version selection cannot be applied.</p> <p> <code>]CheckForLaterVersion</code> <code>CheckForLaterVersion</code></p>"},{"location":"load-and-update-strategy/#installing-packages","title":"Installing packages","text":"<p>To incorporate packages into an application, they must be installed. In the following example, we install two packages, <code>Foo</code> and <code>Goo</code>. Both require <code>Zoo</code>, so <code>Zoo</code> gets installed as a side effect.</p> <pre><code>      \u2395NEXISTS '/myPkgs'\n0\n      ]TATIN.InstallPackages [MyTatin]/mygroup-Foo-1.0.0 /myPkgs/\n/myPkgs/mygroup-Foo-1.0.0\n      ]TATIN.InstallPackages [MyTatin]/mygroup-Goo-2.1.0 /myPkgs/\n/myPkgs/mygroup-Goo-2.1.0\n      \u236a\u2283\u2395NINFO \u2360 1\u22a2'/myPkgs/*'\n/myPkgs/apl-buildlist.json\n/myPkgs/apl-dependencies.txt\n/myPkgs/mygroup-Foo-1.0.0\n/myPkgs/mygroup-Goo-2.1.0\n/myPkgs/mygroup-Zoo-1.1.1\n/myPkgs/mygroup-Zoo-1.2.0\n</code></pre> <p>Compare the dependency file and the build list:</p> <pre><code>      \u2283\u2395NGET '/myPkgs/apl-dependencies.txt'    \u235d dependency file\nmygroup-Foo-1.0.0\nmygroup-Goo-2.1.0\n\n      json\u2190\u2283\u2395NGET'/myPkgs/apl-buildlist.json'  \u235d build list\n      #.q\u2190\u2395JSON \u2360 ('Dialect' 'JSON5') \u22a2 json\n      \u2349\u2191#.q.(principal packageID)\n1  mygroup-Foo-1.0.0\n0  mygroup-Zoo-1.1.1\n1  mygroup-Goo-2.1.0\n0  mygroup-Zoo-1.2.0\n</code></pre> <p>Above, the first column flags the principal packages.</p> <ul> <li>The dependency file lists the principal packages installed.</li> <li>The build list comprises not only the two principal packages but also the dependencies.</li> </ul>"},{"location":"load-and-update-strategy/#loading-installed-packages","title":"Loading installed packages","text":"<p>Loading packages puts them in your workspace; installing packages puts them in your file system.</p> <p>Loading installed packages lets Tatin use MVS to optimise what it loads.</p> <p></p> <p>Load installed packages with command <code>]LoadDependencies</code>. Its argument is a folder with files <code>apl-dependencies.txt</code> and <code>apl-buildlist.json</code>, created when you installed your first package there.</p> <p>You can also specify a second argument: where to create the references pointing to the principal packages.<sup>1</sup></p> <pre><code>]TATIN.LoadDependencies /myPkgs/ #.Temp\n</code></pre> <p>If the command finds the dependency file is newer than the build list, it checks for inconsistencies: if none, it reconstructs the build list from scratch.</p> <p>Then it prunes the build list and loads the remaining packages.</p> <p>In our example the pruning eliminates <code>Zoo</code> 1.1.1: rather than loading <code>Zoo</code> twice, Tatin loads only the latest installed version. Both <code>Foo</code> and <code>Goo</code> will use <code>Zoo</code> version 1.2.0.</p>"},{"location":"load-and-update-strategy/#remove-a-principal-package","title":"Remove a principal package","text":"<p>Suppose you no longer need <code>Goo</code>.</p> <p>To remove it, use either command <code>]UnInstallPackage</code> or API function <code>UnInstallPackage</code>. This will remove not only the principal package, but any of its dependencies that are neither principal packages nor dependencies of other packages.</p> Do not manually remove packages from your application\u2019s packages folder. <p>Tatin manages these dependency relations; don\u2019t interfere.</p>"},{"location":"load-and-update-strategy/#implicit-downgrading","title":"Implicit downgrading","text":"<p>Removing a principal package might imply a downgrade.</p> <p>Consider, say, these packages (dependencies indented):</p> <pre><code>group-foo-1.0.0\n  group-zoo-1.1.0\ngroup-boo-1.0.0\n  group-zoo-1.0.0\n</code></pre> <p>Minimal version selection (MVS) means both <code>foo</code> and <code>boo</code> use <code>zoo</code> 1.1 when loaded. What happens if you remove <code>boo</code>?</p> <p>Either could be argued:</p> <ol> <li><code>zoo-1.1.0</code> should survive this and still be used</li> <li>a package not required anywhere shouldn\u2019t be used</li> </ol> <p>A full implementation of MVS requires (1). For now, Tatin uses (2) as a more pragmatic approach.</p> <p>It is not obvious what is best here. Tatin\u2019s strategy might change after feedback.</p>"},{"location":"load-and-update-strategy/#add-a-package-manually","title":"Add a package manually","text":"<p>To add a package that has no dependencies you could just add it to the file <code>apl-dependencies.txt</code> and copy the package over.</p> <p>That would not cause a problem. When the <code>LoadDependencies</code> command is next issued, Tatin sees the file <code>apl-dependencies.txt</code> changed after <code>apl-buildlist.json</code> was last modified, performs some health checks, and if all is well, recreates the build list. (This is insurance against people manually introducing errors into <code>apl-dependencies.txt</code>)</p>"},{"location":"load-and-update-strategy/#downgrade","title":"Downgrade","text":"<p>Sometimes you might need to downgrade, for example from a version you find buggy, to an older version known to be okay.</p> <p>Tatin does not offer help here; you need to do this yourself.</p> <ol> <li> <p>(Defaults to <code>#</code> if that is your current namespace. If you are, say, in <code>#.foo</code> then Tatin asks whether to install into <code>#</code> or <code>#.foo</code>.)\u00a0\u21a9</p> </li> </ol>"},{"location":"maintenance/","title":"Maintain your server","text":"<p>Care and grooming of your Tatin server.</p>"},{"location":"maintenance/#curate-the-tags","title":"Curate the tags","text":"<p>The most important maintenance job is to curate the tags.</p> <p>Tags can be very useful for finding a package, but package authors may use different tags for the same thing, use legal but different spelling (UK versus US) or invalid spelling, or tags that make no sense, such as the group name or <code>dyalog</code> etc.</p> <p>To be useful, tags needs curating.</p> <p>A package\u2019s tags are defined in its configuration file. Merely changing the config file is enough: the server watches for such changes and adds the new config to the package ZIP, thus updating it.</p> <p>Create and run maintenance jobs to correct problems in the package config files.</p>"},{"location":"maintenance/#maintenance-jobs","title":"Maintenance jobs","text":"<p>The Maintenance Folder holds maintenance jobs in the form of APL function files (APLFs). The downloaded server includes some examples.</p> <p>If a job crashes, the server</p> <ol> <li>reports it to the log file</li> <li>emails a report to the maintainer (see config)</li> <li>renames the file from <code>*.aplf</code> to <code>*.crashed</code> to stop it being run again</li> </ol> <p>If the server finds APLFs in the Maintenance Folder during housekeeping, it loads and executes them.</p> <p>Once executed, a file is renamed by adding an extension <code>.executed</code>, so it is not run again. That also documents what jobs were executed, and when.</p> <p>For example, a file <code>RemoveDyalogFromTags.aplf</code> gets loaded into an unnamed namespace and called with a right argument <code>G</code> (for globals).  Once executed, the file is renamed to <code>RemoveDyalogFromTags.aplf.executed</code>.</p> <p> User command: <code>]Maintenance</code></p>"},{"location":"maintenance/#update-the-server","title":"Update the server","text":"<p>Download the release ZIP from the Releases page into a temporary folder and unzip it.</p> <p>Read the release note before doing anything else.</p> <p>An update could require taking the server down for maintenance.</p> <p>By default, a running Tatin server watches the workspace on disk and reloads it if it changes. This makes for an easy update if no other action is required.</p> <p>The automatic update can be switched off in the INI file with <code>[CONFIG]ReloadWS</code>.</p> <p>While reloading the workspace, the server returns error messages. Expect this to last 10 seconds or more, depending on the number of packages managed.</p>"},{"location":"maintenance/#the-ini-file","title":"The INI file","text":"<p>The update might add or remove settings in the INI file: consult the release note.</p> <p>If there are changes, follow instructions in the note.</p> <p>Do not replace the INI file.</p> <p>The server monitors the INI file for changes, and re-initialises if it finds them. Whether that works depends on the change: some settings are used at an early stage and cannot be changed later. Again, the release note will tell.</p>"},{"location":"maintenance/#assets","title":"Assets","text":"<p>The release note describes what action to take, if any. Often the subfolder <code>docs/</code> is to be replaced. (Contains the documentation.)</p>"},{"location":"maintenance/#maintenance-folder","title":"Maintenance folder","text":"<p>Never replace the Maintenance Folder</p> <p>The folder <code>maintenance/</code> documents changes made to the packages: you don\u2019t want to lose this.</p> <p>If the new folder is not empty, copy its content over. Maintenance files can be used to carry out changes on all or some of the packages managed by the server, like adding a new property to the package config files of all packages.</p>"},{"location":"older-versions/","title":"Install and update older versions","text":"<p>How to install Tatin in Dyalog 18.2 and how to update older versions</p>"},{"location":"older-versions/#install-in-dyalog-182","title":"Install in Dyalog 18.2","text":"<p>Tatin is included in Dyalog 19.0; in Dyalog 18.2 it has to be installed.</p>"},{"location":"older-versions/#requirements","title":"Requirements","text":"<ul> <li>Dyalog 18.2 Unicode</li> <li>Link version 3.0.8 or better</li> </ul> <p><code>]TATIN.Init</code> checks the requirements are met.</p>"},{"location":"older-versions/#download","title":"Download","text":"<p>Download the latest release of the Tatin client.</p> <p> https://github.com/aplteam/Tatin/releases</p> <p>Unzip the file and move folder <code>Tatin/</code> to the installation folder.</p>"},{"location":"older-versions/#installation-folder","title":"Installation folder","text":"<p>The installation folder is at <code>&lt;path&gt;/SessionExtensions/CiderTatin</code> where <code>path</code> is:</p> Version-specificVersion-agnostic <p>These file paths are specific to Version 18.2: <pre><code>/home/&lt;\u2395AN&gt;/dyalog.182U&lt;bit&gt;.files                          \u235d Linux\n/Users/&lt;\u2395AN&gt;/dyalog.182U64.files                            \u235d macOS\nC:\\Users\\&lt;\u2395AN&gt;\\Documents\\Dyalog APL[-64] 18.2 Unicode Files \u235d Windows\n</code></pre></p> <p>These file paths make Tatin available to all Dyalog versions: <pre><code>/home/&lt;\u2395AN&gt;/dyalog.files                  \u235d Linux\n/Users/&lt;\u2395AN&gt;/dyalog.files                 \u235d macOS\nC:\\Users\\&lt;\u2395AN&gt;\\Documents\\Dyalog APL Files \u235d Windows\n</code></pre></p>"},{"location":"older-versions/#connect-user-commands","title":"Connect user commands","text":"<p>Include the installation folder in SALT\u2019s search path.</p> <pre><code>]SALT.Settings cmddir \",&lt;installation-folder&gt;\" -p\n</code></pre> <p>The comma tells SALT to extend its path, not replace it. The <code>-p</code> flag makes the change permanent.</p> <p>Test for inline help: in a new Dyalog session enter</p> <pre><code>]tatin -?\n</code></pre>"},{"location":"older-versions/#expose-the-api","title":"Expose the API","text":"<p>Executing any Tatin command exposes the API.</p> <p>Dyalog 19.0+ exposes the Tatin API before any user command is executed.</p> <p>An automated build process might need to expose the API  without first executing a command. You can do this with a <code>setup.dyalog</code> script in your <code>MyUCMDs/</code> folder.</p> <p>Default locations for the  <code>MyUCMDs/</code> folder:</p> <pre><code>/home/{username}/               \u235d Linux\n/Users/{username}/              \u235d macOS\nC:\\Users\\{username}\\Documents\\  \u235d Windows\n</code></pre> <p>The Windows installer creates this folder; on other platforms, create it yourself.</p> <p>Setup scripts</p> <p>At launch, Dyalog looks  for a monadic <code>Setup</code> function in a <code>setup.dyalog</code> script.</p> <p>In version 19.0 the <code>Run.aplf</code> function offers a better way to achieve that: <code>setup.dyalog</code> superfluous.</p> <p> <code>setup.dyalog</code> model setup script</p> <p>If you already have a setup script:</p> <ul> <li>Copy from the model script functions <code>IfAtLeastVersion</code>, <code>GetProgramFilesFolder</code> and <code>AutoLoadTatin</code></li> <li>Ensure your <code>Setup</code> function calls <code>AutoLoadTatin</code> and, if it returns an empty vector (success), reset the command cache:<pre><code>{}\u2395SE.SALTUtils.ResetUCMDcache -1\n</code></pre> </li> </ul>"},{"location":"older-versions/#update-an-old-version-of-tatin","title":"Update an old version of Tatin","text":""},{"location":"older-versions/#versions-before-01050","title":"Versions before 0.105.0","text":"<p>Tatin Version 0.105.0 introduced the <code>Update</code> user command.</p> <p>To update an earlier version:</p> <ol> <li>Remove <code>Tatin/</code> from the <code>MyUCMDs/</code> folder. (See Expose the API.)</li> <li>Download and install Tatin from scratch. (Also Cider, if you are using it.)</li> <li>Review your <code>setup.dyalog</code> script if you are using one.</li> </ol>"},{"location":"older-versions/#onedrive-and-versions-before-01140","title":"OneDrive and versions before 0.114.0","text":"<p>OneDrive is cloud storage provided by Microsoft for backing up your personal folders. A Windows user <code>JohnDoe</code> who enables OneDrive changes his Documents folder:</p> <pre><code>C:\\Users\\JohnDoe\\Documents\\             \u235d from\nC:\\Users\\JohnDoe\\OneDrive\\Documents\\    \u235d to\n</code></pre> <p>The Dyalog installation folder is (by default) in the Documents folder, e.g.</p> <pre><code>Dyalog APL Files                  \u235d version-agnostic\nDyalog APL-64 19.0 Unicode Files  \u235d version-specific\n</code></pre> <p>Before version 0.114.0, Tatin read environment variable <code>USERPROFILE</code> to find the Documents folder. But <code>USERPROFILE</code> does not reflect use of OneDrive! An update of Tatin would apparently succeed but, written to the wrong Documents folder, would not appear in subsequent launches of Dyalog.</p> <p>Since version 0.114.0, Tatin uses the experimental I-beam <code>4070\u23360</code> to recognise a Documents folder in OneDrive.</p> <p>If you are using OneDrive and a version of Tatin older than 0.114.0:</p> <ol> <li> <p>Determine your Tatin home: the relative path from your OneDrive Documents folder in which your Tatin files are kept, i.e.</p> <pre><code>&lt;dyalog-install-folder&gt;/SessionExtensions/CiderTatin\n</code></pre> </li> <li> <p>Add<sup>1</sup> to SALT\u2019s <code>cmddir</code> the path</p> <pre><code>C:/Users/&lt;\u2395AN&gt;/OneDrive/Documents/&lt;tatin-home&gt;\n</code></pre> </li> <li> <p>Remove from SALT\u2019s <code>cmddir</code>  the path</p> <pre><code>C:/Users/&lt;\u2395AN&gt;/Documents/&lt;tatin-home&gt;\n</code></pre> </li> <li> <p>Remove from your file system folder</p> <pre><code>C:/Users/JohnDoe/Documents/&lt;tatin-home&gt;\n</code></pre> </li> </ol> <p>Updates will then work as expected.</p> Reverting to a version older than 0.114.0 <p>If you revert to a Tatin version older than 0.114.0, for example with</p> <pre><code>]activate -reset\n</code></pre> <p>you also recreate the problem.</p> <ol> <li> <p>See <code>]SALT.Settings -??</code> for help.\u00a0\u21a9</p> </li> </ol>"},{"location":"package-configuration/","title":"Package configuration","text":"<p>Your package\u2019s configuration contains essential information about it.</p> <p>Your package configuration is in file <code>apl-package.json</code> in the package root.</p> <p>Example</p> <pre><code>{\n  api: \"DotNetZip\",\n  assets: \"\",\n  description: \"Zipping and unzipping with .NET Core on all major platforms\",\n  documentation: \"\",\n  exclude: \"\",\n  files: \"\",\n  group: \"aplteam\",\n  io: 1,\n  license: \"MIT\",\n  lx: \"\",\n  maintainer: \"kai@aplteam.com\",\n  minimumAplVersion: \"18.2\",\n  ml: 1,\n  name: \"DotNetZip\",\n  os_lin: 1,\n  os_mac: 1,\n  os_win: 1,\n  project_url: \"https://github.com/aplteam/DotNetZip\",\n  source: \"DotNetZip.aplc\",\n  tags: \"zip-tools\",\n  tatin_version: \"0.103.0\",\n  userCommandScript: \"\",\n  version: \"0.5.4\",\n}\n</code></pre> <p>Key <code>wx</code> was removed in Tatin version 0.61.0.</p> <p> <code>]CreatePackage</code> <code>]PackageConfig</code> <code>InitialisePackage</code> <code>InitPackageConfig</code> <code>ReadPackageConfigFile</code></p>"},{"location":"package-configuration/#standard-settings","title":"Standard settings","text":"<p>All the standard settings are optional except those marked required.</p> <p>A configuration setting or parameter is \u2018set\u2019 when a file key or parameter variable is defined with a non-empty string.</p> <code>api</code> String. The name of a namespace that is to contain the public interface to the package. (<code>'API'</code> is a good choice.) <code>assets</code> <p>String. Path to a folder containing the package\u2019s assets, relative to the package root.</p> <p>Treat the assets folder as read-only: do not write to it from a package.</p> Tatin signals an error\u2026 <p>If</p> <ul> <li>the path contains a <code>:</code> or begins with <code>/</code>, unless the path begins with absolute path to the package root, when Tatin silently converts it to a relative path</li> <li>the path does not point to an existing folder</li> </ul> <p>See also <code>files</code> and <code>GetFullPath2AssetsFolder</code>.</p> Access package assets from a class instance <p>If you need to access assets from an instance of a class in a package you can either:</p> <ol> <li> <p>Add to the class a function like this:</p> <pre><code>\u2207 r\u2190GetAssetFolder\n  r\u2190##.TatinVars.GetFullPath2AssetsFolder\n\u2207\n</code></pre> </li> <li> <p>Use the expression <code>\u2283\u2283\u2395CLASS \u2395THIS</code> to locate the class script, i.e.</p> <pre><code>(\u2283\u2283\u2395CLASS \u2395THIS).##.TatinVars.GetFullPath2AssetsFolder\n</code></pre> </li> </ol> Access platform-dependent assets <p>There is no general solution for the problem of platform-dependent assets. One way to solve this is to use <code>lx</code>.</p> <code>deprecated</code> Flag. Whether the package is deprecated; default 0. <code>deprecate_comment</code> String. Why the package was deprecated. <code>description</code> String. Required. What the package does, or what problems it solves. <code>documentation</code> <p>String. Either:</p> <ul> <li>URL of an online help resource, beginning <code>http://</code> or <code>https://</code></li> <li>local relative path to a file (or program) within the package, beginning <code>./</code></li> <li>pointer to a function or a variable in the package, beginning <code>\u2395THIS.</code>, e.g. <code>\u2395THIS.Admin.ShowHelp</code></li> </ul> <code>exclude</code> <p>Comma-delimited string. Paths from <code>source</code> to file/s or directories to exclude from the package.</p> Use cases <p>To publish your package both as a Tatin package and also on GitHub, consider how to specify <code>\u2395IO</code> and <code>\u2395ML</code>.</p> <p>Tatin packages allow these values to be set in the package config.</p> <p>For GitHub you can set them in the <code>APLSource/</code> folder as files <code>\u2395IO.apla</code> and <code>\u2395ML.apla</code>; Link will load and set them.</p> <p>The non-ANSI characters in the filenames make zipping and unzipping across platforms unreliable. Since the two files are not required by the Tatin package, they can be excluded from the build, which lets you avoid this.</p> <pre><code>exclude: \"\u2395IO.apla, \u2395ML.apla\",\n</code></pre> <code>files</code> <p>Comma-delimited string. Files and/or folders to be moved into the package root, e.g. <code>ReadMe.txt</code>. (See also <code>assets</code>.)</p> <p>By convention, a file <code>LICENSE</code> in the project root is copied to the package root when the package is built.</p> <code>group</code> String. The group part of the full package ID. You can specify a default in your user settings. <code>io</code> Integer. Value to be assigned to <code>\u2395IO</code>. <code>license</code> String. Each Tatin registry publishes a list of licences it accepts for packages it hosts. <code>lx</code> <p>String. Name of a niladic or monadic function in the top-level namespace of the package (not in what might be defined as API!) or a shared method of a class.</p> <p>This will be executed by either <code>LoadPackages</code> or <code>LoadDependencies</code> after all dependencies have been loaded and all refs established, i.e. at a very late stage. You could use it</p> <ul> <li>to initialise a package on bringing it into the workspace</li> <li>to deal with platform-dependent assets</li> </ul> <p>If the function is monadic its argument is the file path to the package. (If the package is brought into the workspace by <code>LoadPackages</code> and has no assets,  the argument will be empty.)</p> <p>The function must return a result, which is assigned to <code>TatinVars.LX</code> inside the package space. (Without an <code>lx</code> object there will be no <code>TatinVars.LX</code>.)</p> Trapping errors <p>The <code>lx</code> function is executed under error trapping, and any error silently ignored. You have two alternatives to this:</p> <ol> <li> <p>Localise <code>\u2395TRAP</code> to the <code>lx</code> function and set <code>\u2395TRAP\u21900 'S'</code> to make any problem pop up straight away</p> </li> <li> <p>Put <code>:TRAP \u22c4 :EndTrap</code> around the code in the <code>lx</code> function and deal with problems yourself, for example in the <code>:Else</code> branch.</p> </li> </ol> <p>The existence of <code>TatinVars.LX</code> indicates an <code>lx</code> function was executed successfully, even if it is empty.</p> <code>maintainer</code> <p>String. Email address for the package maintainer. Valid formats:</p> <pre><code>your name &lt;your.name@your-domain.com&gt;\nyour.name &lt;your.name@your-domain.com&gt;\nyour.name@your-domain.com\n</code></pre> <p>Any double quotes are removed.</p> <p>You can define a default value in the user settings. Otherwise, if <code>maintainer</code> is empty at publication time, the registry assigns the email address from the group\u2019s home page if there is one.</p> <code>minimumAplVersion</code> <p>String. Minimum APL version for the package.</p> <p>Tatin itself needs at least version 18.2, so this setting cannot be less.</p> <code>ml</code> Integer. Value to be assigned to <code>\u2395ML</code>. <code>name</code> String. The name part of the full package ID. <code>os_lin</code> Flag. Whether the package runs under Linux. <code>os_mac</code> Flag. Whether the package runs under macOS. <code>os_win</code> Flag. Whether the package runs under Windows. <code>project_url</code> String. URL to where the project is hosted, e.g.<pre><code>https://github.com/aplteam/MarkAPL\n</code></pre> <code>source</code> Code file extensions: <pre><code>.aplc     \u235d class\n.aplf     \u235d function\n.apln     \u235d namespace\n.aplo     \u235d operator\n.dyalog   \u235d SALT script\n</code></pre> <p>String. Required. Path, relative to the package root, to a code file, or to a folder of code files.</p> <p>(Tatin ignores non-code files.)</p> <p>You can specify a default <code>source</code> in your user settings.</p> Tatin does not guarantee compatibility with SALT <p>The <code>.dyalog</code> extension is still used by the user-command framework, so Tatin supports it: a user command might well be delivered as a Tatin package.</p> <p>Using the <code>.dyalog</code> extension outside this context is discouraged.</p> Cider and Tatin source properties <p>If you use Cider to manage your project, you see both Cider and Tatin configs have a <code>source</code> property. The Cider <code>source</code> refers to the Cider project, while the Tatin <code>source</code> refers to the package to be published.</p> <p>Suppose project Foo consists of a single class <code>Foo</code>: <pre><code>Foo/\n\u251c\u2500\u2500 APLSource/\n\u2502   \u251c\u2500\u2500 Admin/\n\u2502   \u251c\u2500\u2500 Foo.aplc\n\u2502   \u2514\u2500\u2500 TestCases/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 apl-package.json\n\u2514\u2500\u2500 cider.config\n</code></pre> In <code>cider.config</code> the <code>source</code> is <code>APLSource</code>, because that\u2019s where the code lives.</p> <p>In <code>apl-package.json</code> however, <code>source</code> is <code>APLSource/Foo.aplc</code>, because that is what goes in the package.</p> <p>A slightly more complex example, with a namespace that hosts several functions: <pre><code>Goo/\n\u251c\u2500\u2500 APLSource/\n\u2502   \u251c\u2500\u2500 Admin/\n\u2502   \u251c\u2500\u2500 Foo.aplc\n\u2502   \u251c\u2500\u2500 Goo/\n\u2502   \u2514\u2500\u2500 TestCases/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 apl-package.json\n\u2514\u2500\u2500 cider.config\n</code></pre> In this case, the package <code>source</code> package could be <code>APLSource/Goo</code>, because<code>Admin</code> and <code>TestCases</code> do not go in the package.</p> <code>tags</code> <p>Comma-delimited string. Required. A list of tags (keywords) to help searchers.</p> Tags should relate only to the problems one can solve with the package. <p>Operating systems have their own properties (<code>os_lin</code>, <code>os_mac</code>, <code>os_win</code>) introduced with Tatin version 0.81.0.</p> <p>There is no point in adding tags like <code>dyalog</code> or <code>apl</code>\u2026</p> <p>Admins of the Principal Registry might silently edit them to keep them consistent and meaningful.</p> <code>userCommandScript</code> String. Path, relative to the project root, of the user-command script. Identifies and required for user-command packages. (Introduced in Tatin version 0.86.0.) <code>version</code> String. Version in the full package ID."},{"location":"package-configuration/#read-only-settings","title":"Read-only settings","text":"<p>Set by Tatin:</p> <code>date</code> Float. Date of publication, in the format <code>yyyymmdd.hhmmss</code>. <code>tatin_version</code> String. Tatin version number (no build ID) by which the config data was created or changed. <code>url</code> String. Source from which package was loaded or installed: URL or file path."},{"location":"package-configuration/#system-variables","title":"System variables","text":"<p>APL system variables <code>\u2395IO</code> and <code>\u2395ML</code> are local in each package. They require special treatment, because</p> <ul> <li>a package\u2019s definitions might depend on them</li> <li>any subnamespaces inherit the values</li> </ul> <p>Before any code is loaded into a namespace created by <code>LoadPackages</code> or <code>LoadDependencies</code> Tatin sets these values as</p> <ol> <li>the <code>io</code> and <code>ml</code> settings in the package configuration; else</li> <li>the two Dyalog parameters (environment variables) <code>Default_IO</code> and <code>Default_ML</code>; else</li> <li>Dyalog\u2019s default value: 1.</li> </ol> Don\u2019t set these values in array files <p>Although including array files <code>\u2395IO.apla</code> or <code>\u2395ML.apla</code> would cause Link to set the system variables correctly, zipping their file names can break publication.</p> <p>See <code>exclude</code> for detail.</p>"},{"location":"package-configuration/#user-defined-variables","title":"User-defined variables","text":"<p>You can set your own variables in a package configuration file.</p> <p>To avoid name conflicts, your variable names must begin with an underscore. (Tatin signals an error if it encounters a name it does not know, unless the name begins with an underscore.)</p>"},{"location":"package-configuration/#package-metadata","title":"Package metadata","text":"<p>When Tatin loads a package, it writes its metadata into a namespace <code>TatinVars</code> within the package.</p> <p>For example, suppose Tatin has loaded packages Foo and Goo, and both depend on MarkAPL.</p> <p>In the workspace we find</p> <pre><code>#.Foo\n#.Foo.MarkAPL\n#.Foo.MarkAPL.APLTreeUtils2\n#.Foo.MarkAPL.CommTools\n#.Foo.MarkAPL.FilesAndDirs\n#.Goo\n#.Goo.MarkAPL\n...\n</code></pre> <p>These are refs to the package cache in <code>#._tatin</code>. <pre><code>      #.Foo.MarkAPL           \u235d ref to API of cached package\n#._tatin.aplteam_MarkAPL_13_1_0.API\n      #._tatin.\u2395NL 9          \u235d content of package cache\naplteam-APLTreeUtils2-1.4.0\naplteam-CommTools-1.8.1\naplteam-FilesAndDirs-5.8.0\naplteam_MarkAPL_13_1_0\nmy_Foo_1_0_0\nmy_Goo_1_1_0\n</code></pre> Metadata \u2018constants\u2019 in <code>TatinVars</code> are niladic functions. <pre><code>      )CS #._tatin.aplteam_MarkAPL_13_1_0\n#._tatin.aplteam_MarkAPL_13_1_0\n      \u2395NL 9                   \u235d content of cached package\nAPI\nAPLTreeUtils2\nCommTools\nFilesAndDirs\nLeanPubIcons\nMarkAPL\nTatinVars\n      TatinVars.\u2395NL 3         \u235d metadata 'constants'\nASSETS\nCONFIG\nDEPENDENCIES\nGetFullPath2AssetsFolder\nHOME\nID\nURI\n</code></pre></p> <p>So any package function can refer to its metadata \u2013 e.g. <code>HOME</code> as <code>##.TatinVars.HOME</code>.</p> <code>ASSETS</code> String. Path to the assets, relative to <code>HOME</code> \u2013 empty if there are none. <code>CONFIG</code> <p>String. Contents of <code>apl-package.json</code>.</p> Convert to parameter space <pre><code>      cfg\u2190(\u2395JSON \u2360 'Dialect' 'JSON5') TatinVars.CONFIG\n      cfg.\u2395NL 2\napi\nassets\ndate\ndescription\ndocumentation\nfiles\ngroup\nio\nlicense\nlx\nmaintainer\nminimumAplVersion\nml\nname\nos_lin\nos_mac\nos_win\nproject_url\nsource\ntags\nuri\nuserCommandScript\nversion\n      cfg.name\nMarkAPL\n</code></pre> <code>DEPENDENCIES</code> Strings. Full package IDs of this package\u2019s dependencies. <code>GetFullPath2AssetsFolder</code> <p>String. Absolute path to the assets, relative to <code>HOME</code> \u2013 empty if there are none.</p> <p>If <code>HOME</code> is empty or does not exist on disk the result is <code>ASSETS</code></p> <pre><code>      #.MarkAPL\n#._tatin.aplteam_MarkAPL_13_1_0.API\n      )CS #._tatin.aplteam_MarkAPL_13_1_0\n#._tatin.aplteam_MarkAPL_13_1_0\n      \u2191TatinVars.(HOME ASSETS GetFullPath2AssetsFolder)\n/Users/sjt/tmp/Foo/packages/aplteam-MarkAPL-13.1.0\nFiles/\n/Users/sjt/tmp/Foo/packages/aplteam-MarkAPL-13.1.0/Files/\n</code></pre> <code>HOME</code> <p>String. Path to the directory the package was installed into, even if the package has no assets.</p> <p>This differs when the package is imported with <code>LoadPackages</code>.</p> <code>ID</code> String. Full package ID. <code>URI</code> String. Source from which the package was loaded: URL or file path."},{"location":"public-interface/","title":"Public interface to a package","text":"<p>How to control which objects of a Tatin package are exposed to its users</p> <p>By default, the public interface of your package is all its top-level objects:</p> <pre><code>\u2395NL 2 3 4 9\n</code></pre> <p>The API space serves as a filter: referring to anything but the exposed names signals an error.</p> <p>You can instead select objects to expose by specifying an API space: a namespace with references only to the exposed objects. Then when the package is loaded into the workspace, the contents go into the package cache, and its handle points to its API namespace.</p> <p>For example, MarkAPL has an API space (called <code>API</code>) with references to its exposed functions. <pre><code>      #.MarkAPL\n#._tatin.aplteam_MarkAPL_13_1_0.API\n</code></pre> You can define an API space for your package, or Tatin can create one for you. The <code>api</code> setting in the package config tells Tatin how to use it.</p>"},{"location":"public-interface/#define-an-api-space","title":"Define an API space","text":"<p>Suppose package APkg consists of a single scripted namespace <code>Core</code> with multiple variables, functions, and operators of which only <code>Encode</code> and <code>Decode</code> should be exposed \u2013 as <code>#.APkg.Encode</code> and <code>#.APkg.Decode</code>.</p> <p>In the <code>Core</code> script you could create this structure <pre><code>#.APkg\n#.APkg.Core\n  ... \u235d vars, fns and oprs\n#.APkg.Core.API\n#.APkg.Core.API.Encode\n#.APkg.Core.API.Decode\n</code></pre> with these definitions <pre><code>API.Decode\u2190{\u237a ##.Decode \u2375}\nAPI.Encode\u2190{\u237a ##.Encode \u2375}\n</code></pre> then have the config <code>api</code> setting specify <code>Core.API</code>. The two functions would be exposed as <code>#.APkg.Decode</code> and <code>#.APkg.Encode</code> \u2013 and nothing else would.</p> <p>Suppose you had reason not to modify the <code>Core</code> script. Just include a second namespace in your package: <pre><code>:Namespace API\n    Decode\u2190{\u237a ##.Core.Decode \u2375}\n    Encode\u2190{\u237a ##.Core.Encode \u2375}\n:EndNamespace\n</code></pre> then have the config <code>api</code> setting specify <code>API</code>. The effect would be the same.</p> <p>An API can use multiple sources. Suppose you have a third namespace: <code>More</code>. <pre><code>:Namespace API\n    Decode\u2190{\u237a ##.Core.Decode \u2375}\n    Encode\u2190{\u237a ##.More.Encode \u2375}\n:EndNamespace\n</code></pre></p>"},{"location":"public-interface/#create-an-api-from-the-config","title":"Create an API from the config","text":"<p>For many packages, Tatin can create the API space for you, at build or load time. Specify the API space in the <code>api</code> setting of the package config and list what is to be exposed in it.</p> <p>Function <code>CreateAPIfromCFG</code> creates the API space as a child of the source namespace and populates it with references to the exposed ojects.</p> <p>You can substitute for this list (or override it) with an optional left argument.</p> <p>It looks in the package for a constant <code>Public</code> that names the objects to expose. This list of strings can name functions, operators, variables, interfaces, classes and namespaces, both simple and scripted. The objects must all be children (or, with dot syntax, grandchildren) of a single source namespace.</p> <p>You can create the API by calling <code>CreateAPIfrom CFG</code></p> <ul> <li>at load time from a function specified as the package\u2019s <code>lx</code> setting</li> <li>at build time, incorporating the API into the built package</li> </ul> If your source is a single scripted namespace, you cannot use <code>CreateAPIfromCFG</code> <p>The function cannot create a child space of a scripted namespace.</p> <p>Instead, define an API space directly: see above.</p>"},{"location":"public-interface/#some-scenarios","title":"Some scenarios","text":"<p>To expose from your package APkg (as e.g. <code>#.APkg.Hello</code>)</p> object/s from api CreateAPIfromConfig a single namespace <code>Foo</code> <code>Foo</code> a single scripted namespace <code>API</code> a single class <code>Foo</code><sup>1</sup> <code>Foo</code> multiple namespaces <code>API</code> <ol> <li> <p>In a class, use <code>:Field</code> and <code>:Access</code> declarations to expose objects.\u00a0\u21a9</p> </li> </ol>"},{"location":"publish-packages/","title":"Publish a package","text":"<p>Organise, configure, install dependencies, publish.</p>"},{"location":"publish-packages/#get-started","title":"Get started","text":"<p>A Tatin package separates APL source files from files such as CSS, EXE, DLL and so on. Tatin calls the APL files source and the others assets.</p> <ol> <li> <p>Arrange your files accordingly, e.g.</p> <pre><code>myproj/\n\u251c\u2500\u2500 assets/\n\u2502   \u251c\u2500\u2500 config.ini\n\u2502   \u251c\u2500\u2500 foo.json\n\u2502   \u251c\u2500\u2500 style.css\n\u2502   \u2514\u2500\u2500 tests.csv\n\u2514\u2500\u2500 source/\n    \u251c\u2500\u2500 RunTests.aplf\n    \u251c\u2500\u2500 asc.aplf\n    \u251c\u2500\u2500 dot.aplo\n    \u251c\u2500\u2500 mean.aplf\n    \u2514\u2500\u2500 valid8_.aplf\n</code></pre> </li> <li> <p>Create a default configuration for your package:</p> <pre><code>]TATIN.PackageConfig path/to/myproj -edit\n</code></pre> <p>The command prompts you for the essential configuration parameters and writes <code>myproj/apl-package.json</code>.</p> </li> <li> <p>If your project incorporates other Tatin packages, install them, e.g.</p> <pre><code>]TATIN.InstallPackages aplteam-MarkAPL path/to/myproj\n</code></pre> <p> <code>]InstallPackages</code></p> <p>This will install the dependencies in <code>myproj/packages</code> and write there<sup>1</sup> a file <code>apl-dependencies.txt</code>.</p> </li> <li> <p>Finally, publish.</p> <pre><code>]TATIN.PublishPackage /path/to/myproj [tatin-test]\n</code></pre> <p> <code>]PublishPackage</code></p> </li> </ol>"},{"location":"publish-packages/#dependencies","title":"Dependencies","text":""},{"location":"publish-packages/#location","title":"Location","text":"<p>Where should your package\u2019s dependencies be installed?</p> <p>By default, Tatin installs them in a project subfolder <code>packages/</code>.</p> <p>If you manage your package as a Cider project, Tatin will check the Cider configuration properties <code>dependencies.tatin</code> and <code>dependencies_dev.tatin</code> and install where they say.</p> <p>If you do not use Cider you can use command options or API function parameters to specify an alternative to <code>packages/</code>.</p>"},{"location":"publish-packages/#unpublished-dependencies","title":"Unpublished dependencies","text":"<p>If you specify a dependency not (yet) published, the server you publish to will not object.</p> <p>This is because, when several packages are published, there might be mutual \u2013 or worse, circular \u2013 dependencies between them. Requiring dependencies to be already published would not work in that case.</p>"},{"location":"publish-packages/#url-protocols","title":"URL protocols","text":"<p>Tatin allows you to identify a package with a URL protocol, either the <code>file://</code> protocol for a local resource or <code>http://</code> or <code>https://</code> for a remote one.</p> <p>Useful as these are for local development, neither is acceptable for specifying a dependency of a published package.</p> URL protocols override Tatin\u2019s scan strategy <p>Normally when a dependency is required Tatin scans known registries in order of priority \u2013 unless a URL protocol is used.</p> <p>Use URL protocols for local development only, and only with care.</p> <p>If you publish a package <code>foo</code> with a dependency <code>goo</code> specified with a URL protocol, the registry will remove the protocol and retain only <code>goo</code>. When Tatin loads <code>foo</code> it will scan the registries in its search path, and use the first <code>goo</code> it finds.</p>"},{"location":"publish-packages/#user-command-packages","title":"User-command packages","text":"<p>A user-command package has a script that makes it a user command.</p> <p>The package might look like this:</p> <pre><code>MyUserCommand/\n    APLSource/\n        MyUserCommand/        \u235d Contains the code\n        TestData/\n        TestCases/\n        MyUserCommand.dyalog  \u235d The user command script\n    packages/\n        ...\n    packages_dev/\n        ...\n    apl-package.json\n    cider.config\n    LICENSE\n    README\n</code></pre> <p>The package configuration specifies</p> <pre><code>source: \"APLSource/MyUserCommand\",\n</code></pre> <p>which excludes <code>TestData/</code> and <code>TestCases/</code> from the published package, but also excludes script <code>MyUserCommand.dyalog</code> \u2013 which we need in the package root!</p> <p>So tell Tatin the package is a user command, and where to find its script. In the package configuration:</p> <pre><code>userCommandScript: \"APLSource/MyUserCommand.dyalog\",\n</code></pre> <p>This marks the package as a user command. Tatin first installs everything as usual, then moves the script to the root of the package.</p> <p>The installed package will then consist of:</p> <ul> <li>a folder for the <code>MyUserCommand</code> package</li> <li>folders for all dependencies</li> <li>a file <code>apl-buildlist.json</code></li> <li>a file <code>apl-dependencies.txt</code></li> <li>the user command script <code>MyUserCommand.dyalog</code></li> </ul> <p>A package must contain code.</p> <p>If you implement a user command as a single script file (quite possible for a simple command) that would not be true. So, separate the user-command script (with the required <code>Run</code>, <code>List</code> and <code>Help</code> functions) from the \u2018real code\u2019 that does the work.</p> <p>Keeping the real code in the package satisfies the requirement.</p>"},{"location":"publish-packages/#deleting-packages","title":"Deleting packages","text":"<p>A registry\u2019s delete policy controls whether you can delete a package published there:</p> <ul> <li><code>Any</code> \u2013 you may delete any package</li> <li><code>JustBetas</code> \u2013 you may delete only beta versions</li> <li><code>None</code> \u2013 you cannot delete any packages at all</li> </ul> <p>Each server-hosted registry publishes its delete policy on its home page.</p> <ol> <li> <p>By default Tatin assumes a subfolder <code>packages/</code> to contain dependencies.\u00a0\u21a9</p> </li> </ol>"},{"location":"publish/","title":"About publishing packages","text":"<p>About publishing and licensing Tatin packages, with a development workflow</p>"},{"location":"publish/#package-identity","title":"Package identity","text":"<p>A full package ID uniquely identifes a package. It follows semantic versioning conventions and has four parts:</p> <pre><code>group-name-version+buildnumber\n</code></pre>"},{"location":"publish/#group","title":"Group","text":"<p>A group might be</p> <ul> <li>the name of a company</li> <li>your name, even just your first name</li> <li>a term such as <code>aplteam</code> (but not that one)</li> </ul> <p>If you publish your package to the Principal Registry, maintain a home page there for the group: include anything useful like background, motivation, contact details, whatever.</p> <p>Home pages do not always make sense for a group, so a home page needs activating; see <code>GroupHomePages</code> in the INI file.</p>"},{"location":"publish/#package-name","title":"Package name","text":"<p>The package name should suggest what the package does.</p> <p>The combination of group and name must be unique, but if your package does something very similar, you could use a name already used by a different group. Be cautious about this; the practice could become unhelpful.</p>"},{"location":"publish/#version","title":"Version","text":"<p>The version consists of three numbers separated by dots, optionally followed by a description.</p> <pre><code>major.minor.patch-[description]\n</code></pre> <p>e.g.:</p> <pre><code>1.2.3-beta-1\n1.2.3-fix-for-the-foo-problem\n1.2.3-issue-234\n</code></pre> <p>The description can include hyphens, but not a <code>+</code>, which serves as a delimiter.</p>"},{"location":"publish/#build-number","title":"Build number","text":"<p>An integer that gets bumped (incremented) with each version.</p> <pre><code>1.2.3+453\n1.2.3-beta-1+911\n</code></pre> <p>Tatin bumps but otherwise largely ignores build numbers. Their only use is to distinguish builds when the version number does not change.</p> <p>In most contexts build numbers need not be specified and Tatin does not display them.</p>"},{"location":"publish/#licences","title":"Licences","text":"<p>Tatin is a community resource and offers software with minimal licence restrictions. All licences on the Principal Registry give users great freedom.</p> <p>If you host a Tatin registry you can set your own licence policy.</p> <p>To publish a package on the Principal Registry at tatin.dev or on the test server you must give it a <code>license</code> property with an acceptable value.</p> <p> <code>]ListLicences</code> <code>ListLicences</code></p>"},{"location":"publish/#api-keys","title":"API keys","text":"<p>To publish a package (or delete or deprecate it) you need an API key<sup>1</sup> for the registry.</p> <p> Request an API key</p> <p>Include</p> <ul> <li>Your desired group name (case insensitive)</li> <li>Your real name</li> <li>Company name, if relevant</li> <li>Maintainer\u2019s email address</li> </ul>"},{"location":"publish/#tatin-principal-registry","title":"Tatin Principal Registry","text":"<p>To publish on the Principal Registry at tatin.dev first request an API key.</p> <p>When you receive it, create a home page for your group at the registry.</p>"},{"location":"publish/#tatin-test-server","title":"Tatin Test Server","text":"<p>The Test Server publishes its API key on its website: <code>Tatin-Test-API-Key</code>.</p> <p>You can publish on the Test Server anything you want, using any group name except <code>aplteam</code> or <code>dyalog</code>.</p> <p>The Test Server is reset now and then, and whatever you publish there disappears.</p>"},{"location":"publish/#your-keys","title":"Your keys","text":"<p>Your API keys are saved in your user settings. The quickest and safest way to edit them is with the command.</p> <p> <code>]TATIN.UserSettings -edit</code></p>"},{"location":"publish/#development-workflow","title":"Development workflow","text":"<p>Suppose you develop Tatin packages for your employer, company XYZ.</p> <ol> <li> <p>Run a Tatin server on your local machine; give it alias <code>[my]</code>.</p> <p>This is just for you, nobody else. This is where you first publish a package.</p> <p>Give it the highest priority of all registries, ensuring that when a package is on several registries it is found first on <code>[my]</code>.</p> </li> <li> <p>Run a team Tatin Server on the XYZ intranet; give it alias <code>[my-team]</code>.</p> <p>Use it to publish beta versions your team might want to use. Give it the second-highest priority.</p> </li> <li> <p>Run a corporate Tatin Server for production packages.</p> </li> <li> <p>Your packages might depend on packages on <code>[tatin]</code>.     Of the four Registries, give this the lowest priority.</p> </li> <li> <p>You might also have the Tatin Test Server in your user settings, with a priority of zero.     It will be ignored when registries are scanned, but you could still use it.</p> </li> </ol> <p>You can now develop a package <code>Foo</code> and publish it on <code>[my]</code>, probably several times until it is stable.</p> <p>You would then publish it on <code>[my-team]</code>. At the same time, you would either delete the package from <code>[my]</code> or set the registry\u2019s priority to zero so scans ignore it.</p> <p>When all is good, publish the beta as a production release on the corporate server. At the same time, you might delete the package from the Team server.</p> <ol> <li> <p>Fancy expression for a password used by an application.\u00a0\u21a9</p> </li> </ol>"},{"location":"release-notes/","title":"Release notes","text":"<p>The notes contain </p> <ul> <li>actions to take before using a new version</li> <li>important information</li> </ul> <p>For a complete list of fixes, added features, etc. see  Tatin on GitHub.</p> <p> Semantic versioning</p>"},{"location":"release-notes/#version-01200","title":"Version 0.120.0","text":"<p>2025-05-03</p> <p><code>LoadPackages</code> now throws an error when one of the packages specified cannot be found. No package is loaded.</p> <p>No action required</p>"},{"location":"release-notes/#version-01190","title":"Version 0.119.0","text":"<p>2025-03-12</p> <p>No action required</p>"},{"location":"release-notes/#version-01182","title":"Version 0.118.2","text":"<p>2025-02-03</p> <p>No action required</p>"},{"location":"release-notes/#version-01181","title":"Version 0.118.1","text":"<p>2025-01-14</p> <p>No action required</p>"},{"location":"release-notes/#version-01180","title":"Version 0.118.0","text":"<p>2024-12-30</p> <p>The API function <code>BuildPackage</code> does not process a property <code>tatinVars</code> anymore; if it is fed one anyway, it will throw an error.</p> <p>The function <code>CreateBuildParms</code> does not contain a variable <code>tatinVars</code> anymore but a variable <code>projectspace</code>, which is optional. You may set it to the namespace where the package project lives. That enables <code>BuildPackage</code> to update <code>TatinVars.CONFIG</code> in that namespace, otherwise <code>BuildPackage</code> doesn\u2019t know where to look.</p> <p>Accordingly the option <code>-tatinVars=</code> was removed from the <code>]BuildPackage</code> user command but the option <code>-projectspace=</code> was introduced.</p> <p>The user command <code>]ReInstallDependencies</code> now accepts a flag <code>-recursive</code>. This can be put to use with a folder that contains multiple independent packages, for example the folder <code>[MyUCMDs]</code>: all installed packages in that folder can be re-installed and (in this instance) updated without user interaction with the following statement.</p> <pre><code>]ReInstallDependencies [MyUCMDs] -recursive -update -force\n</code></pre>"},{"location":"release-notes/#version-01170","title":"Version 0.117.0","text":"<p>2024-12-08</p> <p>The way build numbers are processed has changed: prior to 0.117.0 when a complete version number \u2014 including a build number \u2014  was passed on to <code>]BuildPackage</code> the build number was not bumped. Now it is bumped.</p>"},{"location":"release-notes/#version-01160","title":"Version 0.116.0","text":"<p>2024-11-30</p> <p>Tatin now requires at least 18.2: 18.0 is not supported any longer.</p>"},{"location":"release-notes/#version-01153","title":"Version 0.115.3","text":"<p>2024-11-25</p> <p>Fixes a gaping security hole (Server only, group home page)</p>"},{"location":"release-notes/#version-01152","title":"Version 0.115.2","text":"<p>2024-11-16</p> <p>No action required</p>"},{"location":"release-notes/#version-01151","title":"Version 0.115.1","text":"<p>2024-11-15</p> <p>No action required</p>"},{"location":"release-notes/#version-01150","title":"Version 0.115.0","text":"<p>2024-10-14</p> <p>No action required</p>"},{"location":"release-notes/#version-01140","title":"Version 0.114.0","text":"<p>2024-09-30</p> <p>In case you are on Windows and you are using OneDrive then you might need to pay attention. </p> <p>Older versions of Tatin did not cooperate with OneDrive; this can potentially cause problems. A new document, \"Tatin and OneDrive,\" discusses this issue. If you use OneDrive, read it!</p> <p>Otherwise no action is required, but be aware of changes made to <code>]ListVersions</code>: if no argument is provided it checks on open Cider projects now. In other words, it became more powerful.</p>"},{"location":"release-notes/#version-01131","title":"Version 0.113.1","text":"<p>2024-09-08</p> <p>No action required</p>"},{"location":"release-notes/#version-01130","title":"Version 0.113.0","text":"<p>2024-09-05</p> <p>No action required</p>"},{"location":"release-notes/#version-01121","title":"Version 0.112.1","text":"<p>2024-08-16</p> <p>No action required</p>"},{"location":"release-notes/#version-01120","title":"Version 0.112.0","text":"<p>2024-07-14</p> <p>The <code>]CopyRegistry</code> user command, introduced in 0.110.0, got a changed syntax:</p> <ul> <li> <p>The <code>-full</code> flag was removed.</p> </li> <li> <p>Default behaviour is now what was so far achievable with <code>-full</code>      except that deprecated packages are now copied as well.</p> <p>This is a necessity for compatability, because some package might well depend on an earlier version of a now deprecated package.</p> </li> <li> <p>With <code>-dry</code> one might omit both arguments, meaning that the URL defaults to <code>[tatin]</code> while no path is required.</p> </li> <li> <p>The list of copied packages is now returned as a matrix.</p> </li> </ul>"},{"location":"release-notes/#version-01110","title":"Version 0.111.0","text":"<p>2024-07-12</p> <p>No action required</p>"},{"location":"release-notes/#version-01100","title":"Version 0.110.0","text":"<p>2024-07-09</p> <p>A maintenance file \"2024-07-07-Inject-Exclude.aplf\" was introduced. </p> <p>It allows to add the new \"exclude\" property (introduced with version 0.109.0) to be introduced into all saved packages as an empty text vector.</p> <p>You don't have to run this maintenance function on all your packages (Tatin deals with both a defined \"exclude\" as well as an absent \"exclude\") but it is better for future use when this is part of all packages.</p>"},{"location":"release-notes/#version-01090","title":"Version 0.109.0","text":"<p>2024-06-27</p> <p>No action required</p>"},{"location":"release-notes/#version-01081","title":"Version 0.108.1","text":"<p>2024-05-04</p> <p>No action required</p>"},{"location":"release-notes/#version-01080","title":"Version 0.108.0","text":"<p>2024-05-02</p> <ul> <li>You must update your client to 0.108.0 for correct results \u2014 prior versions are incompatible with 0.108.0!</li> </ul>"},{"location":"release-notes/#version-01070","title":"Version 0.107.0","text":"<p>2024-04-04</p> <p>The syntax of the API function <code>DeletePackages</code> has changed.</p>"},{"location":"release-notes/#version-01062","title":"Version 0.106.2","text":"<p>2024-03-27</p> <p>Action is required with version 18.2 and/or 18.0</p> <p>With this version the Tatin user commands won't be available in the session until you either execute <code>]UReset</code> yourself, or you add the following code to your <code>setup.dyalog</code> in <code>MyUCMDs/</code>:</p> <pre><code>:If ~IfAtLeastVersion 19\n    {}\u2395SE.SALTUtils.ResetUCMDcache -1                 \n:EndIf\n</code></pre>"},{"location":"release-notes/#version-01061","title":"Version 0.106.1","text":"<p>2024-03-18</p> <p>No action required when running Tatin. </p>"},{"location":"release-notes/#version-01060","title":"Version 0.106.0","text":"<p>2024-03-12</p> <p>No action required when running Tatin. </p> <p>However, when developing (contributing to) Tatin there is a significant change: read \"Special case: working on user commands\" in the \"Tatin for Contributors\" document for details.</p>"},{"location":"release-notes/#version-01050","title":"Version 0.105.0","text":"<p>2024-03-02</p> <p>Potentially breaking changes: </p> <ul> <li>The function <code>DeletePackage</code> was renamed: <code>DeletePackages</code></li> <li>The user command <code>]DeletePackage</code> was renamed: <code>]DeletePackages</code></li> </ul>"},{"location":"release-notes/#version-01041","title":"Version 0.104.1","text":"<p>2024-01-28</p> <p>The client requires a server on 0.104.1 as well</p>"},{"location":"release-notes/#version-01040","title":"Version 0.104.0","text":"<p>2024-01-22</p> <p>The result of both <code>]ListRegistries</code> and the corresponding API function return a different (extended) result now.</p> <p>This implies that older versions of Tatin than 0.104.0 are incompatible with this new version, therefore you are forced to update.</p> <p>Apart from the update no action is required.</p>"},{"location":"release-notes/#version-01032","title":"Version 0.103.2","text":"<p>2024-01-16</p> <p>No action required.</p>"},{"location":"release-notes/#version-01031","title":"Version 0.103.1","text":"<p>2023-12-14</p> <p>No action required.</p>"},{"location":"release-notes/#version-01030","title":"Version 0.103.0","text":"<p>2023-11-04</p> <p>No action required but note that the result of the API function <code>LoadPackages</code> has changed.</p>"},{"location":"release-notes/#version-01023","title":"Version 0.102.3","text":"<p>2023-10-13</p> <p>No action required</p>"},{"location":"release-notes/#version-01022","title":"Version 0.102.2","text":"<p>2023-10-09</p> <p>No action required</p>"},{"location":"release-notes/#version-01021","title":"Version 0.102.1","text":"<p>2023-10-07</p> <p>Most importantly, a bug fix in <code>]TATIN.CiderUpdate</code></p>"},{"location":"release-notes/#version-01020","title":"Version 0.102.0","text":"<p>2023-10-04</p> <p>Most importantly, a revised install procedure</p>"},{"location":"release-notes/#version-01012","title":"Version 0.101.2","text":"<p>2023-09-30</p> <p>Very important bug fix in <code>UnInstallPackages</code></p>"},{"location":"release-notes/#version-01011","title":"Version 0.101.1","text":"<p>2023-09-26</p> <p>Two massive changes:</p> <ul> <li> <p>This version is only compatible with Cider 0.36.0 or later</p> </li> <li> <p>The installation folder is not <code>MyUCMDs/</code> anymore. However, <code>]TATIN.UpdateTatin</code> of your old version cannot know about this, therefore you have to take action once in order to get Tatin into the right folder. </p> <p>See <code>]UpdateTatin</code> for details.</p> </li> <li> <p>In future <code>]TATIN.UpdateTatin</code> will use the new installation folder.</p> </li> </ul>"},{"location":"release-notes/#version-01002","title":"Version 0.100.2","text":"<p>2023-09-23</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-01001","title":"Version 0.100.1","text":"<p>2023-08-28</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-01000","title":"Version 0.100.0","text":"<p>2023-08-27</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0991","title":"Version 0.99.1","text":"<p>2023-08-05</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0990","title":"Version 0.99.0","text":"<p>2023-08-02</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0982","title":"Version 0.98.2","text":"<p>2023-07-14</p> <p>This release addresses a bug in the server; the client has not been changed.</p> <p>Update only required if you run a server.</p>"},{"location":"release-notes/#version-0981","title":"Version 0.98.1","text":"<p>2023-07-13</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0980","title":"Version 0.98.0","text":"<p>2023-07-05</p> <ul> <li> <p>No breaking changes for the Tatin client, therefore there are no user actions required</p> </li> <li> <p>If you run a Tatin server you don't need to take action but you should be aware of a major change</p> </li> </ul> <p>Before version 0.98.0 credentials got stored in a file <code>Credentials.txt</code>. The format was:</p> <pre><code>&lt;group&gt;=&lt;api-key&gt;\n</code></pre> <p>The API-keys were stored as clear text. We don't want that anymore.</p> <p>With version 0.98.0 credentials will be stored in a file <code>Credentials.csv</code>. The format is different:</p> <pre><code>&lt;group&gt;,&lt;api-key-hash&gt;,&lt;Salt&gt;\n</code></pre> <p>The server will convert <code>Credentials.txt</code> automatically into <code>Credentials.csv</code>. Afterwards there is a new file <code>Credentials.csv</code> while the old file <code>Credentials.txt</code> will be deleted.</p> <p>Note that you might create at a later stage a new file <code>Credentials.txt</code> with entries like</p> <pre><code>&lt;group-name&gt;=&lt;api-key&gt;\n</code></pre> <p>or</p> <pre><code>&lt;group-name&gt;,&lt;api-key&gt;\n</code></pre> <p>That allows you to add new groups, or overwrite existing ones, for example when somebody lost the API-key.</p> <p>The server will perform the following actions:</p> <ul> <li>Take the data and convert it</li> <li>Delete rows from <code>Credentials.csv</code> that are also contained in <code>Credentials.txt</code> (same group name)</li> <li>Add the data to <code>Credentials.csv</code> </li> <li>Delete <code>Credentials.txt</code></li> </ul>"},{"location":"release-notes/#version-0971","title":"Version 0.97.1","text":"<p>2023-06-30</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0970","title":"Version 0.97.0","text":"<p>2023-06-14</p> <p>This version comes with several breaking changes:</p> <ul> <li>The <code>]FindDependencies</code> user command's <code>-detailed</code> property has been renamed to <code>verbose</code></li> <li>The API function <code>FindDependencies</code> has a changed syntax and returns a changed result.</li> </ul>"},{"location":"release-notes/#version-0962","title":"Version 0.96.2","text":"<p>2023-06-08</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0961","title":"Version 0.96.1","text":"<p>2023-05-21</p> <p>No breaking changes, no user actions required.</p>"},{"location":"release-notes/#version-0960","title":"Version 0.96.0","text":"<p>2023-05-18</p> <p>No breaking changes, no user actions required.</p>"},{"location":"secure-server/","title":"Secure your Tatin registry","text":"<p>How to authorise users and secure your Tatin server from attack</p> <p>Issue and require credentials for publishing packages on your server. Encrypt internet communications by installing security certificates; or (better) use a reverse proxy to shield your Tatin registry behind an industrial-strength webserver such as Apache or Nginx.</p>"},{"location":"secure-server/#credentials","title":"Credentials","text":"<p>The server requires and accepts API keys according to <code>Credentials.csv</code> in the server\u2019s home folder.</p> <p>Create a UUID and use that as an API key.</p>"},{"location":"secure-server/#add-an-api-key","title":"Add an API key","text":"<p>To add an API key to the stored credentials, put it in a file <code>Credentials.txt</code> in the server\u2019s home folder as either</p> <pre><code>&lt;group-name&gt;,&lt;api-key&gt;\n*,&lt;api-key&gt;\n</code></pre> <p>The server:</p> <ul> <li>deletes from <code>Credentials.csv</code> rules with matching group names</li> <li>creates a Salt for each API key in <code>Credentials.txt</code></li> <li>converts each key and its Salt into a hash and records the rule in <code>Credentials.csv</code></li> <li>deletes file <code>Credentials.txt</code></li> </ul>"},{"location":"secure-server/#credential-rules","title":"Credential rules","text":"<p>Rules in <code>Credentials.csv</code> have syntax:</p> <pre><code>[group-name | *] [,api-key-hash[,salt]]\n; just a comment\n</code></pre> <p>Some rule examples:</p> <pre><code>; require hash1 key for group1\ngroup1,hash1,salt1\n\n; require hash2 key for everything else\n*,hash2,salt2\n\n; allow no-key publication for everything else\n*\n</code></pre> <p>Having <code>*</code> (or <code>*,</code> or <code>*=</code>) as the only rule is the same as having no credentials file.</p> <p>The rules are read in sequence and can mix different scenarios.</p> Some credential file examples <p>Require individual keys for <code>group1</code> and <code>group2</code>, and a \u2018master\u2019 key for other groups:</p> <pre><code>group1,hash1,salt1\ngroup2,hash2,salt2\n*,hash3,salt3\n</code></pre> <p>Require keys for <code>group1</code> and <code>group2</code> only     group1,hash1     group2,hash2     *</p> <p>Allow no-key publication for a specific group:</p> <pre><code>group1,hash1,salt1\ngroup2,\n*,hash3,salt3\n</code></pre>"},{"location":"secure-server/#delete-a-rule","title":"Delete a rule","text":"<p>To delete a rule for a group, edit the file <code>Credentials.csv</code>.</p>"},{"location":"secure-server/#security-certificates","title":"Security certificates","text":"<p>Encrypting communications (HTTPS) requires security certificates. The server download includes two:</p> <pre><code>Assets/Runtime/Certificates/ca-[cert|key].pem\nAssets/Runtime/Certificates/localhost-[cert|key].pem\n</code></pre> <p>GitHub blocks downloads of certificates. If the PEMs are missing, you should see eponymous files with a further extension <code>.RemoveMe</code>.</p> <p>Removing that extension should produce what you need.</p> <p>Instead of enabling HTTPS, shield the server with a reverse proxy.</p>"},{"location":"secure-server/#reverse-proxy","title":"Reverse proxy","text":"<p>If your registry serves requests from the internet, shield it behind an industrial-strength web server like Apache or Nginx.</p> <p>This improves security and defences against e.g. DDoS attacks. It also offers an easy way to implement load balancing.</p> <p>Apache can be used as a reverse-proxy server, a.k.a. gateway server.</p> <p>Suppose Tatin is listening on port 8081.</p> <p>Add the following lines to the web server\u2019s configuration file, typically <code>/etc/apache2/sites-available</code>.</p> <pre><code>ProxyPreserveHost on\nProxyPass / http://localhost:8081/\nProxyPassReverse / http://localhost:8081/\n</code></pre> <p>In <code>/etc/apache2/sites-enabled</code> there should be just a link pointing to <code>/etc/apache2/sites-available</code>.</p> <p>The <code>ProxyPass</code> directive forwards incoming requests to the Tatin server.</p> <p>The <code>ProxyPassReverse</code> directive ensures the <code>Location:</code> headers generated by your Tatin server are modified to point instead to the web server.</p> <p> Apache guides: Reverse Proxy and Module mod_proxy</p>"},{"location":"semanticversioning/","title":"Tatin and Semantic Versioning","text":"<p>Tatin is based on the concept of Semantic Versioning (SemVer), so before we go into any details, we first need to understand SemVer. </p> <p>If you are already familiar with the concept of semantic versioning then of course you may skip this document.</p>"},{"location":"semanticversioning/#format","title":"Format","text":"<p>The version number of a Tatin package must follow the rules for Semantic Versioning: it always has the format <code>{major}.{minor}.{patch}</code>. </p> <p>After <code>{patch}</code>, more information might be available, separated from the patch number by a hyphen.</p> <p>Valid examples for a version number are therefore:</p> <pre><code>0.1.0\n1.0.0\n12.23.199\n1.2.3-beta-1     \n</code></pre> <p>These pieces of information fully participate when Tatin needs to establish package precedence:</p> <p><code>1.2.3</code> is \"better\" than  <code>1.2.2</code> but also \"better\" than <code>1.2.3-beta1</code> of course.</p> <p>Information after the hyphen is restricted to ASCII characters and digits until a space or a plus (<code>+</code>) is detected. </p> <p>The plus (<code>+</code>) is used to separate an (optional) build number from the other parts of a version number.</p>"},{"location":"semanticversioning/#build-numbers","title":"Build numbers","text":"<p>After {major}-{minor}-{patch} you may add the optional build number. Build numbers do not participate in establishing precedence and are therefore ignored by Tatin when compiling the name of a package and/or a package ZIP file.</p> <p>I&gt; That means that you cannot publish two packages that share the same group-name, package-name, major-no, minor-no and patch-no but have different build numbers - they are the same as far as Tatin is concerned.</p> <p>A build number, when specified, needs to be separated by a <code>+</code>. A build number may consist of digits only.</p> <pre><code>2.3.4+1456\n1.2.3-beta-1      \u235d becomes 1.2.3-beta-1 as a Tatin package\n1.2.3-beta-1+123  \u235d becomes 1.2.3-beta-1 as a Tatin package\n</code></pre> <p>Therefore <code>1.2.3-beta-1.abc</code> is invalid.</p> <p>The Semantic Versioning rules define when exactly which part of the version number may or must be bumped. They also define which parts are considered when establishing precedence: build numbers are always ignored.</p>"},{"location":"semanticversioning/#terminology-and-versioning-rules","title":"Terminology and versioning Rules","text":"<p>Given <code>1.2.3+4</code>:</p> <ul> <li><code>1</code> is the major version number</li> <li><code>2</code> is the minor version number</li> <li><code>3</code> is the patch number </li> <li>The (optional) <code>4</code> is the build number.</li> </ul>"},{"location":"semanticversioning/#the-build-number","title":"The build number","text":"<p>The build number is optional and is ignored by Tatin. However, if a package has a build-number, it is bumped whenever the package is built again, no matter what. It is never reset. </p>"},{"location":"semanticversioning/#the-patch-number","title":"The Patch Number","text":"<p>The patch number is bumped only when a change does not affect compatibility. </p> <p>A typical example is a bug fix: imagine that a function in a package crashes because an edge condition was not handled. When you fix that problem, you may bump the patch number because nothing else has changed. A consumer of the package can be reasonably confident that everything that worked before will continue to work.</p> <p>However, in real life things get messy pretty quickly: the consumer of a package might mistake a bug for a feature if it does not crash but does something it shouldn't, and take advantage of the bug. Imagine that a new version of the package comes with a fix for just that bug...</p> <p>If chances are high that a consumer might rely on the bug then you should bump the Major number rather than the Patch number - see there. Very old bugs are excellent candidates for that.</p>"},{"location":"semanticversioning/#the-minor-number","title":"The Minor number","text":"<p>The minor version number is bumped in case functionality was added to a package. </p> <p>That means that compatibility should still be guaranteed: anything else works exactly as before. A consumer should be confident when updating the package that nothing will break. She just may take advantage of, say, a function added to the API.</p> <p>A&gt; ### Chances of breaking things A&gt; A&gt; Note that by definition it seems that a change of the minor number is indicating a very low risk: just adding functionality should never change anything that has worked before, while a change in the patch number might come from a bug fix your code relies on.  A&gt; A&gt; In reality however a version with a new (bumped) minor version number often comes with bug fixes as well.</p>"},{"location":"semanticversioning/#the-major-number","title":"The Major number","text":"<p>When you change the API not by just adding stuff but by deleting or renaming parts of the public interface, or changing the parameters that an API function requires, then the package is guaranteed to be incompatible with earlier versions. If that's the case then you must bump the major version number.</p> <p>These two packages:</p> <pre><code>aplteam-foo-1.0.0\naplteam-GOO-1.0.0\n</code></pre> <p>... are of course considered to be different packages, but according to the concept of SemVer these two packages:</p> <pre><code>aplteam-foo-1.0.0\naplteam-foo-2.0.0\n</code></pre> <p>... are also considered to be different packages.</p> <p>Tatin reflects that in several ways, for example by listing all major versions of a package when this user command is invoked:</p> <pre><code>      ]tatin.ListPackages\n</code></pre>"},{"location":"semanticversioning/#why-semantic-versioning","title":"Why Semantic versioning?","text":"<p>Before the introduction of the rules of Semantic Versioning, everybody assigned version numbers to their liking. Updating to a new version always carried a significant risk that things would break.</p> <p>With the rules of Semantic Versioning in place, if everybody involved acts accordingly and sensibly, updating should be much safer. </p> <p>However, things can get pretty complicated even with Semantic Versioning; see the Load and Update Strategy.</p> <p>Semantic versioning came into being via this website:</p> <p>https://semver.org/</p>"},{"location":"test/","title":"Testing Tatin","text":"<p>Before submitting a pull request for your changes, confirm they pass the tests.</p> <p>The Tester2 framework used for testing Tatin is very powerful, and offers lots of options. Only the basics are covered here.</p> <p> Tester2 <code>]ADOC #.Tatin.Tester2</code> (reference)</p> <ol> <li> <p>Open Tatin in a new instance of Dyalog.</p> <pre><code>]CIDER.OpenProject /path/to/Tatin\n</code></pre> </li> <li> <p>Prepare the test framework.</p> <pre><code>#.Tatin.TestCases.Prepare\n</code></pre> <p>This initializes Tatin as a client and prepares for creating a code-coverage report. It also creates a number of references needed by the tests.</p> <p>It changes the current directory, establishes all required references and instantiates the <code>Tester2</code> class as <code>T</code>.</p> <p>You need call <code>Prepare</code> only once.</p> </li> <li> <p>Run the tests.</p> </li> </ol>"},{"location":"test/#run-the-full-test-suite","title":"Run the full test suite","text":"<pre><code>    #.Tatin.TestCases.RunTests\n</code></pre> <p>This runs all the tests in Debug mode, so if something goes wrong the framework will stop and you can investigate right away,</p> <p>You will be asked if you want to copy the test data to a temporary folder in preparation. The usual answer is Yes.</p>  Windows Linux   macOS <p>You will be asked if you want to start a test server. The usual answer is Yes.</p> <p>You will be asked to start the server yourself before carrying on. With this procedure for starting a Test Server, testing cannot be automated.</p> <p>You will be shown a command like</p> <pre><code>)Load /path/2/test-server/RunTatinServer.dws\n</code></pre> <p>Copy the command and run it in a new Dyalog instance. The command will load and run the server in a temporary directory.</p> What RunTests does <ul> <li>Changes the current directory</li> <li>Establishes all required references</li> <li>Instantiates the <code>Tester2</code> class as <code>T</code></li> <li>Starts a local Tatin test server if you confirm (Windows), or helps you start a test server (other platforms)</li> <li>Calls the <code>T.Run</code> function to run all the test cases, including those that communicate with a locally running Tatin test server and the principal Tatin server available at https://tatin.dev</li> </ul>"},{"location":"test/#run-selected-tests","title":"Run selected tests","text":"<p>Executing the full test suite takes considerable time. Also, caching is switched off (except when caching itself is tested). You will often want to run only parts of the test suite.</p> <p>The tests are grouped, with the grouping reflected in the names of the test functions, for example, <code>Test_API_001</code> and <code>Test_UserCommand_001</code>.</p>"},{"location":"test/#choose-tests","title":"Choose tests","text":"<p>You can now list the groups and the number of tests in them:</p> <pre><code>      T.ListGroups\n Test_API             27\n Test_Build            1\n Test_Cache           10\n Test_CheckVersions    6\n ...\n</code></pre> <p>You can also list tests whose names match a pattern:</p> <pre><code>      T.ListTestFunctions 'Scan*'\n Test_ScanRegistries_002  Search for a specific package wit...\n Test_ScanRegistries_003  Enforce a Registry scan after def...\n Test_ScanRegistries_004  Enforce a Registry scan after def...\n Test_ScanRegistries_005  Enforce a Registry scan. The firs...\n</code></pre> <p>The first comment line after any header lines is displayed.</p> <p>Specify <code>'view'</code> as the left argument to display the list in a read-only Editor window.</p>"},{"location":"test/#run-one-or-more-tests","title":"Run one or more tests","text":"<p>The first example below runs the <code>Test_UC_600</code> function, and so on.</p> <pre><code>    #.Tatin.TestCases.T.RunThese 'UC' 600            \u235d one test\n    #.Tatin.TestCases.T.RunThese 'UC' (600 601 602)  \u235d three tests\n    #.Tatin.TestCases.T.RunThese 'UC'                \u235d whole group\n    #.Tatin.TestCases.T.RunThese 'API,Misc'          \u235d two groups\n    #.Tatin.TestCases.T.RunThese '~UserCommand'      \u235d all except..\n</code></pre> <p>Depending on which test cases you select, you might not need test data, or even a running test server,</p>"},{"location":"test/#run-batch-tests","title":"Run batch tests","text":"<p>Batch tests do not require user interaction.</p> <p>To run only the batch tests:</p> <pre><code>#.Tatin.TestCases.RunBatchTests 1\n</code></pre> <p>The 1 required as right argument is a protection against accidental calls.</p>"},{"location":"test/#abort-a-test-run","title":"Abort a test run","text":"<p>You might need to abort the test suite, for example if a test reveals a severe bug that makes running the remaining tests pointless.</p> <p>Resist the temptation to use <code>)reset</code>; instead make the test suite clean up after itself:</p> <pre><code>#.Tatin.TestCases.T.QuitTests\n</code></pre>"},{"location":"test/#debug-mode","title":"Debug mode","text":"<p>Errors are trapped by default: if a test case fails or crashes, the test framework carries on.</p> <p>In Debug mode, the test suite stops on errors to allow you to investigate.</p> <p>Functions <code>RunThese</code> and <code>RunBatchTests</code> both take a flag as an optional left argument.</p> <p>The default value is 0. When set to 1, tests are run in Debug mode.</p> <pre><code>1 #.Tatin.TestCases.T.RunThese 'UC' (600 601 602)\n1 #.Tatin.TestCases.RunBatchTests 1\n</code></pre>"},{"location":"test/#a-new-version-for-testing","title":"A new version for testing","text":"<p>In a normal workflow you create a new version of Tatin only after passing all the tests.</p> <p>But there are scenarios in which you need a new version in order to run the tests.</p> <p>For example, suppose one group of tests executes user commands. If your code changes affect the commands, then you need the changed code in <code>\u2395SE</code> for testing \u2013 but that requires that you first create a new version.</p> <p>For this reason, a test checks that the version number in the workspace and in <code>\u2395SE</code> match.</p>"},{"location":"test/#automated-builds","title":"Automated builds","text":"<p>You can run batch tests as part of an automated build process; start the test suite either from APL or from the command line.</p>"},{"location":"test/#running-tests-from-apl","title":"Running tests from APL","text":"<pre><code>#.Tatin.TestCases.RunBatchTests 1\n</code></pre> <p>The test suite itself starts (and shuts down) a Tatin server; Debug mode is off.</p> <p>The function ignores the few test cases that require human interaction</p> <p><code>RunBatchTests</code> checks the command line that launched Dyalog to see if <code>OFF2=1</code> was specified then, after the last test case</p> specified If all tests passed, executes <code>\u2395OFF</code>; otherwise <code>\u2395OFF 123</code>.The calling environment can see whether all the tests were passed or not. not A message is printed to the session, indicating success or failure. <p>Warning</p> <p><code>OFF=1</code> in the command line would also work, but would kill Plodder, the underlying HTTP server used by Tatin. That might be too early: for example, you could not then get a code coverage report.</p>"},{"location":"test/#running-tests-from-the-command-line","title":"Running tests from the command line","text":"<p>The Tatin root directory contains shell scripts that run the batch tests.</p> <pre><code>RunTests.bat // Windows\nRunTests.sh  // Linux, macOS\n</code></pre> <p>These are templates: check their contents, you might need to make amendments.</p>"},{"location":"test/#notes","title":"Notes","text":""},{"location":"test/#port-5001","title":"Port 5001","text":"<p>By default, the test cases use port 5001 for communication between the client and the Test Server.</p> <p>Change the INI files for both server and client if that does not work for you.</p>"},{"location":"test/#testing-on-a-stand-alone-tatin-server","title":"Testing on a stand-alone Tatin server","text":"<p>You do not have to run the test cases from the Tatin client.</p> <p>To start and run a local Tatin test server yourself, in a new Dyalog instance</p> <pre><code>]CIDER.OpenProject /path/to/Tatin\n#.Tatin.TestCasesServer.RunTests\n</code></pre> <p>Any code changes you make will be written back to disk.</p>"},{"location":"test/#stress-testing","title":"Stress testing","text":"<p>You might be tempted to run the client tests in multiple instances to put some pressure on the Tatin Server.</p> <p>The client tests are not suitable for this.</p> <p>For example, the tests in the <code>Cache</code> group must be executed in sequence, as they rely on each other. Generally in testing, this should be avoided but here, for technical reasons, it\u2019s a must. Running this group in parallel breaches this, and is certain to fail.</p>"},{"location":"user-commands-host/","title":"User commands for hosting","text":"<p>User commands for hosting a Tatin registry</p> <p>CopyRegistry Maintenance</p> <p> User commands User commands for publishing</p>"},{"location":"user-commands-host/#copy-registry","title":"Copy registry","text":"<pre><code>]TATIN.CopyRegistry [source] [target]\n</code></pre> <p>Where</p> <ul> <li><code>source</code> is the URL or alias of a Tatin registry (defaults to <code>[tatin]</code>)</li> <li><code>target</code> is a path to a local folder (optional if <code>dry</code> flag set)</li> </ul> <p>copy non-deprecated packages from <code>source</code> to <code>target</code> if not already present.</p> dependencies= Flag: whether to copy dependencies, default 1. (Useful only for test cases.) dry List packages that would be copied, but copy nothing. force Overwrite existing packages. group= Copy packages only from specified group, but also their dependencies. latest Copy only the latest minor version of each major version. list= <p>One of</p><ul><li>a comma-separated list of package IDs</li><li>a file with package names, one per row, specified with the <code>file://</code> protocol</li><li>a fully qualified variable name</li></ul><p>Specify all packages as group-name or group-name-major.</p> verbose= <ol><li>Print a detailed report for each package copied.</li><li>Print reports as the list is processed.</li></ol> Examples <p>List packages that would be copied.</p> <pre><code>]CopyRegistry [tatin] -dry\n]CopyRegistry -dry\n</code></pre> <p>Copy all packages from <code>[tatin]</code> if not already available.</p> <pre><code>]CopyRegistry /path/2/Reg\n</code></pre> <p>Copy the latest minor versions of the highest major versions of packages from <code>[company-reg]</code>.</p> <pre><code>]CopyRegistry [company-reg] /path/2/Reg -latest\n</code></pre> <p>Copy from <code>[tatin]</code> all packages of the group <code>aplteam</code>.</p> <pre><code>]CopyRegistry /path/2/Reg group=aplteam -force\n</code></pre> <p>Copy from <code>[tatin]</code>, if not already available, packages listed in variable <code>#.MyVars</code>.</p> <pre><code>#.MyVars\u2190'aplteam-FilesAndDirs,aplteam-APLTreeUtils2'\n]CopyRegistry /path/2/Reg -list=#.MyVars\n</code></pre> <p>Copy from <code>[tatin]</code> packages specified in variable <code>#.MyVars</code></p> <pre><code>]CopyRegistry /path/2/Reg -list=aplteam-FilesAndDirs-4 -force\n</code></pre> <p>Copy all packages specified in the file /myPkgs.txt if not already available</p> <pre><code>]CopyRegistry /path/2/Reg -list=file=/myPkgs.txt\n</code></pre> <p> API: <code>CopyRegistry</code></p>"},{"location":"user-commands-host/#maintenance","title":"Maintenance","text":"<pre><code>]TATIN.Maintenance [path]\n</code></pre> <p>Where <code>path</code> is a path to a folder containing one or more packages, ask me to select functions from the Maintenance Library, then apply them to the packages.</p> <p>Invoked with an option, the command displays information only and leaves the packages untouched.</p> dry Show what the command would do. info Show more information about the command and its purpose. show Show the leading comments of the selected functions. <p>The <code>Maintenance/</code> folder in the Tatin installation folder holds maintenance jobs: APLF files for functions that modify Tatin packages.</p> <p>The command asks you to pick jobs to run from the Maintenance Folder, then searches recursively in the file path for package config files. When it finds one, it applies the maintenance functions sequentially, with the package config data as argument,  receiving the same as result, possibly modified, which it writes back to the package, and also to the ZIP file.</p> <p>The name of a maintenance function follows a pattern: the date it was introduced, and  a short description of what it does. Tatin records the run and prevents repetition, by appending the extension <code>.executed</code> to the APLF file\u2019s name.</p> <p>Some use cases:</p> <ul> <li>inject new properties into package config files</li> <li>remove deprecated properties from package config files</li> <li>rename properties in package config files</li> </ul> <p>Release notes tell you when a maintenance function is introduced, and when, why, and for what to use it.</p>"},{"location":"user-commands-publish/","title":"User commands for publishing","text":"<p>User commands for publishing Tatin packages</p> <p>BuildPackage DeprecatePackage CreatePackage GetDeletePolicy Debug PublishPackage DeletePackages UsageData</p> <p> User commands User commands for hosting</p>"},{"location":"user-commands-publish/#build-package","title":"Build package","text":"<pre><code>]TATIN.BuildPackage [source] [target]\n</code></pre> <p>Where <code>source</code> and <code>target</code> are paths to folders, write the contents of the former as a ZIP in the latter, bumping the build number unless the <code>version</code> option sets it.</p> <p>Folder <code>source</code> must contain a file <code>apl-package.json</code> defining the package.</p> <p>You can omit <code>source</code> and/or <code>target</code> if the source is a Cider project.</p> <p>The command asks you to confirm any assumptions.</p> bump= Either <code>patch</code> or <code>minor</code> or <code>major</code>: bump that part of the version number, together with any build number. Affects both the package and its config file. dependencies= Find dependencies in this subfolder of the project. (Rarely need to specify this: see Publishing Packages.) projectspace= Where the package contents are to be installed. version= Set the version number in both the package project and the package to be created. <p>Note that <code>bump=</code> and <code>version=</code> are mutually exclusive.</p> <p>Until version 0.118.0 <code>projectspace</code> was <code>tatinVars</code>.</p> <p>Until version 0.117.0 you could set the build number by including it in the version. Now the build number gets bumped in all cases.</p> <p> API: <code>BuildPackage</code></p>"},{"location":"user-commands-publish/#create-package","title":"Create package","text":"<pre><code>]TATIN.CreatePackage target\n</code></pre> <p>Where <code>target</code> is a path to a folder, create a new Tatin package in it.</p> <p>The command is a wrapper for <code>]TATIN.PackageConfig -edit</code>.</p>"},{"location":"user-commands-publish/#debug","title":"Debug","text":"<pre><code>]TATIN.Debug [toggle]\n</code></pre> <p>Where <code>toggle</code> is 0, 1, <code>on</code> or <code>off</code>, set Debug Mode on or off.</p> <p>If <code>toggle</code> is omitted, report current state.</p> <p>With Debug Mode on, Tatin leaves application errors untrapped so you can investigate them. (Error guards in dfns, errors when communicating via TCP/IP and similar errors are still trapped.)</p>"},{"location":"user-commands-publish/#delete-packages","title":"Delete packages","text":"<pre><code>]TATIN.DeletePackages pattern\n</code></pre> <p>Where <code>pattern</code> is</p> <ul> <li>a registry URL or alias, followed by a package ID</li> <li>a path to a folder containing a package (must contain a file <code>apl-package.json</code>) specified with the <code>file://</code> protocol</li> </ul> <p>delete one or more packages from the registry or folder, including deprecated packages.</p> <p>If the pattern matches multiple packages, ask which to delete.</p> <p>Example arguments:</p> <pre><code>https:/tatin.dev/grp-foo-1.0.0         \u235d registry URL, package ID\n[test-tatin]grp-foo-1.0.0              \u235d registry alias, package ID\n[test-tatin]foo-1.0.0                  \u235d no group name\n[test-tatin]foo-1                      \u235d versions of foo with major=1\n[test-tatin]foo                        \u235d versions of foo\nfile:///path/2/Registry/grp-foo-1.0.0  \u235d local package\n</code></pre> <p> API: <code>DeletePackages</code></p>"},{"location":"user-commands-publish/#deprecate-package","title":"Deprecate package","text":"<pre><code>]TATIN.DeprecatePackage pattern[majorversion] comment\n</code></pre> <p>Where</p> <ul> <li> <p><code>pattern</code> is a registry URL or alias followed by group and package names</p> </li> <li> <p><code>majorversion</code> (optional) is a major version number (omitted, defaults to all major versions)</p> </li> <li> <p><code>comment</code> is text explaining why the package is deprecated (remmeber to delimit with quotes)</p> </li> </ul> <p>asks to confirm the action, then create (for each major version targeted) a new minor version with the <code>deprecated</code> property set.</p> force Don\u2019t ask for confirmation. (Useful mainly for tests.) <p>Example: Deprecate on <code>[tatin]</code> all major versions of <code>grp-foo</code>: <pre><code>]TATIN.DeprecatePackages [tatin]grp-foo \"Use MarkAPL instead\"\n</code></pre></p> <p> API: <code>DeprecatePackage</code></p>"},{"location":"user-commands-publish/#get-delete-policy","title":"Get delete policy","text":"<pre><code>]TATIN.GetDeletePolicy [reg]\n</code></pre> <p>Where (optional) <code>reg</code> is</p> <ul> <li>a registry URL or alias</li> <li><code>*</code> (all known registries)</li> <li><code>?</code> (list them and ask me to choose)</li> </ul> <p>or if omitted, <code>[tatin]</code>, report the delete policy (<code>None</code>, <code>Any</code>, or <code>JustBetas</code>) of the server/s concerned and cache the result.</p> <p>Query a registry for its delete policy just once and then cache the result.</p> check Ignore the cache: query the server and cache the response. <p> API: <code>GetDeletePolicy</code></p>"},{"location":"user-commands-publish/#publish-package","title":"Publish package","text":"<pre><code>]TATIN.PublishPackage [source] [reg]\n</code></pre> <p>Where</p> <ul> <li><code>source</code> is a path to a package folder, or a ZIP file (typically created by BuildPackage)</li> <li><code>reg</code> is a registry alias or URL, or <code>?</code> (ask me which known registry)</li> </ul> <p>publish the package to the registry if specified, otherwise to <code>[tatin]</code>.</p> <p>If <code>source</code> is not specified, look for open Cider projects. If you find one, use it; if multiple, ask me which.</p> <p>If the registry\u2019s delete policy is <code>none</code>, ask me to confirm publication.</p> <p>The name of the resulting package is extracted from the ZIP file which therefore must conform to the Tatin rules.</p> dependencies= Find dependencies in this project subfolder. (Rarely need to specify: see Publish Packages.) <p> Publishing a user-command package  API: <code>PublishPackage</code></p>"},{"location":"user-commands-publish/#usage-data","title":"Usage data","text":"<pre><code>]TATIN.UsageData [reg] [ -download [-all] [-folder=] [-unzip] ]\n</code></pre> <p>Where <code>reg</code> is a registry URL or alias (if omitted, ask me which) list the usage files available.</p> all Select all available. download Ask me which usage files to download to a subfolder of my temp folder. folder= Download to this empty folder. unzip Unzip downloaded file/s and delete ZIPs. <p>Package downloads</p> <p>A package request might be one person taking a quick look, or several team members deploying the package in multiple projects, with all but the first request served from the Tatin client cache. No way to know.</p> <p>Tatin\u2019s test suite requests packages from both the Principal Registry and the Test server. These requests are flagged as part of a test and ignored when the usage data is compiled.</p> <p>Each month, Tatin saves its request log as a CSV file, compresses it, makes it available for download as <code>usage-data-&lt;YYYY&gt;-&lt;MM&gt;.csv</code>, and deletes the previous usage file. For example, in May 2022 it saved <code>usage-data-2022-04</code> and deleted <code>usage-data-2022-03.csv</code>.</p> <p>So the filename <code>usage-data-2022-04</code> holds requests from 2022-01-01 to 2022-04-30 inclusive.</p> <p>Each January, Tatin collects the data from last year and saves it in a file <code>usage-data-&lt;YYYY&gt;.csv</code>. It also deletes any files <code>usage-data-&lt;YYYY&gt;-&lt;MM&gt;</code>.</p> <p>For example, in January 2023 it created a file <code>usage-data-2022</code>, and deleted all files <code>usage-data-2022-*</code>.</p> <p> A Tatin server offers a page dedicated to the usage data. The page shows some of the data and provides links for downloading.</p> <p> There are no API functions available for retrieving usage data.</p>"},{"location":"user-commands/","title":"User commands","text":"<p>User commands put Tatin packages at your fingertips</p> <p>Cache LoadDependencies CheckForLaterVersion LoadPackages Documentation LoadTatin FindDependencies PackageConfig Init PackageDependencies InstallPackages Ping ListDeprecated ReInstallDependencies ListLicenses UnInstallPackages ListPackages UpdateTatin ListRegistries UserSettings ListTags Version ListVersions </p> <p>There are more user commands for publishing and hosting.</p> <p>User commands and their options are case-insensitive. They all have help built in, for example <pre><code>]tatin -?\n]tatin -??\n]TATIN.CopyRegistry -?\n</code></pre></p> <p>Square brackets in the command syntax</p> <p>Square brackets in the command syntaxes shown on this page indicate optional command arguments. For example, the <code>BuildPackage</code> command has syntax</p> <pre><code>]TATIN.BuildPackage [source] [target]\n</code></pre> <p>Above, both the <code>source</code> and the <code>target</code> arguments are optional.</p>"},{"location":"user-commands/#command-options","title":"Command options","text":"<p>Options are further optional arguments to the command.</p> <p>Specify all the command\u2019s arguments before any options. Prefix options with dashes, e.g.</p> <pre><code>]TATIN.BuildPackage path/to/package path/to/target -bump=minor\n</code></pre> <p>Options affect only the current command. They override settings in the user settings and leave them unchanged.</p> <p>Each command\u2019s options are tabulated below its definition.</p>"},{"location":"user-commands/#search-patterns","title":"Search patterns","text":"<p>Case-insensitive search patterns are used to find packages. (Optional elements are bracketed.)</p> <pre><code>[reg][/][alias@][grp-]name[-maj[.min[.patch]]]\n</code></pre> reg registry alias or URL alias local alias for the package (use only for installing packages or loading packages) name package name maj major version number min minor version number patch patch number <p>Registry scans</p> <p>When scanning registries, Tatin scans all registries listed in the user settings with a priority above 0.</p>"},{"location":"user-commands/#cache","title":"Cache","text":"<pre><code>]TATIN.Cache [reg]\n</code></pre> <p>Where (optional) <code>reg</code> is a registry alias or URL, list Tatin package cache contents (domain names and package names) for <code>reg</code> if specified, otherwise for all known registries.</p> clear List cached packages, ask for confirmation, then remove them. force With <code>clear</code>, skips confirmation. (Useful for tests.) path Return full package paths. <pre><code>      ]TATIN.cache '[tatin]'\n  --- Entries in cache for tatin.dev/:\n   aplteam-ADOC-7.1.2\n   aplteam-GitHubAPIv3-1.4.0\n   aplteam-CommTools-1.8.1\n   ...\n</code></pre> <p> API: <code>ClearCache</code>, <code>ListCache</code></p>"},{"location":"user-commands/#check-for-later-version","title":"Check for later version","text":"<pre><code>]TATIN.CheckForLaterVersion folder\n</code></pre> <p>Where <code>folder</code> is the path to a package folder (contains a <code>apl-buildlist.json</code> file), scan known registries and list later minor versions of principal packages. (List different major versions as different packages.)</p> <p>Prints a table with columns:</p> 1 currently installed package ID 2 package ID of the latest version found, or message, e.g. \"no response\" or \"not found\" 3 URL of the original source registry 4 <code>!</code> for a later version 5 URL of registry with a different (usually later) version; might be empty <p>Reports registries not scanned because their priority is 0.</p> dependencies Include dependencies major Include later major versions <p>To update to latest minor version use <code>]TATIN.ReInstallDependencies</code>. (New major versions need installing.)</p>"},{"location":"user-commands/#documentation","title":"Documentation","text":"<pre><code>]TATIN.Documentation\n</code></pre> <p>Open Tatin documentation in a browser window.</p>"},{"location":"user-commands/#find-dependencies","title":"Find dependencies","text":"<pre><code>]TATIN.FindDependencies pkgs [sources]\n</code></pre> <p>Where</p> <ul> <li><code>pkgs</code> is a comma-delimited list of package IDs (minor and patch numbers are ignored)</li> <li><code>sources</code> is a registry URL or alias (<code>[*]</code> for all known), or a path to a folder;     (optional: defaults to current folder)</li> </ul> <p>scan the source/s recursively for folders wih <code>apl-dependencies.txt</code> files and list results.</p> <pre><code>      ]TATIN.FindDependencies MarkAPL [*]\n  https://tatin.dev/\n                       aplteam-ADOC-7.0.0\n                       aplteam-ADOC-7.0.1\n                       aplteam-ADOC-7.1.0\n                       ...\n</code></pre> verbose Report the actual package folder(s) rather than the hosting folder. <p> API: <code>FindDependencies</code></p>"},{"location":"user-commands/#init","title":"Init","text":"<pre><code>]TATIN.Init [config]\n</code></pre> <p>Where (optional) <code>config</code> is a path to a folder containing a <code>tatin-client.json</code> file, (re)set my user settings in <code>\u2395SE</code>.</p> <p>If <code>config</code> is omitted, use the default user-settings file.</p> <p>Useful to apply in the session user settings that have changed on file.</p>"},{"location":"user-commands/#install-packages","title":"Install packages","text":"<pre><code>]TATIN.InstallPackages pkgs [target]\n</code></pre> <p>Where</p> <ul> <li> <p><code>pkgs</code> is a comma-separated list: each item identifies a package as one of</p> <ul> <li>a search pattern (optionally including a package alias)</li> <li><code>file://{path/to/folder}</code> or <code>file://{path/to/ZIP}</code></li> </ul> </li> </ul> <ul> <li> <p><code>target</code> (optional) is</p> <ul> <li>path to target folder</li> <li><code>[MyUCMDs]name</code> or <code>[MyUCMDs]</code> (case insensitive)</li> <li>a Cider project alias</li> </ul> </li> </ul> <p>create the target folder if necessary, and install there the package/s and any dependencies, registering any package aliases specified.</p> A local alias for a package allows you to use different versions of it in parallel. <p>Don't use this for other purposes.</p> <p>If <code>target</code> is <code>[MyUCMDs]</code> or <code>[MyUCMDs]name</code> install in <code>\u2395SE</code>. If <code>name</code> is omitted, use the package name, but signal an error if more than one user-command package is specified after <code>[MyUCMDs]</code>.</p> <p>If <code>target</code> is omitted, look for open Cider projects: if one is found, install in it; if multiple, ask me which.</p> <p>When installing into a Cider project, if its <code>dependencies</code> and <code>dependencies_dev</code> properties identify one folder, install there; if multiple, ask me which.</p> <p>If a search pattern does not specify a registry, scan known registries and use the first hit. (For dependencies, always scan.)</p> nobetas Ignore beta versions. Example arguments to InstallPackages <pre><code>[tatin]/group-name-1.0.0 /path       \u235d reg alias &amp; package ID with \"/\"\n[tatin]group-name-1.0.0 /path        \u235d reg alias &amp; package ID without \"/\"\n[tatin]group-name-1.0 /path          \u235d no patch no\n[tatin]group-name-1 /path            \u235d neither patch nor minor no.\n[tatin]group-name /path              \u235d no version information at all\n[tatin]name /path                    \u235d no group and no version information\n[tatin]A@name /path                  \u235d registry alias and package alias\ngroup-name-2.0.0 /path               \u235d just a full package ID\nname /path                           \u235d just a package name\nA@name /path                         \u235d just a package name with a pkg alias\nfile:///path/grp-name-1.0.0/ /path/  \u235d package in a local Registry\nfoo,bar /install/                    \u235d multiple packages\nfoo [MyUCMDs]                        \u235d install user command foo\nfoo [MyUCMDs]test                    \u235d install user command foo into test/\n</code></pre> <p> API: <code>InstallPackages</code></p>"},{"location":"user-commands/#list-deprecated","title":"List deprecated","text":"<pre><code>]TATIN.ListDeprecated [reg]\n</code></pre> <p>Where <code>reg</code> is a registry alias or URL list major versions of all deprecated packages. If <code>reg</code> omitted, use <code>[tatin]</code>.</p> all List all versions of all deprecated versions. <p> API: <code>ListDeprecated</code></p>"},{"location":"user-commands/#list-licenses","title":"List licenses","text":"<pre><code>]TATIN.ListLicenses [reg]\n</code></pre> <p>Where <code>reg</code> is a registry alias or URL, list the licences it accepts.</p> <p>If <code>reg</code> omitted, use <code>[tatin]</code>.</p> <pre><code>      ]TATIN.ListLicenses\n Unlicense  CC0  0BSD  EPL  MIT  BSL  ISC  Apache  BSD-2  BSD-3\n</code></pre> <p> API: <code>ListLicences</code></p>"},{"location":"user-commands/#list-packages","title":"List packages","text":"<pre><code>]TATIN.ListPackages [source]\n</code></pre> <p>Where <code>source</code> is</p> <ul> <li>a registry URL or alias</li> <li><code>[*]</code> for known registries (or <code>?</code> \u2013 ask me which)</li> <li>path to a registry</li> <li>path to an install folder</li> </ul> <p>list the packages there, aggregated by major version.</p> <p>If <code>source</code> is omitted, use <code>[tatin]</code>.</p> <p>If <code>source</code> is an install folder, ignore command options and show just package names, with a flag for principal packages.</p> group= list only packages in this group dependencies show all dependencies, assume <code>-noaggr</code> tags= (comma-separated list) list only packages so tagged uc list only packages that are user commands os= (comma-separated list of <code>lin</code>, <code>mac</code>, <code>win</code>) list only packages for these operating system/s since= (YYYYMMDD or YYYY-MM-DD) ignore packages published earlier (implies <code>-date</code> and assumes <code>-noaggr</code>) date show publishing date and assume <code>-noaggr</code> project_url show the URL noaggr don\u2019t aggregate <p>Both / or \\ work as path separators and trailing separators are optional.</p> <p> API: <code>ListPackages</code></p>"},{"location":"user-commands/#list-registries","title":"List registries","text":"<pre><code>]TATIN.ListRegistries\n</code></pre> <p>List alias, URL, ID, port, priority and no-caching flag of known registries in descending order of priority.</p> <p>If a registry does not respond, ask me: retry, skip, or cancel the command.</p> full Show API keys too. raw Show the raw data. <p>See also <code>]TATIN.UserSettings</code>.</p> <p> API: <code>ListRegistries</code></p>"},{"location":"user-commands/#list-tags","title":"List tags","text":"<pre><code>]TATIN.ListTags [source]\n</code></pre> <p>Where <code>source</code> (default <code>[tatin]</code>) is</p> <ul> <li>a registry alias or URL</li> <li><code>?</code> (ask me which)</li> </ul> <p>list alphabetically all tags used in all packages there.</p> tags= (comma-separated list) show only tags on packages that have all the listed tags os= (comma-separated list: <code>lin</code>, <code>mac</code> and <code>win</code>) show only tags on packages restricted to these operating systems <p> API: <code>ListTags</code></p>"},{"location":"user-commands/#list-versions","title":"List versions","text":"<pre><code>]TATIN.ListVersions pattern\n</code></pre> <p>Where <code>pattern</code> is a search pattern, list all versions of the package.</p> <p>If the registry is specified as <code>?</code> or <code>[?]</code>, ask me to choose one.</p> <p>If no registry is specified, show registry URLs.</p> <p>If version precedence is not clear from the version numbers (e.g. for beta versions) take publication dates into account.</p> date Show publication dates. <p> API: <code>ListVersions</code></p>"},{"location":"user-commands/#load-dependencies","title":"Load dependencies","text":"<pre><code>]TATIN.LoadDependencies [source] [ns]\n</code></pre> <p>Where</p> <ul> <li><code>source</code> is the source: a folder, into which one or more packages have been installed,     or <code>[MyUCMDs]</code> (case insensitive)</li> <li><code>ns</code> is the target namespace</li> </ul> <p>recursively search the source folder for packages listed in <code>apl-dependencies.txt</code> and load them into the target namespace unless already there.</p> <p>If <code>ns</code> is omitted, the target namespace is the current namespace \u2013 unless <code>source</code> is <code>[MyUCMDs]</code>, when it is <code>\u2395SE.</code></p> <p>If no arguments are specified, look for open Cider projects. If one is open, use it; if multiple, ask which. If the Cider project config defines multiple installation folders, ask which to use.</p> makeHomeRelative Instead of absolute paths, make <code>TatinVars.GetFullPath2AssetsFolder</code> and <code>TatinVars.HOME</code> return only the package folder and its parent. overwrite Overwrite existing packages in the target namespace. <p> API: <code>LoadDependencies</code></p>"},{"location":"user-commands/#load-packages","title":"Load packages","text":"<pre><code>]TATIN.LoadPackages pkgs [ns]\n</code></pre> <p>Where</p> <ul> <li> <p><code>pkgs</code> is a comma-separated list: each item identifies a package as one of</p> <ul> <li>a search pattern (optionally including a package alias)</li> <li><code>file://{path/to/folder}</code> or <code>file://{path/to/ZIP}</code></li> </ul> </li> <li> <p><code>ns</code> is the target namespace (defaults to the current namespace)</p> </li> </ul> <p>load the package/s and all dependencies into the target, register any aliases specified in <code>pkgs</code>, and show the number of packages loaded, including dependencies.</p> A local alias for a package allows you to use different versions of it in parallel. <p>Don't use this for other purposes.</p> <p>If a search pattern does not specify a registry, scan known registries and use the first hit. (For dependencies, always scan.)</p> nobetas Ignore beta versions. verbose Report details. <p>Example arguments to LoadPackages</p> <pre><code>group-name-2.0.0                \u235d just full package ID without Registry\n[tatin]group-name-1.0           \u235d alias &amp; package ID without patch no.\n[tatin]group-name-1             \u235d without patch and minor no.\n[tatin]group-name               \u235d with any version information\n[tatin]/group-name-1.0.0        \u235d with \"/\"\n[tatin]group-name-1.0.0         \u235d without \"/\"\n[tatin]name #                   \u235d with target namespace\n[tatin]A@name #                 \u235d with package alias\nname #                          \u235d no Registry and no group\nA@name                          \u235d no Registry and no group but alias\nA@name #.Foo.Goo                \u235d with target namespace\nfile:///path/group-name-1.0.0/  \u235d local Registry\nfoo,bar                         \u235d multiple packages\n[company]foo,[personal]bar      \u235d multiple packages from specific servers\n</code></pre> <p> API: <code>LoadPackages</code></p>"},{"location":"user-commands/#load-tatin","title":"Load Tatin","text":"<pre><code>]TATIN.LoadTatin\n</code></pre> <p>Load the Tatin client into <code>\u2395SE</code> (resulting in <code>\u2395SE.Tatin</code>), and initialize it. Write a user config file my home folder if none there.</p> <p>You can use <code>Init</code> to temporarily switch to a different config.</p> force Overwrite existing installation. permanent Make any changes permanent.  <p>Makes the Tatin API available.</p>"},{"location":"user-commands/#package-config","title":"Package config","text":"<pre><code>]TATIN.PackageConfig [source]\n</code></pre> <p>Where <code>source</code> is</p> <ul> <li>a search pattern including a registry alias or URL, ignore any command options, fetch and show the package config file</li> <li>a path to a package folder, show its config file <code>apl-package.json</code>, creating it if necessary</li> </ul> <p>If <code>source</code> is omitted,</p> <ol> <li>look for open Cider projects: if one is found, use it; if multiple, ask me which.</li> <li>look for a package config file in the current directory and confirm with me if found.</li> </ol> edit Let me edit the config (since version 0.104.0 Tatin updates the workspace with the new config). delete Delete the config. Example <pre><code>      ]TATIN.PackageConfig [tatin]MarkAPL\n{\n  api: \"API\",\n  assets: \"Files/\",\n  date: 20240926.1737,\n  description: \"Converts Markdown to HTML5\",\n  documentation: \"\",\n  files: \"\",\n  group: \"aplteam\",\n  io: 1,\n  license: \"MIT\",\n  lx: \"\",\n  maintainer: \"kai@aplteam.com\",\n  minimumAplVersion: \"18.0\",\n  ml: 1,\n  name: \"MarkAPL\",\n  os_lin: 1,\n  os_mac: 1,\n  os_win: 1,\n  project_url: \"https://github.com/aplteam/MarkAPL\",\n  source: \"APLSource/MarkAPL\",\n  tags: \"markdown,converter\",\n  userCommandScript: \"\",\n  version: \"13.1.0+341\",\n}\n</code></pre>"},{"location":"user-commands/#package-dependencies","title":"Package dependencies","text":"<pre><code>]TATIN.PackageDependencies [path]\n</code></pre> <p>Where <code>path</code> is the path to a folder containing a package, display the content of its <code>apl-dependencies.txt</code> file, creating one if necessary.</p> <p>If <code>path</code> is omitted, look for open Cider projects: if one is open, use it; if multiple, ask me which.</p> edit Let me edit the file. delete Delete the dependencies file. force Don\u2019t ask me for confirmations (useful for test cases)."},{"location":"user-commands/#ping","title":"Ping","text":"<pre><code>]TATIN.Ping [source]\n</code></pre> <p>Where <code>source</code> is</p> <ul> <li>a registry or registries, ping it/them and show me which respond;</li> <li>a folder, show whether it exists.</li> </ul> <p>Specify a registry as a registry URL or alias, or <code>?</code>.</p> <p>If <code>source</code> is</p> <ul> <li>omitted, ping all known registries</li> <li><code>?</code> ask me to choose registries</li> </ul> <pre><code>      ]TATIN.Ping\nQuestioning 2 Tatin Registries...\n https://tatin.dev/       1\n https://test.tatin.dev/  1\n      ]TATIN.Ping /Users/sjt/tmp/Foo/packages\nQuestioning 1 Tatin Registry...\n1\n</code></pre> Examples <pre><code>]TATIN.Ping\n]TATIN.Ping ?\n]TATIN.Ping [tatin]\n]TATIN.Ping https://tatin.dev\n]TATIN.Ping http://tatin.dev   \u235d This won't work\n</code></pre> <p> API: <code>Ping</code></p>"},{"location":"user-commands/#re-install-dependencies","title":"Re-install dependencies","text":"<pre><code>]TATIN.ReInstallDependencies [folder] [reg]\n</code></pre> <p>Where</p> <ul> <li><code>folder</code> is the path to a package folder</li> <li><code>reg</code> is a registry URL or alias</li> </ul> <p>remove from the folder all packages listed in <code>apl-dependencies.txt</code> (except ZIP files), compile a new build list, and use it to re/install the dependencies.</p> <p>ZIP files have priority and are not removed.</p> <p>If <code>folder</code> is a relative path, or unspecified,  look for a subfolder of an open Cider project: if one Cider project is open, use it; if multiple, ask me which. Either way, ask me to confirm the folder.</p> <p>If <code>reg</code> is not specified, scan known registries for the direct dependencies, but scan known registries anyway for further dependencies.</p> dry Show what the command would do, but don\u2019t do it. force Skip confirmations (useful for tests). nobetas Ignore beta versions. recursive Re-install dependencies in all child folders. update Install the latest version of each dependency. <p>The <code>recursive</code> option was introduced in version 0.118.0. With it you can re-install dependencies in all principal packages in (say) your UCMDs folder without prompts: <pre><code>]ReinstallDependencies [MyUCMDs] -recursive -update -force\n</code></pre></p> <p> API: <code>ReinstallDependencies</code></p>"},{"location":"user-commands/#uninstall-packages","title":"Uninstall packages","text":"<pre><code>1. ]TATIN.UnInstallPackages package folder\n2. ]TATIN.UnInstallPackages package\n3. ]TATIN.UnInstallPackages folder -cleanup\n4. ]TATIN.UnInstallPackages ?\n</code></pre> <p>Where</p> package <ul><li>fully qualified name of a package</li><li>alias and fully qualified name of a package</li><li>just a package alias (postfix with a <code>@</code> to mark it as alias)</li><li>package ID as group and name</li></ul> folder <ul><li>path to a folder with installed packages</li><li><code>[MyUCMDs]</code> (case independent)</li><li>a Cider alias in square brackets</li></ul> <p>uninstall, according to syntax,</p> <ol> <li><code>package</code> from <code>folder</code></li> <li><code>package</code> from the currently open Cider project (if several open, ask me which)</li> <li>from <code>folder</code> all superflous packages; i.e. neither top-level nor dependency; e.g. outdated versions</li> <li>the top-level packages I select from your prompt, and any dependencies thus superfluous</li> </ol> <p>If <code>folder</code> is a relative path, it must be a subfolder of an open Cider project.</p> cleanup See syntax (3) above. quiet Don\u2019t report progress. <p> API: <code>UninstallPackages</code></p>"},{"location":"user-commands/#update-tatin","title":"Update Tatin","text":"<pre><code>]TATIN.UpdateTatin\n</code></pre> <p>If a later version of Tatin is available, download it from GitHub, install it into the folder it was started from, and display the release notes in a browser window.</p> <p>Does not update the current workspace</p> <p>To use the updated version, close the current session and start a new one.</p> <p>In Dyalog 19.0 and later the command replaces the version installed in your home folder, not the shipped version, which remains unchanged.</p> <p>Debugging is the process of removing bugs from code, while programming is how you introduce them in the first place.</p> Troubleshooting <p>If the update fails, calling it again rarely helps.</p> Dyalog 19.0+Dyalog 18.2 <ol> <li><code>]DeActivate tatin</code> to remove Tatin</li> <li><code>]Activate tatin</code> restores the version your installation was shipped with</li> <li><code>]TATIN.UpdateTatin</code> to update to the latest version</li> </ol> <p>Uninstall Tatin then install it again.</p> Tatin versions before 0.105.0 <p>Versions before 0.105.0 might have been installed into one of these folders:</p> <pre><code>C:\\Users\\&lt;user&gt;\\Documents\\MyUCMDs\\     \u235d Windows\n/users/&lt;user&gt;/MyUCMDs/                 \u235d Mac-OS\n/home/&lt;user&gt;/MyUCMDs/                  \u235d Linux\n</code></pre> <p>If so, remove the folder <code>Tatin</code> from the <code>MyUCMDs/</code> folder and install Tatin (and, if installed, Cider) from scratch rather than updating it.</p> <p>If you loaded Tatin into <code>\u2395SE</code> with a script <code>setup.dyalog</code> you might need to amend it.</p>"},{"location":"user-commands/#user-settings","title":"User settings","text":"<pre><code>]TATIN.UserSettings\n</code></pre> <p>Print my user settings from the config file in JSON format, hiding the API key.</p> <p>To see current user settings rather than the file content, use the API.\"</p> edit Let me edit the file then ask me whether to refresh current settings. home Show path to the config file and do nothing else. refresh Refresh the current user settings from the config file. <p> API: <code>UserSettings</code></p>"},{"location":"user-commands/#version","title":"Version","text":"<pre><code>]TATIN.Version\n</code></pre> <p>Show the client\u2019s Tatin version.</p> <pre><code>]TATIN.Version reg\n</code></pre> <p>Where <code>reg</code> is a registry URL or alias (if <code>?</code> ask me which) show the Tatin version installed there.</p> <pre><code>]TATIN.Version -all\n]TATIN.Version *\n</code></pre> <p>Show the Tatin versions of the client and known registries.</p> <pre><code>]TATIN.Version -check\n</code></pre> <p>Show the installed and minimum required versions of the Principal Registry.</p> <p>Setting the <code>check</code> flag overrides all other arguments.</p> <p> API: <code>Version</code></p>"},{"location":"user-settings/","title":"User settings","text":"<p>Settings govern your use of Tatin</p> <p>Your Tatin user settings specify your \u2018known registries\u2019 \u2013 the Tatin registries you want to use \u2013 and some other settings you might use if you publish packages yourself.</p> <p>When you launch Dyalog<sup>1</sup>, it reads your Tatin user-settings file</p> <pre><code>tatin-client.json\n</code></pre> <p>into <code>\u2395SE.Tatin.MyUserSettings</code>, a class instance. If you don\u2019t have a Tatin user-settings file, Dyalog creates one in your home folder.</p> <p>The default user-settings file lists two registries:</p> <pre><code>      ]ListRegistries\n Alias       URL                     ...\n ----------  ----------------------- ...\n tatin       https://tatin.dev/      ...\n tatin-test  https://test.tatin.dev/ ...\n</code></pre>"},{"location":"user-settings/#edit-your-settings","title":"Edit your settings","text":"Edit your settings with the user command <p>You can use any editor to change your user-settings.</p> <p>On launching Dyalog, Tatin checks your user-settings file is valid JSON5 and signals any errors in it.</p> <p>If you use the user command <pre><code>]TATIN.UserSettings -edit\n</code></pre> to edit the file, Tatin will check the file when you save it.</p> <p>Other settings define the defaults used when you create a new package.</p> group group name your packages will use license license you usually use to publish a package maintainer email address of the maintainer of your packages source name of a folder in your package where all source files are stored <p>JSON5 allows comments.</p> <p>Editing your user-settings file leaves your current user settings unchanged. To update them from the file:</p> <pre><code>]TATIN.UserSettings -refresh\n</code></pre> <p>To save your current user settings to file:</p> <pre><code>\u2395SE.Tatin.MyUserSettings.Save 1\n</code></pre>"},{"location":"user-settings/#cache-settings","title":"Cache settings","text":"<p>To reduce network operations, Tatin caches all packages by default, except</p> <ul> <li>beta versions</li> <li>packages from registries with an <code>Any</code> delete policy</li> </ul> <p>Best delete policies for remote Tatin registries are <code>None</code> or <code>BetasOnly</code>.</p> <p>Properties of <code>\u2395SE.Tatin.MyUserSettings</code> control caching for all known registries.</p> caching flag whether caching is enabled path2cache string path to cache folder; defaults according to OS <p>The <code>noCaching</code> flags in <code>tatin-client.json</code> toggle caching for specific registries.</p> <p>Caching is most commonly disabled for local registries hosting packages being developed.</p> <p> <code>]TATIN.Cache</code></p>"},{"location":"user-settings/#keeping-settings-elsewhere","title":"Keeping settings elsewhere","text":"<p>For most purposes all you need is a single user-settings file in its default location.</p> <p>In some circumstances you might prefer to keep your user-settings file elsewhere:</p> <ul> <li>You need different settings for corporate and personal projects.</li> <li>You need to edit the settings but do not have write access to your home folder.</li> <li>Your computer is shared with others, at least one of whom needs write access to the settings.</li> </ul> <p>First, change the current user-settings location: <pre><code>      p\u2190,\u2282'/path2/user_config_file/'\n      \u2395SE._Tatin.Client.MyUserSettings\u2190\u2395SE._Tatin.Client.\u2395NEW \u2395SE.Tatin.UserSettings p\n      \u2374\u2395\u21901 \u2395se.Tatin.ListRegistries 0\ntatin      https://tatin.dev       ... 0 100 0\ntatin-test https://test.tatin.dev  ... 0   0 0\n2 7\n      \u2374\u2395\u2190\u2395se.Tatin.MyUserSettings.ListRegistries 0\n Alias  URL                  Port  Priority No caching Proxy API-key\n -----  ------------------   ----  -------- ---------- ----- -------\n tatin  https://tatin.dev/      0       100          0           ***\n test-tatin  https://tatin.dev/ 0       100          0           ***\n2 7\n</code></pre> Then make the new location the default: <pre><code>      \u2395SE.Tatin.MyUserSettings.MakeDefaultFile 1\n</code></pre></p> <code>id</code> <p>A unique key that can be used to identify a Registry definition in the user settings file when neither the URL nor an alias can be used for this.</p> <p>However, because mot of the time URL or alias are sufficient for this, setting <code>id</code> is optional.</p>"},{"location":"user-settings/#the-id","title":"The \"id\"","text":"<p>Because it must be possible to define more than one set for the same URL --- for different groups! --- in the user settings, the URL does not necessarily qualify as a unique key for a Registry. Neither does the alias, because it is optional, and you may reset it to \"undefined\".</p> <p>So we need a unique key for this (though admittedly not many will be in need for this). That's why you may set \"id\".</p> <p>This has only an impact locally in a scenario mentioned above, and that's why this is optional.</p> <ol> <li> <p>Tatin is initialized either explicitly or as a side effect when the first Tatin user command is issued.  \u21a9</p> </li> </ol>"},{"location":"original/_readme/","title":"Tatin Documentation Center","text":"<p>Explore Tatin's comprehensive documentation presented as a collection of HTML files. This guide offers an overview of each document's intent, the target audience, and which ones might be relevant based on your requirements and skill set.</p>"},{"location":"original/_readme/#general-information","title":"General Information","text":"<ul> <li>Introduction (draft)</li> </ul> <p>Essential for all users.</p> <ul> <li>Semantic Versioning (draft)</li> </ul> <p>Understand the importance of Semantic Versioning in Tatin.</p> <ul> <li>Tatin's Load and Update Strategy (draft)</li> </ul> <p>Discover how Tatin handles dependencies with varied package versions.</p> <ul> <li>Tatin User Settings (draft)</li> </ul> <p>Relevant if:</p> <ul> <li>you wish to change Tatin's default user settings location.</li> <li>you require multiple user settings files.</li> <li> <p>different users need distinct settings files.</p> </li> <li> <p>Syntax Reference (draft)</p> </li> </ul> <p>Comprehensive syntax guide for all API functions.</p> <ul> <li>Tatin and OneDrive (draft)</li> </ul> <p>Relevant if you are on Windows and you use OneDrive for your personal folders, in particular <code>Documents/</code>.</p>"},{"location":"original/_readme/#client-side","title":"Client Side","text":"<ul> <li>Installing and updating the Tatin Client (draft)</li> </ul> <p>If <code>]Tatin.</code> autocompletes in the Dyalog session, installation isn't required. However, updates might be beneficial.</p> <ul> <li>First Steps with Tatin (draft)</li> </ul> <p>An introductory guide for first-time package consumption.</p> <ul> <li>Package Configuration (draft)</li> </ul> <p>Delve into the details of package configuration files.</p> <ul> <li>Publishing Packages (draft)</li> </ul> <p>For those keen on publishing Tatin packages.</p> <ul> <li>Caching (draft)</li> </ul> <p>Understand the default caching behavior, its implications, and instances when you might want to modify it.</p> <ul> <li>GitHub (draft)</li> </ul> <p>Addresses GitHub-specific topics, primarily for contributors.</p>"},{"location":"original/_readme/#server-side","title":"Server Side","text":"<ul> <li>Installing the Tatin Server (draft)</li> </ul> <p>A guide for users interested in hosting a Tatin server.</p> <ul> <li>Server --- Tips and tricks (stub)</li> </ul> <p>Useful insights for optimal server performance.</p>"},{"location":"original/_readme/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Release Notes (draft)</li> </ul> <p>Highlights any necessary actions for seamless transitions between versions.</p> <ul> <li>Usage data (draft)</li> </ul> <p>For those curious about package download statistics.</p> <ul> <li>Tatin for Contributors (draft)</li> </ul> <p>A guide for potential contributors to Tatin's GitHub project.</p> <ul> <li>Run Dyalog behind Apache (draft)</li> </ul> <p>Instructions for integrating a Tatin server with an Apache server.</p>"},{"location":"original/caching/","title":"Caching in Tatin","text":""},{"location":"original/caching/#background","title":"Background","text":"<p>When a Tatin package and its dependencies are installed or loaded, it seems to be a good idea to save those packages in a machine-specific cache because obviously when the package is requested again, be it by the same user but for a different purpose or a different user, downloading should be avoided because it's already saved on the machine.</p> <p>And that's exactly what Tatin does by default, with two exceptions:</p> <ol> <li>Packages that are betas are never cached.</li> </ol> <p>The goal is to not clutter the cache with short-lived beta versions.</p> <ol> <li>In case a server operates an \"Any\" delete policy, no packages of that registry will be cached.</li> </ol> <p>Once a package got deleted it should not be available anymore, neither from the registry itself nor from the cache.</p> <p>Note that we advise operating a \"none\" or \"Betas-only\" policy on non-local Tatin servers.</p>"},{"location":"original/caching/#influencing-caching","title":"Influencing caching","text":"<p>Caching can be influenced by setting particular parameters in <code>\u2395SE.Tatin.MyUserSettings</code>, an instance of the <code>UserSettings</code> class, but also by setting particular parameters in the registries saved in the user settings.</p> <p>These parameters allow you to...</p> <ul> <li> <p>define the folder that hosts the cached packages</p> </li> <li> <p>toggle caching on a global level  </p> </li> <li> <p>disable caching for particular registries</p> </li> </ul> <p>Note that disabling caching in either way means that packages are neither written to nor read from the cache.</p>"},{"location":"original/caching/#parameters","title":"Parameters","text":""},{"location":"original/caching/#in-myusersettings","title":"In <code>MyUserSettings</code>","text":"<p>These parameters have global scope: they affect all registries.</p>"},{"location":"original/caching/#caching","title":"<code>caching</code>","text":"<p>This is a Boolean that defaults to 1. Settings this to 0 means no caching takes place: no reading from the cache, and no writing to the cache.</p>"},{"location":"original/caching/#path2cache","title":"<code>path2cache</code>","text":"<p>There is no default, meaning that the folder that hosts cached packages depends on the operating system.</p> <p>The function <code>GetPathToPackageCache</code> returns either the value of <code>MyUserSettings.path2cache</code> or the OS-specific default path if <code>path2cache</code> is empty.</p> <p>This property's main purpose is to allow test cases using a temp folder: the tests should not temper with the default cache.</p>"},{"location":"original/caching/#registries-saved-in-the-user-settings","title":"Registries saved in the user settings","text":"<p>Adding a registry to the user settings requires...</p> <ul> <li>creating an instance of the <code>Define Registry</code> class </li> <li>amended the properties of that instance</li> <li>add the instance with the <code>Add</code> method to <code>MyUserSettings</code></li> </ul> <p>One of the parameters of an instance of <code>DefineRegistry</code> is <code>noCaching</code>. This is a Boolean that defaults to 0, meaning that packages from that registry will be cached unless caching is switched off on a global level via <code>MyUserSettings.caching</code>.</p> <p>If it is 1 instead then packages from that registry will never be cached. </p> <p>This is typically used when you have a local Tatin Server running, and you are fiddling with packages managed by that server.</p>"},{"location":"original/caching/#the-user-command-cache","title":"The user command <code>Cache</code>","text":"<p>The user command <code>]Tatin.Cache</code> helps manage the cache. It can be used to list the contents of the cache as well as to clear the cache.</p> <p>Enter <code>]Tatin.Cache -??</code> for details.</p>"},{"location":"original/firststepswithtatin/","title":"First steps with the Tatin Client","text":"<p>Before you start reading this document you should have read the document Introduction.</p> <p>I&gt; Note that you should know what Semantic Versioning is all about.</p> <p>In this document, additional information, that you might or might not be interested in at this stage, is presented in boxes. You might well skip over them till later.</p>"},{"location":"original/firststepswithtatin/#where-we-start-from","title":"Where we start from","text":"<p>We assume that you have the Tatin client installed and ready for use. That means that this command gives you a list with all Tatin user commands available to you:</p> <pre><code>      ]tatin -?\n</code></pre>"},{"location":"original/firststepswithtatin/#what-registries-are-available","title":"What Registries are available","text":"<p>After a fresh installation you might wonder what Registries are available to you.</p> <pre><code>      ]tatin.ListRegistries\nAlias      URL                     Port Priority No caching Proxy API-key\n---------- ----------------------- ---- -------- ---------- ----- -------\ntatin      https://tatin.dev/         0      100          0           ***\ntest-tatin https://test.tatin.dev/    0        0          0           ***\n</code></pre> <p>At this point Tatin only knows about the principal Tatin Registry and the Tatin test Registry. If you wish to access other Registries on the Internet or your company's Intranet, or you want to host and publish packages locally (in all likelihood your own ones), then you must change the user settings. </p> <p>All these topics --- and related ones --- are discussed in a separate document: \"TatinUserSettings.html\". Here we try to keep things simple.</p>"},{"location":"original/firststepswithtatin/#looking-around","title":"Looking around","text":""},{"location":"original/firststepswithtatin/#listing-packages","title":"Listing packages","text":"<p>You may list all packages managed by Tatin's principal Registry with this command:</p> <pre><code>      ]tatin.ListPackages [tatin]\n Group &amp; Name             \u2262 Major versions\n -----------------------  ----------------\n aplteam-APLTreeUtils2                   1 \n aplteam-CodeCoverage                    2 \n aplteam-Compare                         1 \n aplteam-CompareSimple                   3 \n ...\n</code></pre> <p>The square brackets around \"tatin\" declare that string to be an alias. Without the square brackets Tatin would assume the argument to be either a local path or a URL like <code>https://localhost/my_tatin_server</code></p> <p>I&gt; Note that because <code>[tatin]</code> is the principal Tatin Registry you might well omit <code>[tatin]</code>: without an argument the command --- like some others --- would act on the principal Registry anyway.</p> <p>If you specify a <code>?</code> instead of <code>[tatin]</code> then Tatin will present a list with all known Registries to you for selecting the right one:</p> <pre><code>]listPackages ? \n--- Select Tatin Registry -----------------------------------------------------\n   1.  [local]               https://localhost/       \n   2.  [tatin]               https://tatin.dev/       \n   3.  [tatin-test]          https://test.tatin.dev/  \n\nSelect one item (q=quit) :\n</code></pre> <p>A&gt; ### Local and remote Registries A&gt; A&gt; The Tatin client can access packages that are managed by a Tatin Server, but also Registries that are locally available (read: not managed by a server).  A&gt; In order to address a local Registry you would just provide the path to it. A&gt; A&gt; Of course features like listing just the packages that carry a specific tag are only available when a Registry is managed by a Tatin server.</p>"},{"location":"original/firststepswithtatin/#searching-by-tags","title":"Searching by tag(s)","text":"<p><code>]tatin.ListPackages</code> will return a list with all packages available in the given Registry, aggregated by major version number. Now that can be a pretty long list. It might therefore be a good idea to tell something about what you are looking for in order to make the server shrink the list.</p> <ul> <li>If you happen to know the group name, you may specify <code>-group=whatever</code>: then only packages of the group \"whatever\" are listed</li> <li>Every package is tagged with keywords</li> </ul> <p>You may specify one or more tags, for example <code>-tag=smtp,email</code></p> <p>A&gt; ### Searching for tags: the strategy A&gt; A&gt; 1. First Tatin tries to find 100%-matches A&gt; 1. In case there is no match, Tatin tries to find it somewhere (<code>\u2377</code>) A&gt; 1. In case there is still no match a fuzzy search is performed A&gt;  A&gt; The fuzzy search would find \"installer\" when you enter \"intaller\" and \"datetime\" when you enter \"dadetime\". It has limits, but in practice it works quite well unless the tags are very short: typing \"AY\" when you meant \"AI\" would not work. A&gt; A&gt; Notes: A&gt; * The strategy outlined above is applied on each tag independently. A&gt; * Searching for multiple tags would mean that only packages would qualify that carry a hit for all of them. A&gt; * Searching for tags is an action that is carried out by a Tatin Server. That means that specifying <code>-tags=</code> makes sense only in HTTP requests: only then is there a server on the other side that can process the request. A&gt; * This feature's sole purpose is to overcome typos; it should not be used deliberately --- as a shortcut for example --- since the result may be incorrect.</p> <p>Let's assume you need a tool for converting Markdown into HTML, and that the package should run on all platforms.</p> <p>The user command <code>ListTags</code> takes one or more tags and returns a list of tags that were also found in the packages that carried the specified tags:</p> <pre><code>            ]Tatin.ListTags [tatin] -tags=marckdown\n converter\n help \n markdown  \n</code></pre> <p>Note that although we misspelled \"markdown\" as \"marckdown\" it was still identified correctly. </p> <p>We are now ready to identify that package by executing <code>ListPackages</code> with the <code>-tags</code> option:</p> <pre><code>           ]tatin.ListPackages [tatin] -tags=markdown\n Group &amp; Name     \u2262 major versions\n ---------------  ---------------- \n aplteam-MarkAPL                 1\n</code></pre> <p>Note that because packages which share the same group and name but have different major version numbers are considered different packages, the tally of the major version numbers is part of the list.</p> <p>I&gt; If you wonder why that is, then please read the document discussing Semantic Versioning.</p>"},{"location":"original/firststepswithtatin/#consuming-packages","title":"Consuming packages","text":""},{"location":"original/firststepswithtatin/#installing-packages","title":"Installing packages","text":"<p>Imagine you want to use the <code>MarkAPL</code> package in an application you are currently working on, which we will call a project. Let's also assume that this project is named \"Foo\" and lives in <code>/Foo/</code>.</p> <p>The first step is to install the package as part of the project \"Foo\":</p> <pre><code>      ]tatin.InstallPackages [tatin]/MarkAPL /Foo/packages\n</code></pre> <p>Notes:</p> <ul> <li><code>[tatin]</code> tells the Tatin client to load <code>MarkAPL</code> from the server the alias <code>tatin</code> is pointing to: https://tatin.dev</li> <li>The <code>/</code> between <code>[tatin]</code> and <code>MarkAPL</code> is optional</li> <li><code>MarkAPL</code> specifies neither a group nor a version number</li> <li>If the name <code>MarkAPL</code> is used within more than just one group the operation will fail</li> <li>Because no version information was provided at all, the very latest version will be installed</li> </ul>"},{"location":"original/firststepswithtatin/#what-got-installed","title":"What got installed?","text":"<p>Once you executed the above statement, the <code>packages/</code> sub directory carries these files:</p> <pre><code>apl-buildlist.json\napl-dependencies.txt\naplteam-APLTreeUtils2-1.1.1\naplteam-FilesAndDirs-5.0.1\naplteam-MarkAPL-11.0.1\naplteam-OS-3.0.1\n</code></pre> <p>Note that you might see different version numbers.</p> <ul> <li>The folder <code>aplteam-MarkAPL-11.0.1</code> contains the <code>MarkAPL</code> package</li> <li>The file <code>apl-dependencies.txt</code> contains just one line: <code>aplteam-MarkAPL-11.0.1</code></li> </ul> <p>That's because your project \"Foo\" depends so far on just one package, <code>MarkAPL</code></p> <ul> <li>The file <code>apl-buildlist.json</code> carries the build list</li> </ul>"},{"location":"original/firststepswithtatin/#the-build-list","title":"The build list","text":"<p>The build list will be used to get all required packages into the workspace. This is how the build list looks like so far:</p> <pre><code>{\n  packageID: [\n    \"aplteam-MarkAPL-11.0.1\",\n    \"aplteam-OS-3.0.1\",\n    \"aplteam-FilesAndDirs-5.0.1\",\n    \"aplteam-APLTreeUtils2-1.1.1\",\n  ],\n  principal: [\n    1,\n    0,\n    0,\n    0,\n  ],\n  url: [\n    \"https://tatin.dev/\",\n    \"https://tatin.dev/\",\n    \"https://tatin.dev/\",\n    \"https://tatin.dev/\",\n   ],\n}\n</code></pre> <p>Notes:</p> <ul> <li>There is one package that has <code>principal</code> set to 1: <code>MarkAPL</code>. That's because we have explicitly asked for it</li> <li>All other packages got installed because <code>MarkAPL</code> depends on them, either directly or indirectly</li> <li>The URL points to where the packages were loaded from</li> </ul>"},{"location":"original/firststepswithtatin/#how-does-a-package-look-like-on-disk","title":"How does a package look like on disk?","text":"<p>To answer this question we need to look into the directory <code>/Foo/packages/aplteam-MarkAPL-11.0.1</code>:</p> <pre><code>apl-dependencies.txt\napl-package.json\naplteam-MarkAPL-11.0.1/Files\nMarkAPL.aplc\n</code></pre> <p>Again <code>apl-dependencies.txt</code> lists all dependencies, this time all the packages <code>MarkAPL</code> depends on.</p> <p>The file <code>apl-package.json</code> describes the <code>MarkAPL</code> package:</p> <pre><code>{\n  api: \"MarkAPL\",\n  assets: \"Files\",\n  date: 20210725.153851,\n  description: \"Converts Markdown to HTML5\",\n  documentation: \"\",\n  group: \"aplteam\",\n  project_url: \"https://github.com/aplteam/MarkAPL\",\n  io: 1,\n  maintainer: \"kai@aplteam.com\",\n  minimumAplVersion: \"18.2\",\n  lx: \"\",\n  ml: 1,\n  name: \"MarkAPL\",\n  os_lin: 1,\n  os_mac: 1,\n  os_win: 1,\n  source: \"MarkAPL.aplc\",\n  tags: \"markdown,converter\",\n  uri: \"https://tatin.dev/\",\n  version: \"11.0.1+232\",\n}\n</code></pre> <p>Note that <code>MarkAPL</code> is a class. If you would leave <code>api</code> empty then when <code>MarkAPL</code> is loaded into <code>#</code> you would need to call the <code>Version</code> function with:</p> <pre><code>#.MarkAPL.MarkAPL.Version\n</code></pre> <p>By defining <code>MarkAPL</code> as the api this suffices:</p> <pre><code>#.MarkAPL.Version\n</code></pre> <p>The <code>api</code> parameter is discussed in detail in the \"PackageConfiguration\" document.</p>"},{"location":"original/firststepswithtatin/#files-assets","title":"Files assets","text":"<p>Note that the file <code>apl-package.json</code> specifies <code>assets: \"Files\"</code>. That means that there are assets, and that they can be found in the <code>Files/</code> sub directory.</p> <p>In case of <code>MarkAPL</code> these are a bunch of CSS and HTML files:</p> <pre><code>BlackOnWhite_print.css       \nBlackOnWhite_screen.css\nDark_screen.css\nDark_print.css\nLeanPubExtensions.html\nMarkAPL.html\nMarkAPL_CheatSheet.html\nMarkAPL_for_Programmers.html\nMarkAPL_print.css\nMarkAPL_screen.css\nQuickIntro.html\nStyles.html\n</code></pre> <p>Of course it could be anything required by the package.</p> <p>A&gt; ### Regarding Assets A&gt; A&gt; Note that assets are to be consumed, meaning that a package must not write to the assets folder.</p>"},{"location":"original/firststepswithtatin/#tatin-and-cider","title":"Tatin and Cider","text":"<p>If the project manager Cider is installed you may take advantage of it:</p> <p>If you are going to install packages into a project managed by Cider, then you may specify a Cider alias in order to identify the first part of the install path.</p> <ul> <li> <p>If the selected Cider project has only one Tatin folder defined in its config file, then that one is taken</p> </li> <li> <p>If there are multiple Tatin folders defined, the user is questioned which one she wants to install into</p> </li> </ul> <p>It is also possible to specify the package folder explicitly:</p> <pre><code>]Tatin.InstallPackages [tatin]&lt;pkg-name&gt; [&lt;cider-alias/]/my-path\n</code></pre>"},{"location":"original/firststepswithtatin/#getting-a-package-into-the-workspace","title":"Getting a package into the workspace","text":"<p>From the perspective of the application \"Foo\" all packages are dependencies. Therefore one must issue this command:</p> <pre><code>      ]tatin.LoadDependencies /Foo/packages #.Foo\n#._tatin.aplteam_MarkAPL_11_0_1 \n</code></pre> <p>I&gt; By default Tatin does no jabber when going about its business, but by specifying the <code>-verbose</code> flag you can change this: if specified you will see a number of messages printed to the session in order to keep you informed about the progress of loading the packages.  I&gt; I&gt; At the very least the command prints to the session the name of the namespace into which the package was actually loaded. </p> <p>We can use <code>MarkAPL</code> by referring to it as <code>#.Foo.MarkAPL</code> because Tatin has also established a reference in <code>#.Foo</code> named <code>MarkAPL</code> that points to the real package:</p> <pre><code>      #.Foo.MarkAPL\n#._tatin.aplteam_MarkAPL_11_0_1.MarkAPL\n</code></pre> <p>But how does <code>MarkAPL</code> find its assets? Tatin injects a namespace <code>TatinVars</code> into <code>#._tatin.aplteam_MarkAPL_11_0_1</code>, and that namespace carries several variables, among them these:</p> <ul> <li> <p><code>HOME</code> carries the path to the directory the package was installed into, even if the package has no assets. This is different from what happens when the package is brought into the workspace with <code>LoadPackages</code>, see there.</p> </li> <li> <p><code>ASSETS</code> holds the path to the assets relative to <code>HOME</code>.</p> </li> </ul> <p>If there are not assets then <code>ASSETS</code> is an empty vector.</p> <p>I&gt; Note that there is also a function <code>GetFullPath2AssetsFolder</code> available in <code>TatinVars</code>.</p> <pre><code>      #._tatin.aplteam_MarkAPL_11_0_1.TatinVars.HOME\n/Foo/packages/aplteam-APLTreeUtils2-1.1.1\n</code></pre> <p>That means that any <code>MarkAPL</code> function can refer to <code>HOME</code> with <code>##.TatinVars.HOME</code>.</p> <p><code>TatinVars</code> holds more potentially important data; details are discussed at Tatin Variables.</p> <p>What else lives in <code>#._tatin</code>?</p> <pre><code>      #._tatin.\u2395nl 9\naplteam_APLTreeUtils2_1_1_1\naplteam_FilesAndDirs_5_0_1 \naplteam_MarkAPL_11_0_1     \naplteam_OS_3_0_1           \n</code></pre> <p>All packages, whether principal ones or dependencies, are stored in <code>#._tatin</code>. For the principal packages a reference is injected into the target namespace, in our case <code>#.Foo</code>.</p> <p>Note that by naming convention packages are always loaded into either <code>#._tatin</code> or <code>\u2395SE._tatin</code>.</p>"},{"location":"original/firststepswithtatin/#installing-several-packages-at-once","title":"Installing several packages at once","text":"<p>Note that <code>InstallPackages</code> accepts several package IDs, separated by commas:</p> <pre><code>      ]tatin.InstallPackages Tester2,MarkAPL,Laguntza /Foo/packages\n</code></pre> <p>This will load three packages and all their dependencies at once. You might find this significantly faster than installing them one-by-one.</p> <p>!&gt; ### Using an alias for a package =&gt; It is possible to use an alias for a package. Check this example: =&gt; <code>=&gt; ]tatin.InstallPackages F@FilesAndDirs =&gt;</code> =&gt; This creates a ref <code>F</code> for FilesAndDirs. However, the purpose of such aliases is not to allow you to create =&gt; a kind of shortcut for the package in question, this allows you to load to different versions of a package, =&gt; something that is sometimes required due to specific requirements.  =&gt;  =&gt; All you need to do is to assign different aliases to the different versions of the package.</p>"},{"location":"original/firststepswithtatin/#checking-out-a-package-loadpackages","title":"Checking out a package: <code>LoadPackages</code>","text":"<p>Let's assume that before actually installing it, you first  want to check whether the package <code>MarkAPL</code> suits your needs. In this case you might not want to install it (yet) but just to load it into the workspace. </p> <p>That can be achieved with the <code>LoadPackages</code> user command. It loads the package into the workspace.</p> <p>Notes:</p> <ul> <li> <p>Loading a package in this way has one major purpose: to investigate it.</p> </li> <li> <p>Loading a package might well be different from installing a package: when loading a package the precise versions of dependency packages will be loaded, but when a package is installed that is not necessarily the case. </p> </li> </ul> <p>This is discussed in the paper <code>TatinsLoadAndUpdateStrategy.html</code></p> <p>Let's load the <code>MarkAPL</code> package into the workspace; for that we need to specify a URL and optionally a target namespace:</p> <pre><code>      ]tatin.LoadPackages [tatin]MarkAPL -verbose\n  Attempting to install https://tatin.dev/aplteam-MarkAPL-10.0.0...\n  Establish dependencies...\n  4 dependencies identified\n  Fetching https://tatin.dev/aplteam-MarkAPL-10.0.0...\n  Unzipping C:\\Users\\username\\AppData\\Local\\Temp\\...\n  Add aplteam-MarkAPL-10.0.0 to dependency file...\n  Fetching https://tatin.dev/aplteam-APLTreeUtils2-1.1.0...\n  ...\n</code></pre> <p>I&gt; Without <code>-verbose</code> the command is taciturn: I&gt; <code>I&gt; ]tatin.LoadPackages [tatin]MarkAPL I&gt; 4 packages (including dependencies) loaded I&gt;</code></p> <p>Here we did not specify a target namespace, so the package was loaded into <code>#</code>. In case the target namespace is something like <code>#.MyTests</code> then it may or may not exist. If it does not, Tatin will create it.</p> <p>Tatin has created a reference named <code>MarkAPL</code> in the target namespace <code>#</code>:</p> <pre><code>      #.\u2395nl \u237316\nMarkAPL\n_tatin \n</code></pre> <p>That reference points to the namespace that holds the package as such, which is loaded into <code>_tatin</code>: this is the namespace Tatin uses to manage all packages.</p> <p>I&gt; The name <code>_tatin</code> is hard-coded and cannot be changed.</p> <p>The name of the namespace carries the version number:</p> <p><pre><code>      #.MarkAPL\n#._tatin.aplteam_MarkAPL_10_0_0 \n</code></pre> <code>_tatin</code> also contains all the packages <code>MarkAPL</code> depends on:</p> <pre><code>      #._tatin.\u2395nl \u237316\naplteam_APLTreeUtils2_1_1_0\naplteam_FilesAndDirs_5_0_0\naplteam_MarkAPL_10_0_0\naplteam_OS_3_0_0          \n</code></pre> <p>No matter whether the APL code of a package is a single function (or operator) or a bunch of functions and operators or a single namespace (ordinary or scripted) or a bunch of namespaces or a single class or a bunch of classes or a mixture of all these APL objects, they are going to live in the top namespace of a package.</p> <p>But Tatin will also inject references into that namespace pointing to the dependencies, therefore:</p> <pre><code>      #._tatin.aplteam_MarkAPL_11_0_0.\u2395nl\u237316\nAPLTreeUtils2\nFilesAndDirs \nMarkAPL      \n</code></pre> <p><code>MarkAPL</code> is the package we asked for. It depends on two packages, <code>APLTreeUtils2</code> and <code>FilesAndDirs</code>. For these two packages references are injected. <code>FilesAndDirs</code> depends on <code>OS</code> but because that is not required by <code>MarkAPL</code>, no reference to <code>OS</code> is injected into <code>aplteam_MarkAPL_11_0_0.</code>, but you would find such a reference in <code>#._tatin.aplteam_FilesAndDirs_5_0_1</code>.</p>"},{"location":"original/firststepswithtatin/#misc","title":"Misc","text":""},{"location":"original/firststepswithtatin/#scanning-registries","title":"Scanning Registries","text":"<p>The fact that Tatin scans Registries in order to find a package can be put to good use when developing packages: you can run your own Tatin server on, say, your own machine, and give it the highest priority. You can then publish new versions of a package on that server first. </p> <p>That way Tatin would find the package on your local machine even when they are not loaded as principal packages but just as dependencies.</p> <p>Later, when the package is ready, you could publish it to, say, the principal Tatin server on <code>https://tatin.dev</code>, and --- don't forget that step! --- delete it from your local Registry.</p> <p>A&gt; ### Having the same package in more than one Registry A&gt; A&gt; In case you juggle with the same package in several Registries you might well be interested in getting a full list. A&gt; The <code>]ListPackages</code> user command has a syntax for this: A&gt; A&gt; <code>A&gt;       ]ListVersions [*]example-versions  A&gt;</code> A&gt; A&gt; This would check all known Registries with a priority greater than 0 for <code>example-versions</code>, and list all hits.</p> <p>The fact that Registries with a priority of <code>0</code> are not scanned by Tatin allows you to include a Registry like <code>https://test.tatin.dev</code> in your user settings. You don't really want that Registry to participate in a scan, but that way you can still execute commands like <code>]tatin.ListPackages</code> etc. on it.</p> <p>A&gt; ### Scanning for dependencies A&gt; A&gt; Note that Tatin does not only scan all known Registries with a priority greater than zero for principal packages, it also scans all those Registries for dependencies as well. </p>"},{"location":"original/firststepswithtatin/#deprecated-packages","title":"Deprecated packages","text":"<p>Every piece of software will become obsolete one day. Packages are no exception. If a package is not needed anymore, or is obsolete because there is a better one available, it's time to mark it as deprecated.</p> <p>This can be done with the user command <code>]Tatin.DeprecatePackage</code>. In short what the user command does is to publish the latest version available yet as a new version with an increased minor version number and an injected flag <code>deprecated\u21901</code></p> <p>A&gt; ### Deleting versus deprecating packages A&gt; A&gt; Depending on the delete policy operated on a server you might as well delete all obsolete packages, but we discourage you from doing so. A&gt; A&gt; The reason is that one of Tatin's design goals was to make a build 100% reproducible. This is only achievable if packages are not deleted from a server. That's the reason why the principal Tatin Registry operates a non-delete policy.</p> <p>For example, let's assume these three packages are published:</p> <pre><code>aplteam-Foo-1.0.0\naplteam-Foo-1.1.0\naplteam-Foo-1.1.1\n</code></pre> <p>Executing:</p> <pre><code>]Tatin.DeprecatePackage https://your-Registry/aplteam-Foo-1\n</code></pre> <p>will publish a new version <code>aplteam-Foo-1.2.0</code> which is almost identical with version 1.1.1 except that it has two additional properties in its config file: <code>deprecated</code> with the value 1 and <code>deprecate_comment</code> which carries the comment in case you've specified one with <code>-comment=</code>; this should be used to explain why a package got marked as deprecated, so it will be something along the lines of \"See package Foo-Boo\".</p> <p>From now on both the \"Packages\" web page and <code>]Tatin.ListPackages</code> won't list these four packages anymore.</p> <p>Note that <code>]Tatin.ListDeprecated</code> is designed to list just the deprecated packages. If you want the list to include also the earlier versions --- which are now sort of hidden by 1.2.0 --- then you need to specify the <code>-all</code> flag. </p> <p>With <code>-all</code> a matrix with two columns rather than one is returned, with the second column carrying an asterisk for those packages that actually  do carry <code>deprecated\u21901</code> in their config file. That would be at least the very last one.</p>"},{"location":"original/firststepswithtatin/#side-effects-of-deprecating-a-package","title":"Side effects of deprecating a package","text":"<p>If you try to load or install a package that is marked as deprecated then you will be asked whether you really want that, but if you insist then you will get what you asked for.</p> <p>Note however that this is only true when you ask explicitly for the last package (the one with <code>deprecated\u21901</code>).</p> <p>In our example that would be:</p> <pre><code>]Tatin.LoadPackages https://your-registry/aplteam-Foo-1\n</code></pre> <p>This statement:</p> <pre><code>]Tatin.LoadPackages https://your-registry/aplteam-Foo\n</code></pre> <p>would yield the same result, but only because there is just one major version anyway.</p> <p>If you ask explicitly for an earlier version than the deprecated one,  then that version would be loaded (or installed) without further ado, because Tatin would just assume that you know what you are doing.</p> <p>Note that the API functions for loading / installing packages would not complain or warn you at all. </p> <p>A&gt; ### Mistakenly deprecated a package? A&gt; A&gt; There is an easy escape route: just publish the package again with an increased minor version number but <code>deprecated</code> either set to 0 or removed from the config file, and the package is back on track.  A&gt; A&gt; If <code>deprecate_comment</code> was not empty then that should be removed or emptied. A&gt;  A&gt; Once you've done that the very latest published package would no longer carry a \"deprecated\" flag with the value 1, and therefore it would no longer fulfil the criteria of a deprecated package.</p>"},{"location":"original/firststepswithtatin/#tatin-variables","title":"Tatin Variables","text":"<p>For every package Tatin will establish a couple of constants. Because APL has no concept of constants, they are emulated via niladic functions.</p> <p>They are injected into a namespace <code>TatinVars</code> which in turn is injected into the top package namespace.</p> <p>W&gt; Of course this means that theoretically there could be a name clash, but then the name <code>TatinVars</code> should certainly not be used by any package author.</p> <p>Strictly speaking <code>TatinVars</code> is a misnomer because the namespace carries just functions, and not a single variable, but all but one of those act as constants, and the exception <code>GetFullPath2-AssetsFolder</code> was introduced at a later stage, so it was decided to stick with the name <code>TatinVars</code> for compatability.</p> <p>Note that we refer to, say, <code>HOME</code> as a character vector because the niladic function <code>HOME</code> returns a character vector.</p>"},{"location":"original/firststepswithtatin/#assets","title":"ASSETS","text":"<p>The path to the package's assets relative to <code>HOME</code>. Is empty in case there are no assets.</p> <p>See also the GetFullPath2AssetsFolder function.</p>"},{"location":"original/firststepswithtatin/#config","title":"CONFIG","text":"<p>This is a simple character vector that stems from the file <code>apl-package.json</code> of the given package.</p>"},{"location":"original/firststepswithtatin/#dependencies","title":"DEPENDENCIES","text":"<p>A vector of character vectors with the package IDs of the packages the package in question depends on.</p>"},{"location":"original/firststepswithtatin/#getfullpath2assetsfolder","title":"GetFullPath2AssetsFolder","text":"<p>This is a function which returns the result of the expression <code>HOME,'/',ASSETS</code> if both <code>HOME</code> and <code>ASSETS</code> are not empty and <code>HOME</code> exists on disk. If <code>HOME</code> is empty or does not exist on disk then just <code>ASSETS</code> is returned. </p> <p>When accessing assets you are advised to always use the <code>GetFullPath2AssetsFolder</code> function. Why? Imagine the following scenario as an example: you've loaded packages into a clear workspace, set <code>\u2395WSID</code> and then saved that WS. Later you make sure that the assets folder of the package becomes a sibling of the workspace. You might than move the WS with the assets folder elsewhere, even to a different machine. The expression <code>HOME,'/',ASSETS</code> would then fail.</p> <p>But the function <code>GetFullPath2AssetsFolder</code> would not find <code>HOME</code> and therefore return just <code>ASSETS</code>, and that allows you to still access the assets sucessfully, assuming that you changed the current directory to where the workspace was loaded from.</p>"},{"location":"original/firststepswithtatin/#home","title":"HOME","text":"<p>Is a character vector holding the path of a folder that hosts the package. </p> <p>There is an exception: when the package was brought into the workspace with <code>LoadPackages</code> rather than <code>LoadDependencies</code> that has no assets. This is because without assets <code>LoadPackages</code> loads the package into a temp folder, brings the package into the WS and then deletes the temp folder, because without assets there is no need to leave a footprint behind.</p> <p>In this case <code>HOME</code> returns an empty vector.</p>"},{"location":"original/firststepswithtatin/#id","title":"ID","text":"<p>The full package name. This will include a build ID if there is any, so it is not necessarily identical with the package ID.</p>"},{"location":"original/firststepswithtatin/#lx","title":"LX","text":"<p>In a package config file a function can be defined on the <code>lx</code> parameter. Such a function would be executed after the package was loaded. The purpose of the function is to perform some sort of initialisation.</p> <p>If such a function returns a result then it is assigned to <code>LX</code> in the <code>TatinVars</code> namespace.</p> <p>Note that <code>LX</code> does not exist in case no such function is defined, or the function did not return a result.</p>"},{"location":"original/firststepswithtatin/#uri","title":"URI","text":"<p>Character vector that holds the address of a Tatin server the package was loaded from, or the full name of a ZIP file.</p>"},{"location":"original/github/","title":"Tatin &amp; GitHub","text":""},{"location":"original/github/#overview","title":"Overview","text":"<p>Tatin is version controlled by Git and hosted on GitHub.</p> <p>There is no limit for accessing GitHub with a browser, but there are limits for what you can do when accessing GitHub via the API.</p>"},{"location":"original/github/#githubs-limit-policy","title":"GitHub's limit policy","text":"<p>GitHub has a fairly complex limit policy, which means that above a certain threshold further requests will be rejected for a period of time, typically one hour.</p> <p>It is very unlikely that you will hit this limit if you are an ordinary Tatin user, because with a Tatin client, the only command that accesses GitHub via the API is <code>]TATIN.UpdateTatin</code>. With a Tatin server, it does not matter at all.</p> <p>However, there might be circumstances where you hit this anyway because other parts of your workflow also access GitHub. In this case you can overcome the limitation by specifying a GitHub personal access token.</p> <p>You can save the personal access token in the Tatin client folder in a file named <code>GitHub-personal-token.txt</code>, and the problem is solved. To be precise, there are still restrictions, but they are so relaxed that they will only affect the bad guys.</p>"},{"location":"original/installingandupdatingthetatinclient/","title":"Installing and Updating the Tatin Client","text":""},{"location":"original/installingandupdatingthetatinclient/#introduction","title":"Introduction","text":"<p>You don't need to worry about installing Tatin if you use version 19.0 of Dyalog: In 19.0 Tatin just needs to be activated with the <code>]activate</code> user command.</p> <p>In 18.2 you need to install Tatin yourself.</p>"},{"location":"original/installingandupdatingthetatinclient/#requirements","title":"Requirements","text":"<ul> <li> <p>Tatin needs a Unicode version of Dyalog</p> </li> <li> <p>Dyalog version 18.2 or better</p> </li> <li> <p>Link version 3.0.8 or better</p> </li> </ul> <p>Note that when you call <code>]Tatin.Init</code>, Tatin will check whether those requirements are met.</p>"},{"location":"original/installingandupdatingthetatinclient/#installing-tatin","title":"Installing Tatin","text":""},{"location":"original/installingandupdatingthetatinclient/#190","title":"19.0","text":"<p>Strictly speaking it is not necessary to install Tatin for 19.0, because Tatin is part of a 19.0-installation. However, before it can be used it must be activated. That's because in 19.0 it is still experimental.</p> <p>Note that activating is available in 19.0 only. Activating is not supported in 18.2.</p> <p>In order to activate Tatin, execute</p> <pre><code>]Activate -??\n</code></pre> <p>and follow the instructions.</p>"},{"location":"original/installingandupdatingthetatinclient/#activating-deactivating-resetting-updating","title":"Activating, deactivating, resetting, updating","text":""},{"location":"original/installingandupdatingthetatinclient/#activating","title":"Activating","text":"<p>Activating means to copy Tatin (and possibly Cider) from the Dyalog installation directory's sub folder <code>Experimental\\CiderTatin\\</code> to either a version specific folder (the default) or a version agnostic folder in your home directory, and to instruct the user command framework to scan the chosen directory for user commands.</p> <p>Which folder that is exactly depends on the operating system:</p> <pre><code>\u235d\u235d\u235d Version specific\n\n\u235d Windows\n&lt;HOME&gt;\\Documents\\Dyalog APL-64 19.0 Unicode Files\n\n\u235d Others\n&lt;HOME&gt;/dyalog.190U64.files\n\n\u235d\u235d\u235d Version agnostic\n\n\u235d Windows\n&lt;HOME&gt;\\Documents\\Dyalog APL Files\n\n\u235d Others\n&lt;HOME&gt;/dyalog.files\n</code></pre>"},{"location":"original/installingandupdatingthetatinclient/#deactivating","title":"Deactivating","text":"<p>Deactivating means to remove Tatin (and possibly Cider) from that folder. It has its own user command:</p> <pre><code>]Deactivate [all|cider|tatin] [-versionagnostic]\n</code></pre>"},{"location":"original/installingandupdatingthetatinclient/#resetting","title":"Resetting","text":"<p>Resetting means to replace the current version by the one the installation originally came with.</p> <p>This can be useful when you have updated Tatin with <code>]UpdateTatin</code> and then find the new version to be buggy.</p>"},{"location":"original/installingandupdatingthetatinclient/#updating","title":"Updating","text":"<p>Updating means that the version that is currently available is updated to the latest version available from GitHub.</p> <p>This can be achieved with the user command <code>]UpdateTatin</code>.</p>"},{"location":"original/installingandupdatingthetatinclient/#182","title":"18.2","text":"<p>Instructions:</p> <ol> <li> <p>Download the latest release of the Tatin client from https://github.com/aplteam/Tatin/releases</p> </li> <li> <p>Unzipping the file will produce a subdirectory named <code>Tatin/</code> that you should then place in the appropriate installation folder discussed in a second</p> </li> </ol>"},{"location":"original/installingandupdatingthetatinclient/#what-is-the-correct-installation-folder","title":"What is the correct installation folder?","text":"<p>Tatin must be installed into one of these folders dependening on your OS:</p> <p>Windows: <pre><code>C:\\Users\\&lt;\u2395AN&gt;\\Documents\\Dyalog APL[-64] &lt;version&gt; Unicode Files\\SessionExtensions\\CiderTatin\n</code></pre></p> <p>Linux: <pre><code>/home/&lt;\u2395AN&gt;/dyalog.&lt;version&gt;U&lt;bit&gt;.files/SessionExtensions/CiderTatin\n</code></pre></p> <p>Mac OS: <pre><code>/Users/&lt;\u2395AN&gt;/dyalog.&lt;version&gt;U&lt;bit&gt;.files/SessionExtensions/CiderTatin\n</code></pre> However, these folders are version specific. Instead you might consider installing them into a version agnostic folder in order to make Tatin available to several versions of Dyalog at the same time.</p> <p>For that install into one of these folders: <pre><code>\u235d Windows\nC:\\Users\\&lt;\u2395AN&gt;\\Documents\\Dyalog APL Files\\SessionExtensions\\CiderTatin\n\n\u235d Linux\n/home/&lt;\u2395AN&gt;/dyalog.files/SessionExtensions/CiderTatin\n\n\u235d Mac OS\n/Users/&lt;\u2395AN&gt;/dyalog.files/SessionExtensions/CiderTatin\n</code></pre></p> <p>As a result you should see something like this:</p> <pre><code>\u235d Windows\n...\\Dyalog APL[-64] &lt;version&gt; Unicode Files\\SessionExtensions\\CiderTatin\\Tatin\n\n\u235d Linux &amp; Mac OS\n.../dyalog.&lt;version&gt;&lt;bit&gt;.files/SessionExtensions/CiderTatin/Tatin\n</code></pre>"},{"location":"original/installingandupdatingthetatinclient/#tell-dyalog-where-to-look-for-user-commands","title":"Tell Dyalog where to look for user commands","text":"<p>Though Tatin's user command script etc. is now in place, Dyalog does not know about it yet. To achieve that we have to add the folder to SALT's search path. This step needs to be carried out only once for version 18.2</p> <p>Execute one of the following commands:</p> <p>!&gt; ### Windows  <pre><code>]SALT.Settings cmddir \",C:\\Users\\&lt;\u2395AN&gt;\\Documents\\Dyalog APL-64 18.2 Unicode Files\\SessionExtensions\\CiderTatin\" -p\n\n!&gt; ### Linux\n</code></pre> ]SALT.Settings cmddir \",/home/&lt;\u2395AN&gt;/dyalog.182U64.files/SessionExtensions/CiderTatin -p</p> <p>!&gt; ###  Mac OS <pre><code>]SALT.Settings cmddir \",/Users/&lt;\u2395AN&gt;/dyalog.182U64.files/SessionExtensions/CiderTatin\" -p\n</code></pre></p> <p>Notes: </p> <ul> <li>Note the comma (<code>,</code>) in front of the path: it tells SALT to add the path, rather than using it as a replacement</li> <li>The <code>-p</code> stands for \"permanent\"; this makes sure your addition to the search path is permanent</li> <li>In case you installed Tatin into a version-agnostic folder you must specify that folder of course</li> </ul> <p>Any newly started instance of Dyalog now comes with the user command <code>]Tatin.*</code>.</p> <p>There is no point in having a function <code>Run.aplf</code> in place with 8.2: only in 19.0 did Dyalog add the feature that a function <code>Run.aplf</code> will be loaded and executed as part of Dyalog's bootstrapping procedure; in earlier versions such a function is not executed.</p> <p>As a side effect of executing any of the Tatin user commands the Tatin API will become available via <code>\u2395SE.Tatin</code>.</p> <p>If you want the Tatin API to be available right from the start: this is discussed soon.</p>"},{"location":"original/installingandupdatingthetatinclient/#initializing-tatin","title":"Initializing Tatin","text":"<p>Once installed, any suitable version of Dyalog will provide a list of the Tatin user commands once you enter:</p> <pre><code>      ]tatin -?\n</code></pre> <p>The script <code>Tatin.dyalog</code> is the interface between the Dyalog user command framework and the Tatin API.</p> <p>When any of the Tatin user commands is executed, it will check whether the API is already loaded --- that will be the case in 19.0 once Tatin is activated. If it's not available yet (18.2), it will be loaded.</p>"},{"location":"original/installingandupdatingthetatinclient/#on-setupdyalog-182","title":"On <code>setup.dyalog</code> (18.2)","text":"<p>I&gt; This is 18.2 only because in later versions of Dyalog, Tatin's API will be available in <code>\u2395SE</code> right from the start anyway. I&gt;  I&gt; You might want the Tatin API to be available right from the start in earlier versions of Dyalog as well, so that you can invoke any of the Tatin API functions without first executing a Tatin user command.  I&gt;  I&gt; What is the application for this? Well, you might want to have an automated build process available, for example. I&gt; I&gt; If you are not interested in this: skip it and carry on with Updating Tatin.</p> <p>The way to achieve this goal requires the introduction or modification of a file <code>setup.dyalog</code> in your <code>MyUCMDs/</code> folder. </p> <p>Where to find the <code>MyUCMDs/</code> folder depends on your operating system:</p> <ul> <li>On Windows it's usually <code>C:\\Users\\{username}\\Documents\\</code></li> <li>On Linux (including the PI) it is <code>/home/{username}/</code></li> <li>On Mac OS it is <code>/Users/{username}/</code></li> </ul> <p>Note that only on Windows is the folder created as part of the installation routine. On other platforms you must create the folder yourself.</p>"},{"location":"original/installingandupdatingthetatinclient/#how-does-setupdyalog-work","title":"How does <code>setup.dyalog</code> work?","text":"<p>Whenever an instance of Dyalog is fired up, it checks whether such a script exists. If that is the case it checks whether there is a function <code>Setup</code> in the script. </p> <p>If there is such a function then it is expected to be monadic; it will be executed automatically as part of the instantiating process of Dyalog APL.</p> <p>This can be used for many things like...</p> <ul> <li>making changes to the session</li> <li>specifying function keys </li> <li>loading stuff into <code>\u2395SE</code></li> </ul> <p>In version 19.0 the <code>Run.aplf</code> function offers a better way to achieve that, rendering <code>setup.dyalog</code> superfluous.</p>"},{"location":"original/installingandupdatingthetatinclient/#there-is-no-such-script-yet","title":"There is no such script yet","text":"<p>Create one that looks like this:</p> <pre><code>:Namespace SetItUp\n\n    \u2207 {r}\u2190Setup arg;\u2395IO;\u2395ML;dmx\n      r\u2190\u236c\n      \u2395IO\u21901 \u22c4 \u2395ML\u21901\n      :If ~IfAtLeastVersion 19\n      :AndIf 0=\u2262\u2395\u2190AutoloadTatin \u2395SE.SALTUtils.DEBUG\n          {}\u2395SE.SALTUtils.ResetUCMDcache -1\n      :EndIf\n    \u2207\n\n    \u2207 r\u2190AutoloadTatin debug;wspath;path2Config\n      r\u21900 0\u2374''\n      :Trap debug/0\n          :If 0=\u2395SE.\u2395NC'_Tatin'  \u235d In 19.0 it most likely will already be there!\n              :If ~IfAtLeastVersion 18\n                  r\u2190'Tatin not loaded: not compatible with this version of Dyalog'\n              :ElseIf 80\u2260\u2395DR' '              \u235d Not in \"Classic\"\n                  r\u2190'Tatin not loaded: not compatible with Classic'\n              :Else\n                  \u2395SE.\u2395EX\u00a8'_Tatin' 'Tatin'\n                  wspath\u21901 GetProgramFilesFolder '/SessionExtensions/CiderTatin/Tatin/Client.dws'\n                  '_Tatin'\u2395SE.\u2395CY wspath\n                  path2Config\u2190\u2283\u2395nparts \u2395SE._Tatin.Client.FindUserSettings \u2395AN\n                  'Create!'\u2395SE._Tatin.Client.F.CheckPath path2Config\n                  'Tatin'\u2395SE.\u2395NS''\n                  path2Config \u2395SE._Tatin.Admin.EstablishClientInQuadSE \u236c\n              :EndIf\n          :EndIf\n      :Else\n          r\u2190'Attempt to load Tatin failed with ',\u2395DMX.EM\n      :EndTrap\n    \u2207\n\n      IfAtLeastVersion\u2190{\n      \u235d \u2375 is supposed to be a number like 15 or 17.1, representing a version of Dyalog APL.\n      \u235d Returns a Boolean that is 1 only if the current version is at least as good.\n          \u2375\u2264{\u2283(//)\u2395VFI \u2375/\u23682&gt;+\\'.'=\u2375}2\u2283# \u2395WG'APLVersion'\n      }\n\n    \u2207 r\u2190{versionAgnostic}GetProgramFilesFolder postFix;version;aplVersion;OS\n      \u235d Returns the path to Dyalog's version-specific program files folder.\\\\\n      \u235d Works on all platforms but returns different results.\\\\\n      \u235d Under Windows typically:\\\\\n      \u235d `C:\\Users\\&lt;\u2395AN&gt;\\Documents\\Dyalog APL[-64] 19.0 Unicode Files' \u2190\u2192 GetMyUCMDsFolder\n      \u235d \u237a is optional and defaults to 0, meaning the version-agnostic folder is returned.\n      \u235d If \u237a\u21901, the folder associated with the currently running version of Dyalog is returned.\n       versionAgnostic\u2190{0&lt;\u2395NC \u2375:\u234e\u2375 \u22c4 0}'versionAgnostic'\n       OS\u21903\u21911\u2283# \u2395WG'APLVersion'\n       postFix\u2190{(((~'/\\'\u220a\u2368\u2283\u2375)\u22270\u2260\u2262\u2375)/'/'),\u2375}postFix\n       aplVersion\u2190# \u2395WG'APLVersion'\n       :If versionAgnostic\n           :If OS\u2261'Win'\n               version\u2190((\u2228/'-64'\u23771\u2283aplVersion)/'-64'),' ',({\u2375/\u23682&gt;+\\\u2375='.'}2\u2283aplVersion),' ',(80=\u2395DR' ')/'Unicode'\n               r\u2190(2 \u2395NQ #'GetEnvironment' 'USERPROFILE'),'\\Documents\\Dyalog APL',version,' Files',postFix\n           :Else\n               version\u2190({'.'~\u2368\u2375/\u23682&gt;+\\\u2375='.'}2\u2283aplVersion),((80=\u2395DR' ')/'U'),((1+\u2228/'-64'\u23771\u2283aplVersion)\u2283'32' '64')\n               r\u2190(\u2283\u2395SH'echo $HOME'),'/dyalog.',version,'.files',postFix\n           :EndIf\n       :Else\n           :If OS\u2261'Win'\n               r\u2190(2 \u2395NQ #'GetEnvironment' 'USERPROFILE'),'\\Documents\\Dyalog APL Files',postFix\n           :Else\n               r\u2190(\u2283\u2395SH'echo $HOME'),'/dyalog.files',postFix\n           :EndIf\n       :EndIf\n   \u2207\n\n:EndNamespace\n</code></pre>"},{"location":"original/installingandupdatingthetatinclient/#there-is-already-such-a-script","title":"There is already such a script","text":"<p>Copy the functions <code>IfAtLeastVersion</code>, <code>GetProgramFilesFolder</code> and <code>AutoLoadTatin</code> from above into your own <code>setup.dyalog</code> script and then make sure that <code>AutoLoadTatin</code> is called from your <code>Setup</code> function. </p> <p>Also, call <code>{}\u2395SE.SALTUtils.ResetUCMDcache -1</code> in case <code>AutoLoadTatin</code> returned an empty vector (read: was executed successfully) in order to make sure that the Tatin user commands are found.</p>"},{"location":"original/installingandupdatingthetatinclient/#updating-tatin","title":"Updating Tatin","text":"<p>You've installed (18.2) or activated (later than 18.2) Tatin before and want to update it to the latest version.</p> <p>In that case you might need to perform some action, depending on how old your version of Tatin is.</p>"},{"location":"original/installingandupdatingthetatinclient/#tatin-versions-before-01050","title":"Tatin versions before 0.105.0","text":"<p>Versions before 0.105.0 might have been installed into one of these folders:</p> <pre><code>C:\\Users\\&lt;user&gt;\\Documents\\MyUCMDs\\     \u235d Windows\n/users/&lt;user&gt;/MyUCMDs/                 \u235d Mac-OS\n/home/&lt;user&gt;/MyUCMDs/                  \u235d Linux\n</code></pre> <p>If that is the case then, in order to keep things simple, you are advised to remove the folder <code>Tatin</code> from the <code>MyUCMDs/</code> folder and install Tatin (and, if installed, Cider) from scratch rather than updating it.</p> <p>If have loaded Tatin into <code>\u2395SE</code> with a script <code>setup.dyalog</code> you might need to make amendment to it.</p>"},{"location":"original/installingandupdatingthetatinclient/#tatin-version-01050-and-later","title":"Tatin version 0.105.0 and later","text":"<p>Once you have Tatin 0.105.0 (or later) installed in the right place you can use <code>]Tatin.UpdateTatin</code> for updating Tatin to a later version.</p> <p>Just execute:</p> <p>``` ]Tatin.UpdateTatin ````</p> <p>All necessary steps will be executed; eventually the new version number will be reported.</p> <p>Notes:</p> <ul> <li> <p>The command will put the release notes on display in your default browser</p> </li> <li> <p>Although Tatin is updated on disk, the workspace from which the update command was executed is not updated for technical reasons --- start a new instance of Dyalog to get the latest version</p> </li> <li> <p>19.0 and later only: Tatin's <code>Update</code> command overwrites the version in the installation directory in your home directory, not the version that came originally with Dyalog APL; that remains unchanged.</p> </li> </ul>"},{"location":"original/installingandupdatingthetatinclient/#when-updating-goes-wrong","title":"When updating goes wrong","text":"<p>Debugging is the process of removing bugs from code, while programming is how you introduce them in the first place.</p> <p>There is always the possibility that the update process is itself buggy. Calling it again usually does not help, so you need an escape route.</p> 18.2 19.0 and later <p>The easiest way to recover it by uninstalling and then installing Tatin again.</p> <ol> <li>Execute <code>]DeActivate tatin</code> --- that removes Tatin</li> <li>Execute <code>]Activate tatin</code> --- that brings back the version of Tatin that your installation originally came with</li> <li>Execute <code>]Tatin.UpdateTatin</code> --- that will try to update to the latest version</li> </ol>"},{"location":"original/installingthetatinserver/","title":"Installing and Updating the Tatin Server","text":""},{"location":"original/installingthetatinserver/#introduction","title":"Introduction","text":"<p>While the Tatin Client is coming with version 19.0 and later automatically, the Tatin Server always needs to be installed in case you want to run your own managed Tatin Registry.</p> <p>After downloading it from https://github.com/aplteam/Tatin/releases you need to unzip it into a folder where the Tatin Server is supposed to live.</p>"},{"location":"original/installingthetatinserver/#requirements","title":"Requirements","text":"<ul> <li>Dyalog Unicode 18.2 or better</li> <li>Windows or Linux</li> </ul> <p>For the time being neither the Pi nor AIX are supported. The PI might be added at a later stage.</p>"},{"location":"original/installingthetatinserver/#configuration-the-ini-file","title":"Configuration: the INI File","text":"<p>First, you need to amend the file <code>server.ini</code>.</p> <p>A&gt; ### Plodder A&gt; A&gt; Tatin uses Plodder (https://github.com/aplteam/Plodder) as an HTTP server.  A&gt; A&gt; The INI file is originally a Plodder INI file with some additional settings used on the application level.</p> <p>Note that this is an old-school INI file. Well, almost: it comes with several features that are unusual for INI files. We just mention the most important ones here; for details see https://github.com/aplteam/IniFiles.</p> <ul> <li>There are data types: text needs to go between 'quotes', and everything else is considered a number</li> <li>You may define local variables</li> </ul> <p>A&gt; ### What is a local variable? A&gt; A&gt; On top of the INI file, before any <code>[SECTION]</code>, the local variable <code>home</code> is defined. It carries the value <code>&lt;INIFILE&gt;</code>. A&gt; A&gt; Further down this local variable is referenced as <code>{home}</code>; that simply means that <code>{home}</code> will be replaced by <code>&lt;INIFILE&gt;</code> once the INI file is instantiated.  A&gt;</p>"},{"location":"original/installingthetatinserver/#INIFILE","title":"<code>&lt;INIFILE&gt;</code>","text":"<p>When the Tatin Server loads the INI file it will replace the string <code>&lt;INIFILE&gt;</code> with the fully qualified directory the INI file was loaded from.</p>"},{"location":"original/installingthetatinserver/#settings-to-pay-attention-to","title":"Settings to pay attention to","text":"<p>The INI file is well documented, so we won't discuss the meaning of the different sections and settings. Most of the settings don't need changing, so we will just draw your attention to those you are likely to change:</p>"},{"location":"original/installingthetatinserver/#configappname","title":"[CONFIG]AppName","text":"<p>This defines the name used by Tatin for logging into the Windows Event Log. </p> <p>The parameter has no meaning on non-Windows platforms, and is ignored in case <code>[LOGGING]WindowsEventLog</code> is 0 rather than 1.</p>"},{"location":"original/installingthetatinserver/#configregistry","title":"[CONFIG]Registry","text":"<p>This is the path where the Registry lives that is managed by the Tatin Server.</p>"},{"location":"original/installingthetatinserver/#configbase","title":"[CONFIG]Base","text":"<p>From version 0.104.0 onwards this INI file entry is ignored.</p>"},{"location":"original/installingthetatinserver/#configbasetagport","title":"[CONFIG]BaseTagPort","text":"<p>From version 0.104.0 onwards this INI file entry is ignored.</p>"},{"location":"original/installingthetatinserver/#configtitle","title":"[CONFIG]Title","text":"<p>When you use a Browser for accessing a Tatin server then <code>Title</code> defines what will become the window or tab title in the browser.</p>"},{"location":"original/installingthetatinserver/#configcaption","title":"[CONFIG]Caption","text":"<p>This defines what all the HTML pages will display as <code>&lt;h1&gt;</code>.</p>"},{"location":"original/installingthetatinserver/#configreloadws","title":"[CONFIG]ReloadWS","text":"<p>If this is 1 Tatin will frequently check whether the workspace <code>Server.dws</code> was changed since it was loaded. If it was then Tatin will load it, meaning that it will kind of restart itself.</p> <p>Whether this is a good idea in production is debatable, but it can be helpful in development.</p>"},{"location":"original/installingthetatinserver/#configdeletepackages","title":"[CONFIG]DeletePackages","text":"<p>This setting defines whether a user might delete a package. The setting may become one of these:</p> <p>| 0 | Deleting packages is not allowed | 1 | Deleting packages is allowed | 2 | Only beta versions may be deleted </p> <p>The principal Tatin server does not allow the deletion of anything. The simple reason for this policy is that we want to guarantee that a build can always be reproduced.</p> <p>A&gt; ### Beta versions A&gt; A&gt; What qualifies as a beta version? Here are some examples: A&gt; <code>A&gt; group-foo-1.0.0              \u235d not a beta A&gt; group-foo-1.0.0+123          \u235d not a beta A&gt; group-foo-1.0.0-fix          \u235d a beta A&gt; group-foo-1.0.0-fix+123      \u235d a beta A&gt; group-foo-1.0.0-beta-23+123  \u235d a beta A&gt;</code></p>"},{"location":"original/installingthetatinserver/#the-section-configsecure","title":"The section [CONFIG]Secure","text":"<p>Flag that defines whether certificates (https) are used or not (http).</p>"},{"location":"original/installingthetatinserver/#the-section-certificatescertificates","title":"The section [CERTIFICATES]{#certificates}","text":"<p>A certificate is required in case you want to use https, a must on the Internet these days. You probably want to use your own one.</p> <p>For more details on certificates see \"On Certificates\"</p>"},{"location":"original/installingthetatinserver/#the-section-emailemail","title":"The section [EMAIL]{#EMAIL}","text":"<p>A Tatin server can send emails, broadcasting any crashes. For that, you must specify a couple of things in this section.</p> <p>The INI file is well documented, so you should have no trouble making the necessary adjustments.</p>"},{"location":"original/installingthetatinserver/#on-logging","title":"On Logging","text":""},{"location":"original/installingthetatinserver/#logging-on-file","title":"Logging on file","text":"<p>Tatin will always write to the log file, but how much information is written can be influenced by settings in the INI file.</p> <p>There are two different levels available for logging:</p> <ul> <li>High- (or application-) level logging should always be done. Only then is usage data available.</li> </ul> <p>Note that IP addresses are not logged at this level.</p> <ul> <li>Low-level logging is controlled by the INI file's <code>LogHTTP</code>, <code>LogConga</code>, and <code>LogRumba</code> properties. These can be useful for debugging. They log IP addresses which might be illegal in certain countries.</li> </ul>"},{"location":"original/installingthetatinserver/#the-windows-event-log","title":"The Windows Event Log","text":"<p>Under Windows, you may let Tatin write to the Event Log by setting <code>WindowsEventLog</code> to 1.</p> <p>This parameter is ignored on non-Windows platforms and has no effect under Windows when Tatin is not running as a Windows Service.</p> <p>If you do run the Tatin Server as a Windows Service then set this to 1. Start, Pause, Stop and crashes are then reported to the Windows Event Log.</p>"},{"location":"original/installingthetatinserver/#on-certificatescertificates2","title":"On Certificates{#certificates2}","text":"<p>Note that in case you want your Tatin server to serve requests from the Internet --- as opposed to an Intranet --- it is strongly recommended to hide the Tatin Server behind an industrial-strength HTTP server like Apache.</p> <p>Such a server can deal with attacks and has also all sorts of security measures built into it, so it's much safer to run Tatin behind it.</p> <p>There is a separate document available that discusses how to do this: Run Dyalog behind Apache.</p> <p>In case you hide the Tatin Server behind, say, an Apache server on the same machine there might be no need to use encryption (https).</p>"},{"location":"original/installingthetatinserver/#the-msg-section","title":"The <code>[MSG]</code> section","text":"<p>This section can be useful in case you want to inject a message into every HTML page delivered by Tatin.</p> <p>A typical application is the announcement of downtime due to maintenance.</p> <p>The section has two values, <code>Text</code> and <code>CSS</code>. In case <code>Text</code> is not empty it is injected as <code>&lt;div&gt;&lt;p&gt;{text}&lt;/p&gt;?&lt;/div&gt;</code>. If <code>CSS</code> is not empty it is injected into the <code>&lt;div&gt;</code> as <code>style=\"...\"</code>.</p>"},{"location":"original/installingthetatinserver/#the_app_section","title":"The <code>[APP]</code> section","text":"<p>This section tells Plodder where to find the application-specific logic (Tatin).</p> <ul> <li><code>Context</code></li> </ul> <p>This defines the namespace all Tatin-specific handlers live in.</p> <ul> <li>The <code>On*</code> handlers</li> </ul> <p>These are the Tatin-specific entry points. You might want to add something to <code>OnHouseKeeping</code>, or add a handler <code>OnHeader</code>, but that is pretty unusual.</p>"},{"location":"original/installingthetatinserver/#how-to-start-the-tatin-server","title":"How to start the Tatin server","text":"<p>After having made the necessary adjustments in the INI file you could of course simply start an instance of Dyalog with ample memory, and load the workspace. <code>#.Tatin.Server.Run 1</code> is executed via <code>\u2395LX</code>, and your server is up and running.</p> <p>Most errors that could occur (bugs in Tatin etc.) are trapped and will return a 500 (Internal Server Error) but would not prevent the server from running. However, some errors might bring the server down like an aplcore or a WS FULL.</p> <p>In such an event you are most likely interested in the server being restarted automatically.</p>"},{"location":"original/installingthetatinserver/#windows","title":"Windows","text":"<p>Under Windows you have two options:</p> <ul> <li>Run the Tatin Server as a Windows Service</li> <li>Run it in a Docker container</li> </ul> <p>Both options allow running the Server so that it is restarted automatically in case of a failure or a reboot.</p> <p>Running the server as a Windows Service gives you the best performance, but running it in a Docker container is still surprisingly fast, given that it runs a (very basic) version of Linux in a virtual machine.</p> <p>If you want to run the Tatin server as a Windows Service you can put the workspace <code>InstallAsWindowsService.dws</code> to good use: it will install Tatin as a Windows service. Note that this requires admin rights.</p>"},{"location":"original/installingthetatinserver/#linux","title":"Linux","text":"<p>Under Linux, you are advised to run the Tatin Server in a Docker image. </p>"},{"location":"original/installingthetatinserver/#docker-required-amendments","title":"Docker: required amendments","text":""},{"location":"original/installingthetatinserver/#the-file-dockerfile","title":"The file <code>Dockerfile</code>","text":"<ol> <li>Linux Version</li> </ol> <p>Specify both the name of the desired distribution and the version number in the <code>FROM</code> clause at the top of the file. In the template, this is \"Ubuntu\" and \"22.04\".</p> <ol> <li> <p>It is a Docker convention to specify the Docker username and email address of a maintainer in the <code>MAINTAINER</code> clause.</p> </li> <li> <p>Dyalog APL</p> </li> </ol> <p>Before anything else make sure that you copy the appropriate version of Dyalog APL into the folder that holds the Docker-related files.</p> <ol> <li>Dockerfile</li> </ol> <p>This file defines what docker should put into the container. In particular, it must point to the desired version of Dyalog APL, so check the variables <code>DYALOG_RELEASE</code>, <code>DYALOG_VERSION</code> and <code>DYALOG_DEBFILE</code>.</p> <ol> <li> <p>Do not change the <code>WORKDIR</code>!</p> </li> <li> <p>Do not change <code>DYALOG_SERIAL</code>: this license number is explicitly reserved for Tatin servers.</p> </li> </ol>"},{"location":"original/installingthetatinserver/#the-file-entrypoint","title":"The file <code>entrypoint</code>","text":"<p>In this file, a couple of environment variables are defined that might not be set to your taste: <code>TRACE_ON_ERROR</code>, <code>SINGLETRACE</code> and <code>CLASSICMODE</code>. </p>"},{"location":"original/installingthetatinserver/#the-file-createtatindockercontainersh","title":"The file <code>CreateTatinDockerContainer.sh</code>","text":"<ol> <li> <p>You must change the <code>source</code> parameter so that it points to the folder that hosts the Tatin server data.</p> </li> <li> <p>You might need to change port 443, defined with the <code>-p</code> flag.</p> </li> </ol> <p>This can only ever be 80 or 443 on your local machine if the Tatin server is not exposed to the Internet because in that scenario Tatin should run behind a web server like Apache. In that case, Apache would listen to 80 or 443 but communicate with the Tatin server on a different port.</p> <ol> <li>The second port exposed in that script is used for connecting with Ride to the interpreter, if ever. (Note that the INI file rules whether the interpreter allows a Ride or not)</li> </ol>"},{"location":"original/installingthetatinserver/#docker-workflow","title":"Docker workflow","text":"<p>Execute these steps:</p> <ol> <li>Call  <code>./BuildImage.sh</code> for creating the image</li> <li>Call  <code>./CreateTatinDockerContainer.sh</code> for creating the container from that image</li> <li>Call  <code>start-tatin.sh</code> to start the container; this script ensures that the container is restarted after a crash or auto-started after a reboot</li> </ol>"},{"location":"original/installingthetatinserver/#testing-and-debugging","title":"Testing and Debugging","text":"<p>For testing and debugging you might want to change these settings:</p> <ul> <li><code>[CONFIG]DisplayRequests</code></li> <li><code>LogHTTPToSession</code></li> <li><code>TestFlag</code>; in case this is 1 a Tatin Server supports additional commands. To get a list of these commands execute \"list-commands\". Naturally, this makes sense only under program control, not from a browser.</li> <li><code>ReloadWS</code></li> <li>The settings in the <code>[LOGFILE]</code> section</li> </ul>"},{"location":"original/installingthetatinserver/#misc","title":"Misc","text":"<p>When you see the term \"Plodder\" somewhere: This is a generalized HTTP server that is used by Tatin behind the curtains. Plodder is in turn based on Rumba and Conga.</p> <p>For details see:</p> <ul> <li> <p>https://github.com/aplteam/Plodder</p> </li> <li> <p>https://github.com/aplteam/RumbaLean</p> </li> </ul>"},{"location":"original/installingthetatinserver/#updating-the-server","title":"Updating the Server","text":"<p>Before updating the server you must read the release notes! The reason is that an update might be as easy as copying the workspace over while the server is running but as complex as requiring several actions while the server is down for maintenance.</p>"},{"location":"original/installingthetatinserver/#the-workspace","title":"The Workspace","text":"<p>A running server might frequently check whether the workspace on disk was changed since the server was started if configured accordingly. If that is the case the server will load the workspace again. This allows an easy update in case no complex actions are required. </p> <p>I&gt; This mechanism is active by default but might be switched off with <code>[CONFIG]ReloadWS</code> in the INI file</p> <p>Naturally, the server will produce an error message for a short period during the reload; expect 10 seconds or more, depending on the number of packages managed by the server.</p>"},{"location":"original/installingthetatinserver/#the-ini-file","title":"The INI file","text":"<p>Entries in the INI file might have been added or removed. Whether that is the case will be revealed by the release notes. If something has changed follow the release notes. Do not replace the INI file!</p> <p>The server checks the INI file for having been changed, and if that is the case re-initialize the INI file. However, whether that works or not depends on the kind of change: a number of settings are required at a very early stage, and cannot be changed later on. Again the release notes will tell.</p>"},{"location":"original/installingthetatinserver/#assets","title":"Assets","text":"<p>What kind of actions need to be taken, if any, is revealed by the release notes. Typically the subfolder <code>docs/</code> needs to be replaced: this folder carries the documentation.</p>"},{"location":"original/installingthetatinserver/#the-folder-maintenance","title":"The folder Maintenance/","text":"<p>First of all, never replace the folder <code>maintenance/</code>: its content documents what changes have been carried out towards the packages in the past, and you don't want to lose this.</p> <p>If the new one is not empty then copy the content over. Maintenance files can be used to carry out changes on all or some of the packages managed by that server, like adding a new property to the package config files of all packages.</p>"},{"location":"original/introduction/","title":"Introduction","text":""},{"location":"original/introduction/#what-is-tatin","title":"What is Tatin?","text":"<p>Tatin is a package manager for Dyalog APL that helps you use and manage packages and their interdependencies. </p>"},{"location":"original/introduction/#what-is-a-package","title":"What is a package?","text":"<p>A package should serve a particular task, for example converting markdown files into HTML. A package may be independent, but it may also depend on other packages. Tatin manages dependencies behind the scene.</p> <p>A package may consist of as little as a single source file and as much as a nested folder structure with many source files. Any of those files may contain a single function, a single operator, a single class, a single interface, or a single namespace. </p> <p>W&gt; Dyalog supports several APL objects in a single text file. Tatin does not support this.</p> <p>A package may also come with assets.</p> <p>A&gt; ### Assets A&gt; A&gt; A package may come with all sorts of assets (CSS files, BAT files, icons, images, config files, documentation, DLLs...) which can be accessed via a folder that is defined in the package configuration file.</p>"},{"location":"original/introduction/#why-do-we-need-packages","title":"Why do we need packages?","text":"<p>These days packages are available in probably 99% of all programming languages. It allows the consumption of code that others have written to solve a particular task. Name clashes can be easily avoided, and you don't have to worry about dependencies.</p> <p>Packages can easily be updated to a later (and therefore hopefully better) version.</p>"},{"location":"original/introduction/#requirements","title":"Requirements","text":"<ul> <li> <p>Tatin requires Dyalog version 18.2 or later. It will come automatically with version 19.0 (although it must be activated with the <code>]activate</code> user command) but must be installed in earlier versions.</p> </li> <li> <p>It needs Unicode --- Classic is not supported.</p> </li> <li> <p>The Tatin client runs on Windows, Linux, Mac OS and the PI.</p> </li> <li> <p>The Tatin server runs on Windows (as a Service or a Docker container) and on Linux (as a Docker image). </p> </li> </ul> <p>In principle the server also runs on a Mac but the docker container has not been tested on a Mac.</p> <ul> <li>Tatin is not compatible with SALT, although the extension <code>.dyalog</code> is supported.</li> </ul> <p>In particular Tatin requires source files to carry exactly one APL object, be that a function, an operator, an array, a class script, an interface script, or a namespace script.</p>"},{"location":"original/introduction/#tatins-components","title":"Tatin's components","text":"<p>Tatin consists of:</p> <ul> <li>A Client</li> </ul> <p>The Tatin client can be used in two different ways:</p> <ul> <li>By executing user commands like <code>]TATIN.LoadPackages ...</code> </li> <li> <p>Via its API by executing a statement like <code>\u2395SE.Tatin.LoadPackages '...'</code></p> </li> <li> <p>A Tatin Server</p> </li> </ul> <p>A Tatin server hosts packages and allows you to fetch packages as well as any dependencies, and to publish packages.</p> <ul> <li> <p>A set of rules that define how a package is structured, and which metadata is required or may optionally be added.</p> </li> <li> <p>A set of HTML documents serving as documentation for different aspects of Tatin.</p> </li> </ul> <p>The principal Tatin server is available at https://tatin.dev, but you can also run your own server(s) if you wish. There is also a server https://test.tatin.dev available as a playground for experiments.</p>"},{"location":"original/introduction/#consumers","title":"Consumers","text":"<p>If you're a consumer, you'll use the Tatin client to load, explore, and eventually install packages from one or more Tatin servers.</p> <p>Note that although you can access a Tatin server with a browser, its real goal is the communication of the <code>]TATIN</code> user commands (or the Tatin API functions) with one or more Tatin servers.</p>"},{"location":"original/introduction/#authors-publishers","title":"Authors (publishers)","text":"<p>You may develop Tatin packages using whatever tools you're familiar with.  These could be GitHub, GitLab or any of their competitors, or local files on your PC.</p> <p>When you're ready to create a release of your package, you'll assign a group and specify a name and a version number, define dependencies (if any), and you may provide additional meta information like tags, a description, and more. You may even add user-defined metadata.</p> <p>Finally, you publish your package to a Tatin server.</p> <p>Of course, you should publish your first package on the test server https://test.tatin.dev rather than on https://tatin.dev to gain experience without shooting yourself in the foot.</p> <p>That is particularly important on https://tatin.dev because any package that was published cannot be changed and/or deleted; you can only publish another version.</p>"},{"location":"original/introduction/#now-what","title":"Now what?!","text":"<p>Now is the time to read First Steps with Tatin</p> <p>A&gt; ### Semantic versioning and Minimal Version Selection A&gt; A&gt; We suggest that you make yourself familiar with the concepts of Semantic Versioning and Minimum Version Selection, and how exactly these concepts are implemented in Tatin by reading the document Tatin's load- and update strategy.</p>"},{"location":"original/packageconfiguration/","title":"Tatin's Package Configuration File","text":""},{"location":"original/packageconfiguration/#overview","title":"Overview","text":"<p>Every package has a configuration file: that's one of the things that make it a package. It defines all that is required to consume the package and to announce its existence to the world.</p> <p>This is an example:</p> <pre><code>{\n  api: \"DotNetZip\",\n  assets: \"\",\n  description: \"Zipping and unzipping with.NET Core on all major platforms\",\n  documentation: \"\",\n  exclude: \"\",\n  files: \"\",\n  group: \"aplteam\",\n  io: 1,\n  license: \"MIT\",\n  lx: \"\",\n  maintainer: \"kai@aplteam.com\",\n  minimumAplVersion: \"18.2\",\n  ml: 1,\n  name: \"DotNetZip\",\n  os_lin: 1,\n  os_mac: 1,\n  os_win: 1,\n  project_url: \"https://github.com/aplteam/DotNetZip\",\n  source: \"DotNetZip.aplc\",\n  tags: \"zip-tools\",\n  tatin_version: \"0.103.0\",\n  userCommandScript: \"\",\n  version: \"0.5.4\",\n}\n</code></pre> <p>This is saved in a file <code>apl-package.json</code> which must live in the root of what is a package.</p> <p>Notes:</p> <ul> <li>You might see <code>wx</code> in an older package: with version 0.61.0 <code>wx</code> was removed from package config files.</li> <li>When viewing a package config file on a Tatin Server you will also see <code>date</code>: this is injected by the Tatin server: it is the package's publishing date.</li> </ul>"},{"location":"original/packageconfiguration/#details","title":"Details","text":""},{"location":"original/packageconfiguration/#introduction","title":"Introduction","text":"<p>In the workspace, a simple namespace can be used for package configuration. On file, it is saved as JSON5. Tatin's API offers a function <code>Tatin.InitialisePackage</code> that can be used to create a package config file.</p> <p>It can be fed with an empty vector as the right argument: then just defaults are established.</p> <p>Instead, you may create a namespace and populate that namespace with Tatin package configuration variables which are discussed underneath. In this case, the values in the namespace overwrite the defaults.</p> <p>Example:</p> <pre><code>      parms\u2190\u2395NS''\n      parms.group\u2190'aplteam'\n      parms.name\u2190'Foo'\n      parms.version\u2190'1.0.0'\n      Tatin.InitialisePackage parms \n</code></pre> <p>The user command equivalent is <code>]tatin.PackageConfig</code></p> <p>I&gt; Instead of <code>]tatin.PackageConfig -edit</code> you may also enter <code>]tatin.CreatePackage</code></p>"},{"location":"original/packageconfiguration/#user-defined-variables","title":"User-defined variables","text":"<p>You may define your own variables in a package configuration file.</p> <p>However, since more Tatin-specific variables might be added at a later stage there is a danger of name clashes. This is avoided by a simple rule:</p> <p>I&gt; The names of user-defined variables must start with an underscore</p> <p>If you specify any variable with a name that Tatin does not know about and that does not start with an underscore an error will be thrown.</p>"},{"location":"original/packageconfiguration/#tatins-package-configuration-variables","title":"Tatin's package configuration variables","text":""},{"location":"original/packageconfiguration/#api","title":"api","text":"<p>\"api\", if not empty,  must be the name of the namespace that will contains the public interface of what's in the package. \"API\" is a good name for this.</p> <p><code>api</code> is used by the Tatin API function <code>CreateAPIfromCFG</code>. This function would create functions in the <code>api</code> namespace that act as the public interface, returning references to functions, operators, interfaces, classes, namespaces and variables.</p> <p>See the \"Syntax Reference\" document for details.</p>"},{"location":"original/packageconfiguration/#assets","title":"assets","text":"<p>If this is empty then the package has no assets. Instead it can point to a folder hosting assets. </p> <p>The folder must be relative to the package since the folder is part of the package. For that reason, a folder may not contain a \"<code>:</code>\", and not start with \"<code>/</code>\". If it does anyway an error is thrown.</p> <p>There is one exception: when an absolute path is specified but it's partly identical to what will become <code>HOME</code> (the folder where the package lives) then Tatin removes that part silently, making it effectively relative. </p> <p>Notes:</p> <ul> <li>When the package configuration file is written to disk, the existence of \"assets\" is checked. If it's not a folder an error is thrown.</li> </ul> <p>See also the <code>GetFullPath2AssetsFolder</code> function.</p> <ul> <li> <p>The <code>assets\\</code> folder must be considered read-only. Do not write to it from a package!</p> </li> <li> <p>Check the \"files\" property for files like \"ReadMe.txt\" and the like.</p> </li> <li> <p>A file named \"LICENSE\" in the root of a project will always be copied to the root of a package by convention when a package is build.</p> </li> </ul> <p>A&gt; ### Accessing assets from a class instance A&gt; A&gt; In case you need to access assets from an instance of a class in a package you have two choices: A&gt; A&gt; 1. Add to the class a function like this: A&gt;  A&gt;    <code>A&gt;    r\u2190GetAssetFolder A&gt;    r\u2190##.TatinVars.GetFullPath2AssetsFolder A&gt;</code> A&gt;  A&gt; 2. Use the expression <code>\u2283\u2283\u2395CLASS \u2395THIS</code> to find out where the class script lives. A&gt;  A&gt;    Therefore the following expression returns the path to the assets: A&gt;  A&gt;    <code>A&gt;    (\u2283\u2283\u2395CLASS \u2395THIS).##.TatinVars.GetFullPath2AssetsFolder A&gt;</code></p> <p>A&gt; ### Platform dependent assets A&gt;  A&gt; There is no general solution for the problem of platform-dependent assets. One way to solve this is to use <code>lx</code> for this, see there.</p>"},{"location":"original/packageconfiguration/#deprecated","title":"deprecated","text":"<p>A Boolean that is optional. </p> <p>It is injected into a package config file by the <code>]Tatin.DeprecatePackage</code> command. A 1 means that this package is deprecated.</p>"},{"location":"original/packageconfiguration/#deprecate_comment","title":"deprecate_comment","text":"<p>An optional character vector.</p> <p>It is injected into a package config file by the <code>]Tatin.DeprecatePackage</code> command.</p> <p>You are supposed to give a hint why a package became deprecated, for example, \"See package XYZ instead\".</p>"},{"location":"original/packageconfiguration/#description","title":"description","text":"<p>A short description of what the package is supposed to do, or what kind of problems it solves. This is supposed to be readable and meaningful to humans.</p> <p>This information is typically used when a human accesses a Tatin Server with a Browser.</p> <p><code>description</code> must not be empty.</p>"},{"location":"original/packageconfiguration/#documentation","title":"documentation","text":"<p>This can be one of:</p> <ul> <li>A URL pointing to an online help resource</li> </ul> <p>It is identified by starting with either \"<code>http://</code>\" or \"<code>https://</code>\".</p> <ul> <li>A local path pointing to a file (or program) within the package</li> </ul> <p>In this case, it must be a relative path since you cannot know in advance where your package ends up.</p> <p>It must start with \"<code>./</code>\".</p> <ul> <li>A pointer to a function or a variable inside the package</li> </ul> <p>It must start with \"<code>\u2395THIS.</code>\", and whatever follows must be valid APL name(s). Examples:</p> <pre><code>\u2395THIS.ShowHelp\n\u2395THIS.Admin.ShowHelp\n</code></pre> <p>Content that does not qualify for one of these options will be rejected.</p>"},{"location":"original/packageconfiguration/#exclude","title":"exclude","text":"<p>This may or may not exist. If it does exist it must be one of:</p> <ul> <li>A single file- or directory name </li> <li>A comma-separated list of files and/or directories</li> </ul> <p>All entries must be relative to <code>source</code>, and they must exist as a file or a directory, otherwise an error is thrown.</p> <p>!&gt; ### What is \"exclude\" good for? =&gt;  =&gt; If you want a particular repository to not only be available as a Tatin package but also from GitHub, then there is the problem of how to specify <code>\u2395IO</code> and <code>\u2395ML</code>. =&gt;  =&gt; Tatin packages allow these values to be defined in the package config file, and that works just fine for packages. =&gt;  =&gt; If you want to bring in just the <code>APLSource/</code> folder, you have to take care of <code>\u2395IO</code> and <code>\u2395ML</code> yourself. The obvious choice is to define two files, <code>\u2395IO.apla</code> and <code>\u2395ML.apla</code>, which will be loaded by Link and used to set the two system variables. =&gt;  =&gt; But those two files are not required by the package - it would be nice to be able to exclude them from being added to the package when it is built. <code>exclude</code> would allow just that: =&gt;  =&gt; <code>=&gt; exclude : \"\u2395IO.apla, \u2395ML.apla\", =&gt;</code> =&gt;  =&gt; Because these files have non-ANSI characters in their filenames, adding them to a ZIP file on one platform would currently cause problems when unzipping it on different platform, and this problem is unlikely to go away, and there is nothing we can do about this: it's a ZIP problem. =&gt;  =&gt; This is just one example when <code>exclude</code> can be put to good use.</p> <p>For better compatability this property is not injected into new packages but accepted as an optional parameter. This might be changed with version 1.0.0 of Tatin.</p>"},{"location":"original/packageconfiguration/#files","title":"files","text":"<p>You might want to get one or more specific files into the root of the package although they are not really assets. </p> <p>Typical examples are \"LICENSE\" and \"ReadMe.[md|txt|html]\". Strictly speaking they are not assets because the package will still function perfectly well without them. Also, you want them to go to the root of the project, not into a sub-folder, so that they stand out. </p> <p>That can be achieved by adding them to the \"files\" property. <code>files</code> can be one of:</p> <ul> <li>Absent</li> <li>Empty</li> <li>A single file</li> <li>A comma-separated list of files</li> </ul> <p>Note that if it specifies a sub-folder, <code>BuildPackage</code> will copy the folder from that project-specific sub-folder to the root of the package.</p> <p>See also \"assets\".</p> <p>I&gt; Note that a file <code>LICENSE</code> in the root of a project is by convention copied to the root of a package when a package is build.</p>"},{"location":"original/packageconfiguration/#group","title":"group","text":"<p>The \"group\" part of the package ID<sup>1</sup></p> <p>A group may be the name of a user, the owner, a company, an application name, a publisher or anything else that makes sense. It's totally up to you and might well depend on who is running the Tatin Server you want to publish to.</p> <p>You can define a default for <code>group</code> in the user settings file. The default will be injected when a new package is created.</p>"},{"location":"original/packageconfiguration/#license","title":"license","text":"<p>This may be empty, or it may specify a license such as:</p> <pre><code>  license: \"MIT\",\n</code></pre> <p>You may not be able to publish a package to a Tatin registry without specifying a license: this depends on the licensing policy of a particular registry. The main Tatin registry https://tatin.dev is an example: you must specify a license in order to publish a package to it. Note that you can specify a default license in your user settings:</p> <pre><code>]TATIN.UserSettings -edit\n</code></pre> <p>At the bottom there are defaults defined for <code>license</code> and <code>source</code> and possibly other properties. The default will be injected when a new package is created.</p> <p>Both the user command <code>]Tatin.ListLicenses</code> and the API function <code>\u2395SE.Tatin.ListLicenses</code> can be used to get a list of all licenses tolerated by a Tatin Registry.</p>"},{"location":"original/packageconfiguration/#lx","title":"lx","text":"<p>This is optional: it may or may not exist, and it might be empty if it does exist.</p> <p>In case it is not empty it must be the name of a niladic or monadic function that resides in the top-level namespace of the package (not in what might be defined as API!) or a shared method of a class.</p> <p>This function will be executed by either <code>LoadPackages</code> or <code>LoadDependencies</code> after all dependencies have been loaded and all refs got established (read: at a very late stage).</p> <p>If the function is monadic it will be fed with the path where the package lives on disk. If the package was brought into the WS by <code>LoadPackages</code> and has no assets then the right argument will be empty.</p> <p>The function must return a result which is assigned to <code>TatinVars.LX</code> inside the package namespace. Without an <code>lx</code> function there won't be a variable <code>LX</code> in <code>TatinVars</code>.<sup>3</sup></p> <p>The <code>lx</code> function will be executed under error trapping, and any errors will be silently ignored. If you do not want this then you have two options:</p> <ul> <li> <p>Make <code>\u2395TRAP</code> a local variable in the <code>lx</code> function and assign <code>\u2395TRAP\u21900 'S'</code> to it to make any problem pop up straight away</p> </li> <li> <p>Put <code>:TRAP \u22c4 :EndTrap</code> around the code in the <code>lx</code> function and deal with problems yourself, for example in the <code>:Else</code> branch.</p> </li> </ul> <p>Note that the existence of a variable <code>TatinVars.LX</code> indicates that there was an <code>lx</code> function executed successfully, even when <code>TatinVars.LX</code> is empty.</p> <p>If no variable <code>TatinVars.LX</code> exists then there was either no <code>lx</code> function defined in the package config file or the function did crash.</p>"},{"location":"original/packageconfiguration/#applications","title":"Applications","text":"<p>There are two obvious applications for this:</p> <ul> <li>For initializing a package right after bringing it into the workspace</li> <li>For dealing with platform-dependent assets</li> </ul>"},{"location":"original/packageconfiguration/#maintainer","title":"maintainer","text":"<p>This may be left empty. If set it must be an email address. </p> <p>These formats are valid:</p> <pre><code>your name &lt;your.name@your-domain.com&gt;\nyour.name &lt;your.name@your-domain.com&gt;\nyour.name@your-domain.com\n</code></pre> <p>Note that any double quotes will be removed.</p> <p>If this is empty the server will, when the package is published, check whether there is a group home page. If that's the case, then there is an email address associated with that group, and that email address is then assigned to <code>maintainer</code>.</p> <p>You can define a default for <code>maintainer</code> in the user settings file. The default will be injected when a new package is created.</p>"},{"location":"original/packageconfiguration/#minimumaplversion","title":"minimumAplVersion","text":"<p>A character vector that must contain something like \"18.2\". 18.2 is the minimum version for any Tatin package, for Tatin itself needs at least version 18.2.</p>"},{"location":"original/packageconfiguration/#ml","title":"ml","text":"<p>An integer that will be assigned to <code>\u2395ML</code>.</p>"},{"location":"original/packageconfiguration/#name","title":"name","text":"<p>The \"name\" part of the package ID<sup>1</sup></p>"},{"location":"original/packageconfiguration/#os_lin","title":"os_lin","text":"<p>A Boolean; a 1 means that the package runs under Linux.</p>"},{"location":"original/packageconfiguration/#os_mac","title":"os_mac","text":"<p>A Boolean; a 1 means that the package runs under Mac-OS.</p>"},{"location":"original/packageconfiguration/#os_win","title":"os_win","text":"<p>A Boolean; a 1 means that the package runs under Windows.</p>"},{"location":"original/packageconfiguration/#project_url","title":"project_url","text":"<p>A URL that points to something like GitHub. </p> <p>An example is <code>https://github.com/aplteam/MarkAPL</code></p> <p>It's supposed to point to a place on the Web where the project is hosted that the package was built from.</p>"},{"location":"original/packageconfiguration/#source","title":"source","text":"<p>This defines the source code file(s) that are going to be part of the package.</p> <p>Must be either the name of a text file that contains code or a folder that contains a collection of code files. <code>source</code> must not be empty.</p> <p>If it's a single file it might be anything with the extension <code>.aplc</code> (a class script), <code>.apln</code> (a namespace script), <code>.aplf</code> (a function) or <code>.aplo</code> (an operator).</p> <p>The <code>.dyalog</code> extension is supported for limited backward compatibility --- Tatin does not guarantee complete compatibility with SALT. The <code>.dyalog</code> extension is still used by the user command framework, therefore Tatin must support it: a user command might well be delivered as a Tatin package. Note that outside this context using this extension is not encouraged.</p> <p>If <code>source</code> is a folder, it might contain any number and mixture of the aforementioned files. Any files with other extensions will be ignored.</p> <p><code>source</code> must be relative to the root of the package.</p> <p>Not that you may specify a default source in your Tatin user settings.  The default will be injected when a new package is created.</p>"},{"location":"original/packageconfiguration/#cider-and-tatin","title":"Cider and Tatin","text":"<p>If you manage a project with Cider then you might wonder why both have a property <code>source</code> in their configuration file. The reason is that the Cider config file describes what's going on in the project while the Tatin package config files describe what is going on in the package that will eventually be consumed by a user.</p> <p>Picture the following project \"Foo\" which consists of a single class <code>Foo</code>:</p> <pre><code>/Foo/\n     APLSource/\n               Admin/\n               ...\n               TestCases/\n               ...\n               Foo.aplc\n     cider.config\n     apl-package.json\n     README.md\n</code></pre> <p>In <code>cider.config</code> the <code>source</code> parameter must be set to <code>APLSource</code> because that's where all the code lives. </p> <p>In <code>apl-package.json</code> however, <code>source</code> may be set to <code>APLSource/Foo.aplc</code> because you might decide that this is what will end up in the package.</p> <p>A slightly more complex example with a namespace that hosts several functions:</p> <pre><code>/Goo/\n     APLSource/\n               Admin/\n               ...\n               TestCases/\n               ...\n               Goo/\n                  Function1.aplf\n                  Function2.aplf\n     cider.config\n     apl-package.json\n     README.md\n</code></pre> <p>In this case, the <code>source</code> in the package could become <code>APLSource/Goo</code> because<code>Admin</code> and <code>TestCases</code> do not have to be part of the package.</p>"},{"location":"original/packageconfiguration/#tags","title":"tags","text":"<p>A simple text vector with a comma-separated list of tags (keywords). These can be helpful to filter packages when searching for a solution to a particular problem.</p> <p><code>tags</code> must not be empty if you wish to publish a package to a Tatin server because such a package would not be accepted by the server.</p> <p>Tags should only be related to the problems one can solve with a particular package. There is no need to specify the platform since they have their own properties: <code>os_lin</code>, <code>os_mac</code>, <code>os_win</code>. Those got introduced with version 0.81.0.</p> <p>There is also no point in adding tags like \"dyalog\" or \"apl\" to a package: Tatin is a Dyalog APL package manager...</p> <p>Note that people in charge of the principal Tatin server will have an eye on the tags, and might silently correct them to keep them consistent and meaningful.</p>"},{"location":"original/packageconfiguration/#tatin_version","title":"tatin_version","text":"<p>The Tatin version number without any build ID the config data was created / changed by.</p> <p>You should not edit this because it is overwritten before saving the data anyway.</p>"},{"location":"original/packageconfiguration/#usercommandscript","title":"userCommandScript","text":"<p>If a package is a user command then this must contain the path to the user command script relative to the projects root. <code>InstallPackages</code> uses this to identify a user command script and to move it from the source folder (if any) to the root of the install folder.</p> <p>This optional property was introduced with version 0.86.0. It might not exist in older versions of a package. If it does not exist then Tatin assumes that the package in question is not a user command.</p> <p>Note that for a package to be a user command, the package must be constructed in a particular way. This is discussed in the \"Publishing Packages\" document.</p>"},{"location":"original/packageconfiguration/#version","title":"version","text":"<p>The \"version\"<sup>2</sup> part of the package ID<sup>1</sup></p> <p>Examples of valid version numbers are:</p> <pre><code>1.2.3\n1.2.3-beta1\n1.2.3-beta1+30164\n18.0.0+30165\n</code></pre> <p>The optional build number, separated by the <code>+</code> sign, is ignored by Tatin.</p> <p>For details see the Tatin and Semantic Versioning document. </p>"},{"location":"original/packageconfiguration/#SysVars","title":"APL System variables: \u2395IO and \u2395ML","text":"<p>By default the package configuration file carries the values of the two Dyalog parameters (environment variables) <code>Default_IO</code> and <code>Default_ML</code> for the system variables <code>\u2395IO</code> and <code>\u2395ML</code>, or, if these are not defined, <code>\u2395IO\u21901</code> and <code>\u2395ML\u21901</code> which are the built-in defaults. </p> <p>Tatin uses these values for setting the system variables accordingly in any namespace that is created by either the <code>LoadPackages</code> or the <code>LoadDependencies</code> function before any code is loaded into them. This is important because that makes any sub-namespace created later on inherit those values.</p> <p>If you are tempted to create files names <code>\u2395IO.apla</code> and <code>\u2395ML.apla</code> and leave it to Link to use them in order to set <code>\u2395IO</code> and <code>\u2395ML</code>. Although that would work, for packages your are strongly advised to not do this.</p> <p>See exclude for details.</p>"},{"location":"original/packageconfiguration/#injected-values","title":"Injected values","text":""},{"location":"original/packageconfiguration/#date","title":"date","text":"<p>The user must not specify \"date\", but when a package is published, the server will inject \"date\" as a timestamp in the format <code>yyyymmdd.hhmmss</code>. </p> <p>This date might play an important role in determining the precedence of versions. This is because although it's obvious which version is \"better\" when you look at these two packages:</p> <pre><code>group-name-1.0.0\ngroup-name-1.1.0\n</code></pre> <p>it is less obvious when you look at these:</p> <pre><code>group-name-1.0.0-alpha\ngroup-name-1.1.0-beta\n</code></pre> <p>and it cannot be determined at all with these packages:</p> <pre><code>group-name-1.0.0-TryFeature1\ngroup-name-1.1.0-FixFor234\n</code></pre> <p>Since packages, once published, cannot be altered, it is safe to assume that the publishing date determines the correct order. However, as long as the version consists of just digits and dots, and possibly a build number, <code>date</code> does not play a role in determining precedence.</p>"},{"location":"original/packageconfiguration/#url","title":"url","text":"<ul> <li> <p>When a package is loaded or installed from a Tatin Server, \"url\" is injected and points back to that server.</p> </li> <li> <p>When a package is loaded or installed from a file, \"url\" is injected and points to that file.</p> </li> </ul>"},{"location":"original/packageconfiguration/#misc","title":"Misc","text":""},{"location":"original/packageconfiguration/#getfullpath2assetsfolder","title":"GetFullPath2AssetsFolder","text":"<p>In case <code>assets</code> is not empty this function returns a simple char vector that represents the full path to the assets, using something like:</p> <pre><code>  HOME,'/',ASSETS\n</code></pre> <ul> <li>If <code>HOME</code> is empty the function returns just <code>ASSETS</code></li> <li>If <code>ASSETS</code> is empty the functions returns <code>''</code></li> <li>If <code>HOME</code> is not empty but does not exist on disk just <code>ASSETS</code> is returned</li> </ul> <ol> <li> <p>A package ID consists of <code>{group}-{name}-{major}.{minor}.{patch}</code> \u21a9\u21a9\u21a9</p> </li> <li> <p>A version is built from the major number, the minor number and the version number, optionally followed by a build number\u00a0\u21a9</p> </li> <li> <p>The Tatin package variables are discussed in detail in the document <code>FirstStepsWithTatin.html</code> \u21a9</p> </li> </ol>"},{"location":"original/publishingpackages/","title":"Publishing Packages","text":""},{"location":"original/publishingpackages/#licensing","title":"Licensing","text":""},{"location":"original/publishingpackages/#httpstatindev","title":"https://tatin.dev","text":"<p>If you want to publish packages to the Principal Tatin server (https://tatin.dev) then your package must carry a property <code>license</code>, and its value  must be one of the licenses listed on the web page. All licenses that will be accepted offer a great deal of freedom to a user of a package: there are almost no restrictions.</p> <p>Note that the same holds true for the test server (https://test.tatin.dev)</p>"},{"location":"original/publishingpackages/#your-own-server","title":"Your own server","text":"<p>If you want to run your own server then you can do whatever you like, of course. The document  \"Server --- Tips and Tricks\" offers details.</p>"},{"location":"original/publishingpackages/#groups-names-and-version-numbers","title":"Groups, names and version numbers","text":"<p>A package ID consists of at least three parts:</p> <ul> <li>A group name</li> <li>A package name</li> <li>A version number</li> </ul> <p>Optionally such an ID may also comprehend a build number that is separated from the version number by a plus (<code>+</code>).</p>"},{"location":"original/publishingpackages/#the-group","title":"The Group","text":"<p>A group can be anything really:</p> <ul> <li>If you act on behalf of a company it might be the name of that company, like \"Dyalog\"</li> <li>If you are a freelancer it might be your name, or just your first name, like \"davin\"</li> <li>It might be a term used to indicate something, anything, like \"aplteam\"</li> </ul> <p>Once you have chosen a group name, and published a package with that group name to the principal Tatin Registry, you are advised to create a \"home page\" for that group. Use that for anything useful like background, motivation, contact details, whatever.</p> <p>When a group is listed in a browser, the name of a group is converted into a link to that home page.</p> <p>Of course, group-related home pages do not always make sense, therefore by default they are not active; see <code>GroupHomePages</code> in the INI file.</p>"},{"location":"original/publishingpackages/#the-name","title":"The name","text":"<p>The name should give the user an idea of what a package might do. Group+name must be unique, but you might well use a name that is already used under a different group name, though this is not recommended.</p>"},{"location":"original/publishingpackages/#the-version-number","title":"The version number","text":"<p>The version number must consist of three parts separated by dots:</p> <ul> <li>The major version number: the \"1\" in 1.2.3</li> <li>The minor version number: the \"2\" in 1.2.3</li> <li>The patch number: the \"3\" in 1.2.3</li> </ul> <p>Optionally additional information might be added. Examples are:</p> <ul> <li>1.2.3-beta-1</li> <li>1.2.3-fix-for-the-foo-problem</li> <li>1.2.3-issue-234</li> </ul> <p>There is one restriction: a <code>+</code> cannot be part of the name of a beta version. The reason for that is that finally a build number might be added to a version number, and a build number is separated from the rest of the version number by a plus (<code>+</code>) character. Examples:</p> <ul> <li>1.2.3+453</li> <li>1.2.3-beta-1+911</li> </ul> <p>Build numbers are mostly not shown by Tatin.</p> <p>Build numbers are ignored by Tatin. Their sole purpose is to tell two different builds apart when the version number has not changed.</p>"},{"location":"original/publishingpackages/#precondition-api-key","title":"Precondition: API key","text":"<p>Whether you want to publish to the principal Tatin server at https://tatin.dev or your own Tatin Server or a Tatin Server that someone in your company runs, first you need an API key. \"API key\" is just a fancy expression for a password that is used by an application.</p> <p>API keys are required for publishing --- and possibly deleting --- packages, but not for consuming them.</p> <p>They are saved in the user settings --- for details see the document \"Tatin User Settings\".</p>"},{"location":"original/publishingpackages/#the-server","title":"The Server","text":""},{"location":"original/publishingpackages/#the-principal-tatin-server","title":"The principal Tatin Server","text":"<p>If you want to publish on <code>https://tatin.dev</code> you need to ask info@tatin.dev for an API key.</p> <p>You must provide these pieces of information:</p> <ul> <li>Your desired group name (case insensitive)</li> <li>Your real name</li> <li>If it's connected to a company, the company's name</li> <li>Email address (if different from the one you are using to send the email)</li> </ul> <p>!&gt; ### First step after receiving an API key =&gt; After having received an API key you must first create a home page for your group name on the server. Only then can you start publishing packages.</p>"},{"location":"original/publishingpackages/#credentials-for-the-tatin-test-server","title":"Credentials for the Tatin Test Server","text":"<p>The Tatin Test Server publishes an API key on its website; it's \"Tatin-Test-API-Key\". It allows you to publish anything you want, including any group name except a few reserved group names: \"aplteam\" and \"dyalog\".</p> <p>Notes:</p> <ul> <li>Be aware that the Tatin Test Server is reset now and then, so whatever you publish will disappear sooner or later</li> <li>You cannot publish anything under the group names \"aplteam\" and \"dyalog\"</li> </ul>"},{"location":"original/publishingpackages/#where-are-api-keys-saved","title":"Where are API keys saved?","text":""},{"location":"original/publishingpackages/#client","title":"Client","text":"<p>API keys are saved in the user settings file. The quickest and yet safe way to edit that file is via the user command:</p> <pre><code>      ]TatIN.UserSettings -edit      \n</code></pre>"},{"location":"original/publishingpackages/#server","title":"Server","text":"<p>Credentials are saved in the file \"Credentials.csv\" in the Registry's home folder.</p>"},{"location":"original/publishingpackages/#credentials-for-your-own-tatin-server","title":"Credentials for your own Tatin Server","text":"<p>If you run your own Tatin Server, we suggest that you create a UUID and use that as an API key. </p> <p>For an API key to be accepted by a Tatin Server, it must be added to a file <code>Credentials.txt</code> in the Registry's root directory. </p> <p>Make sure that you specify it as either</p> <pre><code>&lt;group-name&gt;,&lt;api-key&gt;\n</code></pre> <p>or</p> <pre><code>*,&lt;api-key&gt;\n</code></pre> <p>If the server finds such a file it will perform the following actions:</p> <ul> <li>Take the data and convert it to a different format</li> <li>Delete rows from <code>Credential.csv</code> that share a group name with <code>Credentials.txt</code></li> <li>Create a Salt for every API key in <code>Credentials.txt</code></li> <li>Convert every API-key and its Salt into a hash and add them together with the according group name to <code>Credentials.csv</code></li> <li>Delete the file <code>Credentials.txt</code></li> </ul> <p>The format of the file <code>Credentials.csv</code> is:</p> <pre><code>&lt;group-name&gt;,&lt;api-key-hash&gt;,&lt;salt&gt;\n*,&lt;api-key-hash&gt;,&lt;salt&gt;\n*\n</code></pre> <ul> <li>In the first case, anybody who provides the API key the hash was produced from can publish packages for that group.</li> <li>In the second case, the password the hash was created from is a kind of master password: it allows the creation of packages with any group name, except any group that was already handled by then of course.</li> <li>The third case means that no API key is required for any (remaining) group(s).</li> </ul> <p>The different scenarios can be mixed:</p> <pre><code>group1,&lt;hash1,&lt;salt1&gt;\ngroup2,&lt;hash2,&lt;salt2&gt;\n*,{hash3&gt;,&lt;salt3&gt;\n</code></pre> <p>This means that one can only publish packages with the group name...</p> <ul> <li><code>&lt;group1&gt;</code> by using the API key \"hash1\" was generated from...</li> <li><code>&lt;group2&gt;</code> by using the API key \"hash2\" was generated from...</li> </ul> <p>and anything else by using the API key \"hash3\" was created from.</p> <p>Note that <code>*</code> or<code>*,</code> or <code>*=</code> all mean that no API key is required. On its own, it's the same as having no credentials file, but it can be useful together with other group names:</p> <pre><code>&lt;group1&gt;,&lt;hash1&gt;\n&lt;group2&gt;,&lt;hash2&gt;\n*\n</code></pre> <p>This is interpreted as \"require API keys for the groups <code>&lt;group1&gt;</code> and <code>&lt;group2&gt;</code> but allow anything else without an API key\".</p> <p>Finally, you can allow anybody to publish packages under a particular group name without providing an API key:</p> <pre><code>&lt;group1&gt;,&lt;hash1&gt;,&lt;email-address&gt;\n&lt;group2&gt;,\n*,&lt;hash3&gt;\n</code></pre> <p>This means:</p> <ul> <li> <p>In order to publish anything to the group \"group1\" you must provide the API key \"hash1\" was generated from</p> </li> <li> <p>You may publish packages to the group \"group2\" without an API key </p> </li> <li> <p>For any group name but <code>&lt;group1&gt;</code> and <code>&lt;group2&gt;</code> you must specify the API key \"hash3\" was generated from</p> </li> </ul>"},{"location":"original/publishingpackages/#editing-the-file-credentialscsv","title":"Editing the file \"Credentials.csv\"","text":"<p>There is one reason why you might need to change the file <code>Credentials.csv</code>: when a group name must be deleted for some reason.</p> <p>If a new group needs to be added, or a new API key needs to be assigned to an existing group, you must create a file <code>Credentials.txt</code>, see above.</p>"},{"location":"original/publishingpackages/#comments","title":"Comments","text":"<p>The files <code>Credentials.txt</code> as well as <code>Credentials.csv</code> both allow comment lines: any line that has a <code>;</code> as the very first character is regarded a comment.</p>"},{"location":"original/publishingpackages/#publishing","title":"Publishing","text":""},{"location":"original/publishingpackages/#preparing","title":"Preparing","text":""},{"location":"original/publishingpackages/#how-to-structure-a-package","title":"How to structure a package","text":"<p>A Tatin package requires all source code (functions, operators, classes, interfaces and namespace scripts) to be separated from other files (like CSS files, EXEs, DLLs etc.).</p> <p>Tatin calls the former \"source\" and the latter \"assets\". </p>"},{"location":"original/publishingpackages/#the-package-configuration-file","title":"The package configuration file","text":"<p>The file <code>apl-package.json</code> must exist in order to make a folder a package.</p> <p>What is required and how to create and change a package configuration file is discussed in the document PackageConfiguration.</p>"},{"location":"original/publishingpackages/#the-dependency-file","title":"The dependency file","text":"<p>The file <code>apl-dependencies.txt</code> is only required when a package depends on other packages.</p> <p>Dependencies may by installed in a package project in different ways:</p> <ul> <li> <p>By default Tatin assumes a subfolder <code>packages/</code> to save dependencies.</p> </li> <li> <p>If you manage a package project with Cider, then Tatin will check the properties <code>dependencies.tatin</code> and <code>dependencies_dev.tatin</code>: if one of them or both define a folder then it will be taken</p> </li> <li> <p>If you do not use Cider and prefer a subfolder not named <code>packages/</code> for any dependencies, then you must specify them explicitly:</p> </li> <li> <p>The user command <code>]Tatin.PublishPackage</code> has a modifier for this: <code>-dependencies=</code></p> </li> <li>The API function <code>PublishPackage</code> can be fed with an optional left argument for this</li> </ul> <p>I&gt; In case you specify a dependency that has not (yet) been published, then this has no consequences: the server will not reject such a package.  I&gt; I&gt; That might come as a surprise, but there is a reason for this: when a bunch of packages is published then there might well be mutual or worse circular dependencies. Insisting on dependencies already being published would not work then.</p> <p>Usually, you will specify just a full package ID as a dependency. If you wish you may also specify either a URL following the http[s]:// protocol or a zip file following the file:// protocol. The latter is always a temporary solution, however. </p> <p>Notes:</p> <ul> <li>Specifying a dependency with the file:// protocol means that you won't be able to publish that package to a Tatin server because it would for obvious reasons be rejected with \"400 --- bad request\".</li> </ul> <p>That is good enough a reason to use this with care. Only when messing around with packages on your local machine that are not designed to be published on a Tatin server may this be used.</p> <ul> <li> <p>Using the http[s]:// protocol defeats Tatin's scan strategy: normally when a dependency is required Tatin will scan all defined Registries by their priority, unless the http[s]:// protocol is used. Again this should be used with care.</p> </li> <li> <p>When a package is published to a Tatin Registry, any protocols (file:// or http:// or https://) are removed: the dependency is defined just by the package name. </p> </li> </ul> <p>When such a package is installed or loaded, Tatin will interrogate all Registries in its search path, with the first hit winning the day.</p>"},{"location":"original/publishingpackages/#final-step","title":"Final step","text":"<p>Once the preparation is done the final step is easy. Specify the folder hosting the package:</p> <pre><code>]TATIN.PublishPackage /path2package [tatin]\n</code></pre> <p>The folder may or may not carry a trailing slash (<code>/</code>).</p> <p>This would attempt to publish the package found in <code>path2package/</code> to the principal Tatin Server. (In fact, <code>[tatin]</code> is optional: without a second argument the principal Registry would be assumed anyway)</p> <p>You can also build a new version by calling <code>]TATIN.BuildPackage</code> (or its aquivalent, the API-function <code>BuildPackage</code>) and specify the resulting ZIP file as an argument to <code>PublishPackage</code>:</p> <pre><code>]TATIN.PublishPackage /path2package/group-name-1.2.3.zip [tatin]\n</code></pre> <p>When a path to a package project is provided rather than a ZIP file then <code>]PublishProject</code> would create the ZIP file itself.</p> <p>Note that both <code>]PublishPackage</code> as well as <code>]BuildPackage</code> assume that if the package about to be published depends on other packages these packages will be installed in a subfolder <code>packages/</code>.</p> <p>However, if the project is managed by Cider then Tatin investigates the Cider config file. Cider has two properties <code>dependencies.tatin</code> and <code>dependencies_dev.tatin</code> designed to hold the folder with package dependencies, and if one of them is not empty then Tatin would use it, or question the user if both are set and not empty.</p> <p>If you do not use Cider but want to establish a non-default subfolder (read: not named <code>packages/</code>) as the one holding package dependencies then you must specify the subfolder with the <code>-dependencies=</code> flag.</p>"},{"location":"original/publishingpackages/#user-command-packages","title":"User command packages","text":"<p>Packages that are user commands are a special case. Here is why:</p> <p>User commands must have a user command script --- that's what makes them a user command. They can simply be installed as Tatin packages and the job is done. But there is a problem.</p> <p>The package might look like this:</p> <pre><code>MyUserCommand/\n    APLSource/\n        MyUserCommand/        \u235d Contains the code\n        TestData/\n        TestCases/\n        MyUserCommand.dyalog  \u235d The user command script\n    packages/\n        ...\n    packages_dev/\n        ...\n    apl-package.json\n    cider.config\n    LICENSE\n    README\n</code></pre> <p>The package configuration parameter <code>source</code> will then read <code>APLSource/MyUserCommand</code> because we don't want <code>TestData/</code> and <code>TestCases/</code> to be part of the installed package.</p> <p>But that would mean that the script <code>MyUserCommand.dyalog</code> would not be installed either, so there is a problem: the script would not make it when the packages are installed. Also, the user command script should live in the root of the package's installation folder, not in a sub folder.</p> <p>That's why Tatin needs to know that the package is a user command, and where to find its script. This does the trick:</p> <pre><code>userCommandScript: \"APLSource/MyUserCommand.dyalog\",\n</code></pre> <p>The fact that the parameter exists and is not empty tells Tatin that it is a user command, and the path allows Tatin to first install everything as usual and then move the script to the root of the package installation folder.</p> <p>The installed package will then consist of:</p> <ul> <li>A folder for the <code>MyUserCommand</code> package </li> <li>Folders for all dependencies </li> <li>A file <code>apl-buildlist.json</code></li> <li>A file <code>apl-dependencies.txt</code></li> <li>The user command script: <code>MyUserCommand.dyalog</code></li> </ul> <p>Note that by definition a package must contain some code. If a user command is implemented as a single script file, which is possible and perfectly fine with simple user commands, this would not be the case. For this reason, it is advisable to separate the user command as such (with the necessary <code>Run</code>, <code>List</code> and <code>Help</code> functions) from the \"business logic\" that does the real work.</p> <p>The latter one would remain in the package, fulfilling the requirement.</p>"},{"location":"original/publishingpackages/#deleting-packages","title":"Deleting packages","text":"<p>Whether you can delete a package once it was published depends on the policy the server operates:</p> <ul> <li>\"Any\": You may delete any package</li> <li>\"JustBetas\": You may delete only beta versions</li> <li>\"None\": You cannot delete any packages at all</li> </ul> <p>Note that anything that carries something that is not a digit after the second dot in the version number and before the build separator \"<code>+</code>\" qualifies as a beta version.</p> <p>Examples:</p> <pre><code>apltree-Foo-1.0.0                 \u235d Not a beta\napltree-Foo-1.0.0+123             \u235d Not a beta\napltree-Foo-1.0.0-alpha-1         \u235d A beta\napltree-Foo-1.0.0-alpha-1+123     \u235d A beta\n</code></pre> <p>You can find out which policy the server operates in two ways:</p> <ul> <li>Execute this user command:</li> </ul> <pre><code>]Tatin.GetDeletePolicy [tatin]\nNone\n</code></pre> <p>Or visit its website, for example, https://tatin.dev: at the bottom of the home page the server mentions the \"delete\" policy it operates.</p>"},{"location":"original/publishingpackages/#development-strategies","title":"Development strategies","text":"<p>Let's imagine that you are supposed to develop Tatin packages for your employer, the company \"XYZ\".</p> <ul> <li>You run a Tatin server on your local machine, known by the alias <code>[my]</code>.</li> </ul> <p>This is just for you, nobody else. The purpose of this server is to publish packages to it at a very early stage.</p> <p>It has the highest priority of all Registries, ensuring that in case a package lives on several Registries it is found on <code>[my]</code> first.</p> <ul> <li>Your team runs a Tatin Server on the Intranet of your company. It carries the alias <code>[my-team]</code>.</li> </ul> <p>This is used to publish beta versions that your team might want to use. This has the second-highest priority.</p> <ul> <li> <p>Your company also runs a Tatin Server used for productive packages.</p> </li> <li> <p>Your packages may depend on packages published on Tatin's principal server, known as <code>[tatin]</code>.</p> </li> </ul> <p>Of the four Registries, this one should have the lowest priority.</p> <ul> <li>You might also have the test Registry defined in your user settings, but with a priority of <code>0</code> so that it will be ignored when Registries are scanned for packages, but you could still use it.</li> </ul> <p>You can now develop a package <code>Foo</code> and publish it on <code>[my]</code>, probably several times until it is stable.</p> <p>You would then publish it on <code>[my-team]</code>. At the same time, you would either delete the package from <code>[my]</code> or, if you want the Registry <code>[my]</code> to be ignored altogether, set its priority to zero.</p> <p>When all is good the beta is promoted to an official release and published to the Tatin company server. At the same time, the package will most likely be deleted from the Team server.</p>"},{"location":"original/releasenotes/","title":"Release Notes","text":"<p>Tatin release notes contain information regarding actions that need to be executed before a new version can be used, or outstandingly important pieces of information.</p> <p>This document does not come with a complete list of fixes, added features etc. Consult Tatin on GitHub for that.</p>"},{"location":"original/releasenotes/#version-01200-from-2025-05-03","title":"Version 0.120.0 from 2025-05-03","text":"<ul> <li><code>LoadPackages</code> now throws an error when one of the packages specified cannot be found. No package is loaded.</li> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01190-from-2025-03-12","title":"Version 0.119.0 from 2025-03-12","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01182-from-2025-02-03","title":"Version 0.118.2 from 2025-02-03","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01181-from-2025-01-14","title":"Version 0.118.1 from 2025-01-14","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01180-from-2024-12-30","title":"Version 0.118.0 from 2024-12-30","text":"<ul> <li>The API function <code>BuildPackage</code> does not process a property <code>tatinVars</code> anymore; if it is fed one anyway, it will throw an error.</li> <li>The function <code>CreateBuildParms</code> does not contain a variable <code>tatinVars</code> anymore but a variable <code>projectspace</code> which is optional. You may set it to the namespace where the package project lives. That enables <code>BuildPackage</code> to update <code>TatinVars.CONFIG</code> in that namespace, otherwise <code>BuildPackage</code> don't know where to look.</li> <li>Accordingly the option <code>-tatinVars=</code> was removed from the <code>]BuildPackage</code> user command but the option <code>-projectspace=</code> was introduced.</li> <li>The user command <code>]ReInstallDependencies</code> now accepts a flag <code>-recursive</code>.</li> </ul> <p>This can be put to use with a folder that contains multiple independent packages, for example the folder <code>[MyUCMDs]</code>: all installed packages in that folder can be re-installed and (in this instance) updated without user interaction with the following statement.</p> <pre><code>]ReInstallDependencies [MyUCMDs] -recursive -update -force\n</code></pre>"},{"location":"original/releasenotes/#version-01170-from-2024-12-08","title":"Version 0.117.0 from 2024-12-08","text":"<ul> <li>The way build numbers are processed has changed: prior to 0.117.0 when a complete version number --- including a build number ---  was passed on to <code>]BuildPackage</code> the build number was not bumped. Now it is bumped.</li> </ul>"},{"location":"original/releasenotes/#version-01160-from-2024-11-30","title":"Version 0.116.0 from 2024-11-30","text":"<ul> <li>Tatin now requires at least 18.2: 18.0 is not supported any longer.</li> </ul>"},{"location":"original/releasenotes/#version-01153-from-2024-11-25","title":"Version 0.115.3 from 2024-11-25","text":"<ul> <li>Fixes a gaping security hole (Server only, group home page)</li> </ul>"},{"location":"original/releasenotes/#version-01152-from-2024-11-16","title":"Version 0.115.2 from 2024-11-16","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01151-from-2024-11-15","title":"Version 0.115.1 from 2024-11-15","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01150-from-2024-10-14","title":"Version 0.115.0 from 2024-10-14","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01140-from-2024-09-30","title":"Version 0.114.0 from 2024-09-30","text":"<p>In case you are on Windows and you are using OneDrive then you might need to pay attention. </p> <p>Older versions of Tatin did not cooperate with OneDrive; this can potentially cause problems. A new document, \"Tatin and OneDrive,\" discusses this issue. If you use OneDrive, read it!</p> <p>Otherwise no action is required, but be aware of changes made to <code>]ListVersions</code>: if no argument is provided it checks on open Cider projects now. In other words, it became more powerful.</p>"},{"location":"original/releasenotes/#version-01131-from-2024-09-08","title":"Version 0.113.1 from 2024-09-08","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01130-from-2024-09-05","title":"Version 0.113.0 from 2024-09-05","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01121-from-2024-08-16","title":"Version 0.112.1 from 2024-08-16","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01120-from-2024-07-14","title":"Version 0.112.0 from 2024-07-14","text":"<ul> <li> <p>The <code>]CopyRegistry</code> user command, introduced in 0.110.0, got a changed syntax:</p> </li> <li> <p>The <code>-full</code> flag was removed</p> </li> <li> <p>Default behaviour is now what was so far achievable with <code>-full</code> except that deprecated packages are now copied as well</p> <p>This is a necessity for compatability, because some package might well depend on an earlier version of a now deprecated package.   * With <code>-dry</code> one might omit both arguments, meaning that the URL defaults to <code>[tatin]</code> while no path is required   * The list of copied packages is now returned as a matrix</p> </li> </ul>"},{"location":"original/releasenotes/#version-01110-from-2024-07-12","title":"Version 0.111.0 from 2024-07-12","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01100-from-2024-07-09","title":"Version 0.110.0 from 2024-07-09","text":"<ul> <li>A maintenance file \"2024-07-07-Inject-Exclude.aplf\" was introduced. </li> </ul> <p>It allows to add the new \"exclude\" property (introduced with version 0.109.0) to be introduced into all saved packages as an empty text vector.</p> <p>You don't have to run this maintenance function on all your packages (Tatin deals with both a defined \"exclude\" as well as an absent \"exclude\") but it is better for future use when this is part of all packages.</p>"},{"location":"original/releasenotes/#version-01090-from-2024-06-27","title":"Version 0.109.0 from 2024-06-27","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01081-from-2024-05-04","title":"Version 0.108.1 from 2024-05-04","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01080-from-2024-05-02","title":"Version 0.108.0 from 2024-05-02","text":"<ul> <li>You must update your client to 0.108.0 for correct results --- prior versions are incompatible with 0.108.0!</li> </ul>"},{"location":"original/releasenotes/#version-01070-from-2024-04-04","title":"Version 0.107.0 from 2024-04-04","text":"<ul> <li>The syntax of the API function <code>DeletePackages</code> has changed.</li> </ul>"},{"location":"original/releasenotes/#version-01062-from-2024-03-27","title":"Version 0.106.2 from 2024-03-27","text":"<ul> <li>Action is required with version 18.2 and/or 18.0</li> </ul> <p>With this version the Tatin user commands won't be available in the session until you either execute <code>]UReset</code> yourself, or you add the following code to your <code>setup.dyalog</code> in <code>MyUCMDs/</code>:</p> <pre><code>:If ~IfAtLeastVersion 19\n    {}\u2395SE.SALTUtils.ResetUCMDcache -1                 \n:EndIf\n</code></pre>"},{"location":"original/releasenotes/#version-01061-from-2024-03-18","title":"Version 0.106.1 from 2024-03-18","text":"<ul> <li>No action required when running Tatin. </li> </ul>"},{"location":"original/releasenotes/#version-01060-from-2024-03-12","title":"Version 0.106.0 from 2024-03-12","text":"<ul> <li>No action required when running Tatin. </li> </ul> <p>However, when developing (contributing to) Tatin there is a significant change: read \"Special case: working on user commands\" in the \"Tatin for Contributors\" document for details.</p>"},{"location":"original/releasenotes/#version-01050-from-2024-03-02","title":"Version 0.105.0 from 2024-03-02","text":"<p>Potentially breaking changes: </p> <ul> <li>The function <code>DeletePackage</code> was renamed: <code>DeletePackages</code></li> <li>The user command <code>]DeletePackage</code> was renamed: <code>]DeletePackages</code></li> </ul>"},{"location":"original/releasenotes/#version-01041-from-2024-01-28","title":"Version 0.104.1 from 2024-01-28","text":"<ul> <li>The client requires a server on 0.104.1 as well</li> </ul>"},{"location":"original/releasenotes/#version-01040-from-2024-01-22","title":"Version 0.104.0 from 2024-01-22","text":"<ul> <li>The result of both <code>]ListRegistries</code> and the corresponding API function return a different (extended) result now.</li> </ul> <p>This implies that older versions of Tatin than 0.104.0 are incompatible with this new version, therefore you are forced to update.</p> <p>Apart from the update no action is required.</p>"},{"location":"original/releasenotes/#version-01032-from-2024-01-16","title":"Version 0.103.2 from 2024-01-16","text":"<ul> <li>No action required.</li> </ul>"},{"location":"original/releasenotes/#version-01031-from-2023-12-14","title":"Version 0.103.1 from 2023-12-14","text":"<ul> <li>No action required.</li> </ul>"},{"location":"original/releasenotes/#version-01030-from-2023-11-04","title":"Version 0.103.0 from 2023-11-04","text":"<ul> <li>No action required but note that the result of the API function <code>LoadPackages</code> has changed.</li> </ul>"},{"location":"original/releasenotes/#version-01023-from-2023-10-13","title":"Version 0.102.3 from 2023-10-13","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01022-from-2023-10-09","title":"Version 0.102.2 from 2023-10-09","text":"<ul> <li>No action required</li> </ul>"},{"location":"original/releasenotes/#version-01021-from-2023-10-07","title":"Version 0.102.1 from 2023-10-07","text":"<ul> <li>Most importantly, a bug fix in <code>]Tatin.CiderUpdate</code></li> </ul>"},{"location":"original/releasenotes/#version-01020-from-2023-10-04","title":"Version 0.102.0 from 2023-10-04","text":"<ul> <li>Most importantly, a revised install procedure</li> </ul>"},{"location":"original/releasenotes/#version-01012-from-2023-09-30","title":"Version 0.101.2 from 2023-09-30","text":"<ul> <li>Very important bug fix in <code>UnInstallPackages</code></li> </ul>"},{"location":"original/releasenotes/#version-01011-from-2023-09-26","title":"Version 0.101.1 from 2023-09-26","text":"<p>Two massive changes:</p> <ul> <li> <p>This version is only compatible with Cider 0.36.0 or later</p> </li> <li> <p>The installation folder is not <code>MyUCMDs/</code> anymore. However, <code>]Tatin.UpdateTatin</code> of your old version cannot know about this, therefore you have to take action once in order to get Tatin into the right folder. </p> </li> </ul> <p>See the \"InstallingAndUpdatingTheTatinClient.html\" document for details.</p> <ul> <li>Note that in the future <code>]Tatin.UpdateTatin</code> will use the new installation folder </li> </ul>"},{"location":"original/releasenotes/#version-01002-from-2023-09-23","title":"Version 0.100.2 from 2023-09-23","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-01001-from-2023-08-28","title":"Version 0.100.1 from 2023-08-28","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-01000-from-2023-08-27","title":"Version 0.100.0 from 2023-08-27","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0991-from-2023-08-05","title":"Version 0.99.1 from 2023-08-05","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0990-from-2023-08-02","title":"Version 0.99.0 from 2023-08-02","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0982-from-2023-07-14","title":"Version 0.98.2 from 2023-07-14","text":"<p>This release addresses a bug in the server; the client has not been changed.</p> <p>Update only required if you run a server.</p>"},{"location":"original/releasenotes/#version-0981-from-2023-07-13","title":"Version 0.98.1 from 2023-07-13","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0980-from-2023-07-05","title":"Version 0.98.0 from 2023-07-05","text":"<ul> <li> <p>No breaking changes for the Tatin client, therefore there are no user actions required</p> </li> <li> <p>If you run a Tatin server you don't need to take action but you should be aware of a major change</p> </li> </ul> <p>Before version 0.98.0 credentials got stored in a file <code>Credentials.txt</code>. The format was:</p> <pre><code>&lt;group&gt;=&lt;api-key&gt;\n</code></pre> <p>The API-keys were stored as clear text. We don't want that anymore.</p> <p>With version 0.98.0 credentials will be stored in a file <code>Credentials.csv</code>. The format is different:</p> <pre><code>&lt;group&gt;,&lt;api-key-hash&gt;,&lt;Salt&gt;\n</code></pre> <p>The server will convert <code>Credentials.txt</code> automatically into <code>Credentials.csv</code>. Afterwards there is a new file <code>Credentials.csv</code> while the old file <code>Credentials.txt</code> will be deleted.</p> <p>Note that you might create at a later stage a new file <code>Credentials.txt</code> with entries like</p> <pre><code>&lt;group-name&gt;=&lt;api-key&gt;\n</code></pre> <p>or</p> <pre><code>&lt;group-name&gt;,&lt;api-key&gt;\n</code></pre> <p>That allows you to add new groups, or overwrite existing ones, for example when somebody lost the API-key.</p> <p>The server will perform the following actions:</p> <ul> <li>Take the data and convert it</li> <li>Delete rows from <code>Credentials.csv</code> that are also contained in <code>Credentials.txt</code> (same group name)</li> <li>Add the data to <code>Credentials.csv</code> </li> <li>Delete <code>Credentials.txt</code></li> </ul>"},{"location":"original/releasenotes/#version-0971-from-2023-06-30","title":"Version 0.97.1 from 2023-06-30","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0970-from-2023-06-14","title":"Version 0.97.0 from 2023-06-14","text":"<p>This version comes with several breaking changes:</p> <ul> <li>The <code>]FindDependencies</code> user command's <code>-detailed</code> property has been renamed to <code>verbose</code></li> <li>The API function <code>FindDependencies</code> has a changed syntax and returns a changed result.</li> </ul>"},{"location":"original/releasenotes/#version-0962-from-2023-06-08","title":"Version 0.96.2 from 2023-06-08","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0961-from-2023-05-21","title":"Version 0.96.1 from 2023-05-21","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/releasenotes/#version-0960-from-2023-05-18","title":"Version 0.96.0 from 2023-05-18","text":"<p>No breaking changes, no user actions required.</p>"},{"location":"original/rundyalogbehindapache/","title":"Run Dyalog behind Apache","text":"<p>With Dyalog's Conga, Rumba or Plodder  you might well decide to serve HTTP requests with an application written in Dyalog  APL.</p> <p>However, if your application serves requests from the Internet (as opposed to an Intranet), it is strongly recommended to hide your application behind an industrial-strength web server like Apache.</p> <p>This comes not only with benefits in terms of security, and stronger defences against something like DDOS attacks, it also offers an easy way to implement load balancing.</p> <p>Apache can be used this way because it can act as a reverse proxy server, sometimes called a gateway server. </p> <p>Let's assume that your application is listening on port 8081.</p> <p>You need to add the following lines to the configuration file for your specific website:</p> <pre><code>ProxyPreserveHost on\nProxyPass / http://localhost:8081/\nProxyPassReverse / http://localhost:8081/\n</code></pre> <p>This file is typically found in <code>/etc/apache2/sites-available</code>.</p> <p>In <code>/etc/apache2/sites-enabled</code> there should be just a link pointing to <code>/etc/apache2/sites-available</code>.</p> <p>The <code>ProxyPass</code> directive is doing the magic.</p> <p>The <code>ProxyPassReverse</code> directive ensures that the <code>Location:</code> headers generated from the backend (your Tatin Server) are modified to point to the reverse proxy instead of itself.</p> <p>For details see the \"Reverse Proxy Guide\" and Apache Module mod_proxy</p>"},{"location":"original/semanticversioning/","title":"Tatin and Semantic Versioning","text":"<p>Tatin is based on the concept of Semantic Versioning (SemVer), so before we go into any details, we first need to understand SemVer. </p> <p>If you are already familiar with the concept of semantic versioning then of course you may skip this document.</p>"},{"location":"original/semanticversioning/#format","title":"Format","text":"<p>The version number of a Tatin package must follow the rules for Semantic Versioning: it always has the format <code>{major}.{minor}.{patch}</code>. </p> <p>After <code>{patch}</code>, more information might be available, separated from the patch number by a hyphen.</p> <p>Valid examples for a version number are therefore:</p> <pre><code>0.1.0\n1.0.0\n12.23.199\n1.2.3-beta-1     \n</code></pre> <p>These pieces of information fully participate when Tatin needs to establish package precedence:</p> <p><code>1.2.3</code> is \"better\" than  <code>1.2.2</code> but also \"better\" than <code>1.2.3-beta1</code> of course.</p> <p>Information after the hyphen is restricted to ASCII characters and digits until a space or a plus (<code>+</code>) is detected. </p> <p>The plus (<code>+</code>) is used to separate an (optional) build number from the other parts of a version number.</p>"},{"location":"original/semanticversioning/#build-numbers","title":"Build numbers","text":"<p>After {major}-{minor}-{patch} you may add the optional build number. Build numbers do not participate in establishing precedence and are therefore ignored by Tatin when compiling the name of a package and/or a package ZIP file.</p> <p>I&gt; That means that you cannot publish two packages that share the same group-name, package-name, major-no, minor-no and patch-no but have different build numbers - they are the same as far as Tatin is concerned.</p> <p>A build number, when specified, needs to be separated by a <code>+</code>. A build number may consist of digits only.</p> <pre><code>2.3.4+1456\n1.2.3-beta-1      \u235d becomes 1.2.3-beta-1 as a Tatin package\n1.2.3-beta-1+123  \u235d becomes 1.2.3-beta-1 as a Tatin package\n</code></pre> <p>Therefore <code>1.2.3-beta-1.abc</code> is invalid.</p> <p>The Semantic Versioning rules define when exactly which part of the version number may or must be bumped. They also define which parts are considered when establishing precedence: build numbers are always ignored.</p>"},{"location":"original/semanticversioning/#terminology-and-versioning-rules","title":"Terminology and versioning Rules","text":"<p>Given <code>1.2.3+4</code>:</p> <ul> <li><code>1</code> is the major version number</li> <li><code>2</code> is the minor version number</li> <li><code>3</code> is the patch number </li> <li>The (optional) <code>4</code> is the build number.</li> </ul>"},{"location":"original/semanticversioning/#the-build-number","title":"The build number","text":"<p>The build number is optional and is ignored by Tatin. However, if a package has a build-number, it is bumped whenever the package is built again, no matter what. It is never reset. </p>"},{"location":"original/semanticversioning/#the-patch-number","title":"The Patch Number","text":"<p>The patch number is bumped only when a change does not affect compatibility. </p> <p>A typical example is a bug fix: imagine that a function in a package crashes because an edge condition was not handled. When you fix that problem, you may bump the patch number because nothing else has changed. A consumer of the package can be reasonably confident that everything that worked before will continue to work.</p> <p>However, in real life things get messy pretty quickly: the consumer of a package might mistake a bug for a feature if it does not crash but does something it shouldn't, and take advantage of the bug. Imagine that a new version of the package comes with a fix for just that bug...</p> <p>If chances are high that a consumer might rely on the bug then you should bump the Major number rather than the Patch number - see there. Very old bugs are excellent candidates for that.</p>"},{"location":"original/semanticversioning/#the-minor-number","title":"The Minor number","text":"<p>The minor version number is bumped in case functionality was added to a package. </p> <p>That means that compatibility should still be guaranteed: anything else works exactly as before. A consumer should be confident when updating the package that nothing will break. She just may take advantage of, say, a function added to the API.</p> <p>A&gt; ### Chances of breaking things A&gt; A&gt; Note that by definition it seems that a change of the minor number is indicating a very low risk: just adding functionality should never change anything that has worked before, while a change in the patch number might come from a bug fix your code relies on.  A&gt; A&gt; In reality however a version with a new (bumped) minor version number often comes with bug fixes as well.</p>"},{"location":"original/semanticversioning/#the-major-number","title":"The Major number","text":"<p>When you change the API not by just adding stuff but by deleting or renaming parts of the public interface, or changing the parameters that an API function requires, then the package is guaranteed to be incompatible with earlier versions. If that's the case then you must bump the major version number.</p> <p>These two packages:</p> <pre><code>aplteam-foo-1.0.0\naplteam-GOO-1.0.0\n</code></pre> <p>... are of course considered to be different packages, but according to the concept of SemVer these two packages:</p> <pre><code>aplteam-foo-1.0.0\naplteam-foo-2.0.0\n</code></pre> <p>... are also considered to be different packages.</p> <p>Tatin reflects that in several ways, for example by listing all major versions of a package when this user command is invoked:</p> <pre><code>      ]tatin.ListPackages\n</code></pre>"},{"location":"original/semanticversioning/#why-semantic-versioning","title":"Why Semantic versioning?","text":"<p>Before the introduction of the rules of Semantic Versioning, everybody assigned version numbers to their liking. Updating to a new version always carried a significant risk that things would break.</p> <p>With the rules of Semantic Versioning in place, if everybody involved acts accordingly and sensibly, updating should be much safer. </p> <p>However, things can get pretty complicated even with Semantic Versioning; see the TatinsLoadAndUpdateStrategy.</p> <p>Semantic versioning came into being via this website:</p> <p>https://semver.org/</p>"},{"location":"original/server-tipsandtricks/","title":"Server: Tips and tricks","text":"<p>Once you've installed a server there are a couple of things that need to be taken care of.</p>"},{"location":"original/server-tipsandtricks/#maintenance","title":"Maintenance","text":""},{"location":"original/server-tipsandtricks/#tags","title":"Tags","text":"<p>The most important thing is to watch tags. Tags can be very useful to find a package, but the problem is that package authors tend to use different tags for the same thing, use legal but different spelling (UK versus US) or invalid spelling, tags that make no sense like adding the group name or \"dyalog\" etc.</p> <p>That means that for tags to work there has to be a gatekeeper who is responsible for correcting/removing/adding tags.</p> <p>That gatekeeper needs to be able to execute code on the server, but only once. The idea is to correct problems in the package config files somehow.</p> <p>A&gt; ### The package config file and the ZIP file  A&gt; A&gt; Note that changing the config file is enough: If the file got changed then Tatin will make sure that the new version is automatically also added to the ZIP file of the package, effectively overwriting the old version of the package file. </p> <p>This can be achieved by uploading an <code>.aplf</code> text file (read: a function) into a folder that is defined in the INI file as <code>[CONFIG]MaintenancePath</code>.</p> <p>If one or more of such files are found by the Tatin Server while doing housekeeping, they are loaded into the server and executed. Once executed the files are renamed by adding an extension <code>.executed</code>.</p> <p>For example, if there is a file <code>RemoveDyalogFromTags.aplf</code> then it is loaded into an unnamed namespace and called with a right argument <code>G</code> (for \"globals\"). Once executed the file is then renamed to <code>RemoveDyalogFromTags.aplf.executed</code>.</p> <p>That makes sure the code is not executed again, but it is also useful for documenting what code was executed, and when.</p>"},{"location":"original/server-tipsandtricks/#crashing-maintenance-files","title":"Crashing maintenance files","text":"<p>Like any other program, a maintenance file may crash. If that happens the server carries out the following steps:</p> <ol> <li>Report it to the log file</li> <li>Send an email reporting the crash with details to the maintainer (if enabled in the INI file)</li> <li>Rename the file from <code>*.aplf</code> to <code>*.crashed</code> --- we don't want that function to be executed again</li> </ol>"},{"location":"original/server-tipsandtricks/#developing","title":"Developing","text":"<p>If you want to make changes or add new features you need a good understanding of the basic design of Tatin.</p>"},{"location":"original/server-tipsandtricks/#structure","title":"Structure","text":""},{"location":"original/server-tipsandtricks/#main-namespaces","title":"Main namespaces","text":"<p>Four ordinary namespaces contain all the Tatin code:</p> <code>Admin</code> <p>Contains helpers useful to administrate Tatin, for example creating a new version, performing maintenance tasks etc.</p> <p><code>Client</code></p> <p>Contains the code executed on the Client side of Tatin.</p> <p><code>Server</code></p> <p>Contains the code to run a Tatin Server</p> <p><code>Registry</code></p> <p>Contains all code that is shared by a Tatin client and a Tatin server.</p>"},{"location":"original/server-tipsandtricks/#other-stuff","title":"Other stuff","text":"<p>There are some more ordinary namespaces that are used by Tatin</p> <code>Plodder</code> <p>A fully-fledged HTTP server that is based on Rumba and Conga</p> <p>For details see https://github.com/aplteam/Plodder</p> <code>RumbaLean</code> <p>An implementation of HTTP 1.1 in APL</p> <p>For details see https://github.com/aplteam/RumbaLean</p> <p>These two are not part of the Tatin project.</p>"},{"location":"original/server-tipsandtricks/#version","title":"Version","text":"<p>Note that by design new versions always comprehend both the server and the client, so the version number is always the same for both.</p>"},{"location":"original/server-tipsandtricks/#developing-with-a-running-server","title":"Developing with a running server","text":"<p>You might want to run a server while Tatin is an open Cider project. The running server allows you to investigate what the code is doing, and at the same time, any changes and additions would be tracked by Link.</p> <p>You might even want to run the server in one workspace as an opened Cider project and at the same time run the test cases in another workspace, also as an opened Cider project. Of course you need to be very careful because otherwise you might loose code.</p> <p>Let's assume that you want to run the Tatin server that is part of the Tatin project. When the Tatin test cases are executed, Tatin would ask you whether you want to start the server automatically -- that is the server we are talking about, not https://test.tatin.dev.</p> <p>However, when the server is started as part of the tests it is NOT opened as a Cider project, and changes would not be tracked by Link. If you want that then execute the following steps instead:</p> <ol> <li> <p>Open the Tatin project with <code>]Cider.OpenProject</code> with the <code>watch</code> parameter set to \"both\".</p> </li> <li> <p>Run the function <code>#.Tatin.TestCasesServer.RunTests</code></p> </li> </ol> <p>!&gt; ### A word of warning =&gt; Opening Tatin as a project in two different workspaces, and then make changes to the code in both of them is of course dangerous! =&gt; =&gt; On Windows or when .NET is available you can limit the danger by doing this: =&gt;  =&gt; * Make sure that Link's <code>Notify</code> parameter is set to 1. That makes Link print to the session whenever it updates a file or the workspace, so you get some feedback on what is happening. Make sure you watch this! =&gt;  =&gt; * Make sure that you set Link's <code>watch</code> parameter to \"both\" in both workspaces.  =&gt; =&gt;   That ensure that when you change an APL object in on workspace, it will not only be written do disk but Link will also bring that change into the other workspace. =&gt;  =&gt; This is particularly important when you change code in the <code>Tatin.Registry</code> namespace, because that code is shared between the client and the server. =&gt;  =&gt; Taking these measure is important because the mechanism used by Dyalog works most of the time but not always (it's a .NET-problem!), so it is important to watch out for such problems. =&gt;  =&gt; On non-Windows platforms with no .NET available, <code>watch=both</code> is not an option at the time of writing (July 2024), so that is particularly dangerous.</p> <p>If you just want to run the test server, close the project before executing <code>#.Tatin.TestCasesServer.RunTests</code>.</p> <p>The main handlers are:</p> <ul> <li><code>#.Tatin.Server.OnRequest</code></li> <li><code>#.Tatin.Server.OnHouseKeeping</code></li> </ul> <p><code>OnRequest</code> will eventually call one of these:</p> <ul> <li><code>Handle_GET</code></li> <li><code>Handle_PUT_And_POST</code></li> <li><code>Handle_Delete</code></li> </ul> <p>These will call the Tatin functions that perform the real actions.</p>"},{"location":"original/server-tipsandtricks/#error-trapping","title":"Error trapping","text":"<p>Keep in mind that error trapping is active, so when you change a function and inject a typo this will trigger error trapping  once your code gets executed.</p> <p>If there is any danger of you locking horns with error trapping, consider putting this into <code>OnRequest</code>:</p> <p><code>\u2395TRAP\u21900 'S'  \u235dTODO\u235d</code> </p> <p>Also, make <code>\u2395TRAP</code> a local variable in <code>OnRequest</code>.</p> <p><code>\u235dTODO\u235d</code> is a reminder that won't go unnoticed: there is a test case that will detect these markers and report them, so it's pretty hard to forget them.</p>"},{"location":"original/server-tipsandtricks/#misc","title":"Misc","text":""},{"location":"original/server-tipsandtricks/#special-rest-commands","title":"Special REST commands","text":"<p>A Tatin server can offer several special REST commands only useful for a developer when testing Tatin. They should never be available on a production server.</p> <p>Whether these commands would be carried out is decided by the INI entry <code>[CONFIG]SpecialCommands</code>.</p> <p>One of the commands will return an HTML page with all available commands. We use this as an example.</p> <p>In a Browser enter this URL:</p> <pre><code>https://localhost:5001/v1/list-commands\n</code></pre> <p>Note that with the exception <code>list-commands</code>, these commands do not return HTML, they rather trigger actions.</p>"},{"location":"original/server-tipsandtricks/#executing-the-tatin-test-suite","title":"Executing the Tatin test suite","text":"<p>The test framework used is very powerful, and offers lots of options. Naturally only the basics are covered here. </p> <p>For more information refer to https://github.com/aplteam/Tester2</p>"},{"location":"original/server-tipsandtricks/#execute-the-complete-test-suite","title":"Execute the complete test suite","text":"<p>This can be achieved by executing:</p> <pre><code>#.Tatin.TestCases.RunTests\n</code></pre> <p>This prepares the test framework and then executes all tests in debug mode, meaning that in case something goes wrong, the framework will stop and you can investigate right away,</p> <p>You will be asked whether you want to copy the test data to a temp folder in preperation.</p> <p>On Windows you will also be asked whether you want to start a test server. Usually you will answer both questions with \"yes\". On Non-Windows platforms you will be asked to start the server yourself before carrying on.</p>"},{"location":"original/server-tipsandtricks/#execute-particular-tests-or-groups-of-tests","title":"Execute particular tests or group(s) of tests","text":"<p>Sometimes it makes sense to execute not all but a small subset of test cases. In this case you might not need test data, or a running test server, depending on that test cases you are about to execute.</p> <p>This can be achieved as well; first you need to excute:</p> <pre><code>#.Tatin.TestCases.Prepare\n</code></pre> <p>This initializes Tatin as a client and prepares for creating a code-coverage report. It also creates a number of references needed by the tests.</p> <p>You only need to call <code>Prepare</code> once.</p> <p>In a second step you can excute one or more tests. A couple of examples:</p> <p>Execute one particular test of the <code>UC</code> group:</p> <pre><code>#.Tatin.TestCases.T.RunThese 'UC' 600\n</code></pre> <p>Execute several tests of the <code>UC</code> group:</p> <pre><code>#.Tatin.TestCases.T.RunThese 'UC' (600 601 602)\n</code></pre> <p>Execute all tests belonging to the <code>UC</code> group:</p> <pre><code>#.Tatin.TestCases.T.RunThese 'UC'\n</code></pre>"},{"location":"original/server-tipsandtricks/#execute-just-batch-tests","title":"Execute just batch tests","text":"<p>A small number of tests require a user that can be asked to perform actions, like closing an edit window. </p> <p>Sometimes you might want to execute only tests that do not require a human in front of the monitor. These are called batch tests.</p> <p>These tests can be executed by executing:</p> <pre><code>#.Tatin.TestCases.RunBatchTests 1\n</code></pre> <p>The 1 required as right argument is just a safety net against accidental calls.</p> <p>By default error trapping is in place: in case a test case fails or crashes, this is covered, and the test framework carries on. </p> <p>If you want batch tests to stop in case of a problem, you must specify the optional <code>debug</code> flag as left argument:</p> <pre><code>1 #.Tatin.TestCases.RunBatchTests 1\n</code></pre>"},{"location":"original/server-tipsandtricks/#creating-a-new-version","title":"Creating a new version","text":"<ol> <li>Check <code>#.Tatin.Registry.Version</code> for being correct</li> <li>Check <code>#.Tatin.Registry.History</code> for being correct</li> <li>Check the document <code>docs/ReleaseNotes.md</code> for being correct</li> <li>Ask Cider how to \"Make\" a new version with <code>]Cider.Make</code></li> </ol> <p>It will tell you to execute:</p> <pre><code>#.Tatin.Admin.Make 0\n</code></pre> <p>The right argument is a batch flag: it tells the function whether a human is available (0) or not (1). If there is, progress is reported to <code>\u2395SE</code>. Naturally the latter is used in  order to automatically create a new version.</p> <p>Note that if the batch flag is 0, the function will print a statement to the session which, when executed, will install the new version.</p>"},{"location":"original/server-tipsandtricks/#licensing","title":"Licensing","text":""},{"location":"original/server-tipsandtricks/#ini-entries","title":"INI entries","text":"<p>The names of the licenses as well as the URLs that are to be accepted by a server must be defined in the INI file of the server within the <code>[LICENSE]</code> section.</p> <p>Note that the INI section <code>[LICENSE]</code> may exist, but it does not have to: if it does not, then no menu item \"Licensing\" will show in the main menu of the website, and the server will accept any license, including packages that do not even carry a property <code>license</code>.</p>"},{"location":"original/server-tipsandtricks/#the-menu-item-licensing","title":"The menu item \"Licensing\"","text":"<p>The text shown on the web page is defined in the document \"Licensing.html\" in the <code>html/</code> folder.</p>"},{"location":"original/server-tipsandtricks/#a-license-file","title":"A \"LICENSE\" file","text":"<p>By convention a file named \"LICENSE\" when placed in the root of the project will be copied automatically to the root of a package when build by <code>BuildPackage</code>. This convention is independent from the INI file.</p>"},{"location":"original/syntaxreference/","title":"Tatin Syntax Reference","text":""},{"location":"original/syntaxreference/#user-commands","title":"User Commands","text":"<p>Every user command comes with at least two levels of help, and a few even with a third level:</p> <ol> <li><code>-?</code> shows a brief description and the syntax</li> <li><code>-??</code> shows a detailed description of the command and its arguments and options</li> <li><code>-???</code> shows examples (only available for some commands)</li> </ol> <p>If the third level is available then <code>-??</code> shows this at the bottom:</p> <pre><code>]{user-command} -??? \u235d Enter this for examples                                        \n</code></pre>"},{"location":"original/syntaxreference/#the-api","title":"The API","text":"<p>The API is established in <code>\u2395SE.Tatin</code>. These are almost exclusively dfns that call a function in <code>\u2395SE._Tatin</code>.</p> <p>While <code>\u2395SE._Tatin</code> holds all packages loaded into <code>\u2395SE</code>, among them those required by the Tatin client, <code>\u2395SE.Tatin</code> holds the public interface of the Tatin client. A user is supposed to call functions in <code>Tatin</code> but not <code>_Tatin</code>.</p> <p>The API functions are listed alphabetically.</p>"},{"location":"original/syntaxreference/#buildpackage","title":"BuildPackage","text":"<pre><code>zipFilename\u2190BuildPackage parameterSpace\n</code></pre> <p>ZIPs all files that are required for a package according to the specified parameters and creates a ZIP file containing these files in <code>parameterSpace.targetPath</code>.</p> <p>Requires a namespace with parameters as right argument, typically created by calling <code>CreateBuildParms</code> which requires a path to the project as right argument:</p> <pre><code>   parms\u2190\u2395SE.Cider.CreateBuildParms '/path/2/project`\n   parms.\u2395nl 2\ndependencyFolder\nnamespace\nprojectPath     \ntargetPath   \nversion         \n</code></pre>"},{"location":"original/syntaxreference/#dependencyfolder","title":"dependencyFolder","text":"<p>A folder with packages the project depends on. Might be empty, in case there are'nt any dependencies.</p>"},{"location":"original/syntaxreference/#projectspace","title":"projectSpace","text":"<p>This is optional. Set this to the namespace where the package project lives.</p> <p>Setting this makes sense under these conditions:</p> <ul> <li>The package project lives in the workspace</li> <li>You want the build number in <code>TatinVars.CONFIG</code> to be upated by <code>BuildPackage</code></li> </ul> <p><code>BuildPackage</code> bumps the build ID, but only on file. It cannot update it in the WS because it does not know where it lives, unless you tell it by setting <code>projectSpace</code> accordingly.</p> <p>If you do set <code>projectSpace</code>, then <code>BuildPackage</code> will scan that namespace recursively for <code>TatinVars</code> and update <code>TatinVars.CONFIG</code>.</p>"},{"location":"original/syntaxreference/#projectpath","title":"projectPath","text":"<p>The folder the package is going to be created from. To be specified as the right argument of <code>CreateBuildParms</code>.</p>"},{"location":"original/syntaxreference/#targetpath","title":"targetPath","text":"<p>The folder the ZIP file is created in.</p> <p>Defaults to <code>projectPath</code> in case <code>targetPath</code> is empty.</p>"},{"location":"original/syntaxreference/#versionversion-parms","title":"version{#version-parms}","text":"<p>Must be one of:</p> <ul> <li>A rule how to modify the version number in the package config file</li> <li>An empty character vector</li> <li>A character vector that replaces \"version\" in the package config file</li> </ul> <p>A&gt; ### The version number A&gt; A&gt; The problem with version numbers is that a package configuration file must contain a version number, but many programmers want to have the version number also available in their code. So which one rules? A&gt; A&gt; Clearly there is no right or wrong answer here: it depends on personal preferences, or the work flow. A&gt; A&gt; <code>BuildPackage</code> is part of Tatin, therefore it takes care of the <code>version</code> information in the package configuration file. Everything else is left to the user.</p>"},{"location":"original/syntaxreference/#version-starts-with-a","title":"\"version\" starts with a \"+\"","text":"<p>The \"+\" makes it a rule. It must come with three digits separated by dots. The digits may be just 0 or 1.</p> <p>The rules:</p> <ul> <li><code>+0.0.1</code> bumps the patch number</li> <li><code>+0.1.0</code> bumps the minor number and resets the patch number</li> <li><code>+1.0.0</code> bumps the major number and resets both the patch number and the minor number</li> </ul> <p>--- Changed in 0.117.0 ---</p> <p>Such a rule has no impact on the build number: </p> <ul> <li>If the package config file has a build number as part of <code>version</code>, that build number is bumped</li> <li>If the package config file has no build number nothing happens (starting with version 0.117.0)</li> </ul> <p>However, in such a case you might want to force a build number into the package config file. This can be achieved by adding a trailing <code>+</code>, for example <code>+1.0.0+</code>. (Of course, you can also edit the config file and add <code>+0</code> at the end of <code>version</code>)</p> <p>Either way you end up with a build number 1.</p> <p>--- End of change ---</p>"},{"location":"original/syntaxreference/#version-does-not-start-with-a","title":"\"version\" does not start with a \"+\"","text":"<p>--- Changed in 0.117.0 ---</p> <ul> <li>If <code>version</code> is empty, then just the build number in the config file is bumped, if there is one.</li> <li>If <code>version</code> is not empty but does not carry a build number, then it replaces the version information.</li> </ul> <p>If the config file carries a build number , it is bumped. * If <code>version</code> is not empty and includes a build number, then it replaces the version information including the build number. That build number is then bumped.</p> <p>--- End of change ---</p>"},{"location":"original/syntaxreference/#dependencies","title":"Dependencies","text":"<p>If <code>dependencyFolder</code> is empty <code>BuildPackage</code> tries to establish whether the package depends on other packages:</p> <ol> <li>It checks whether the package is managed by Cider (read: has a file <code>cider.config</code>). If that is the case it checks the property <code>[CIDER]dependencies:tatin</code> in that file. If it defines a folder then it is taken.</li> </ol> <p>Refer to the Cider documentation on <code>dependencies:tatin</code> for details.</p> <ol> <li> <p>If the package is not managed by Cider then Tatin assumes that package dependencies (if any) would be installed into a subfolder <code>packages/</code> (convention).</p> </li> <li> <p>If there is no subfolder <code>packages/</code>, or if it does not host a file <code>apl-dependencies.txt</code>, then Tatin looks for a file <code>apl-dependencies.txt</code> in the root of the package project.</p> </li> <li> <p>If the package is not managed by Cider and depends on packages that are installed in a different subfolder than <code>packages/</code>, then the name of the subfolder must be passed as <code>dependencyFolder</code> in the parameter space.</p> </li> </ol> <p>If no file <code>apl-dependencies.txt</code> can be detected then Tatin will assume that the package does not depend on other packages.</p>"},{"location":"original/syntaxreference/#checkforlaterversion","title":"CheckForLaterVersion","text":"<pre><code> r\u2190{flags} CheckForLaterVersion path\n</code></pre> <p>Checks whether there are later versions available for the principal packages installed in <code>path</code>.</p> <p>The optional left argument must, if specified, be an integer that may carry flags as a single integer:</p> Value Description 0 No flag set, same as no argument at all 1 Major: should rather later major versions be listed? Defaults to 0 2 Dependencies: should dependencies be checked as well? Defaults to 0 3 Both flags set <p>By default, only minor and patch number are part of the check. By specifying 1 as <code>major</code> you may change this default behaviour and list any later major versions instead.</p> <p>Note that this function scans all known registries with a priority greater than zero.</p> <p>Returns a matrix with five columns:</p> Col Info [;1] Original package ID [;2] Latest package ID [;3] Original URL [;4] Flag; 1 means later version is available [;5] URL the latest version was found but empty in case it's identical with [;3]"},{"location":"original/syntaxreference/#clearcache","title":"ClearCache","text":"<pre><code>(rc report)\u2190ClearCache url\n</code></pre> <p>Clears the cache, which is the folder <code>GetPathToPackageCache</code> points to.</p> <ul> <li>If <code>url</code> is empty all subdirectories but <code>temp\\</code> are removed</li> <li>If <code>url</code> is not empty then only the given domain is removed from the cache</li> </ul>"},{"location":"original/syntaxreference/#copyregistry","title":"CopyRegistry","text":"<pre><code>list\u2190CopyRegistry parms \n</code></pre> <p>This command copies packages from a managed Tatin Registry (by default <code>[tatin]</code>) to a local folder.</p> <p>There might be a Tatin Server running on the local target folder, but this is not a requirement. In fact any running local server must be paused or stopped while <code>CopyRegistry</code> is running.</p> <p>By default all packages are copied, even deprecated ones.</p> <p>Packages that are already saved in the target folder are not requested again, but check the <code>-force</code> flag.</p> <p><code>CopyRegistry</code> was introduced with version 0.110.0, therefore you cannot use it on Tatin servers that run earlier versions than that.</p> <p>The function takes one mandatory argument: a parameter namespace typically created by calling CreateCopyRegistryParms, and then amended.</p> <p>Note that you must set two of the parameters, <code>url</code> and <code>path</code>. The other parameters have default values.</p>"},{"location":"original/syntaxreference/#createapifromcfg","title":"CreateAPIfromCFG","text":"<pre><code>{noOf}\u2190{names} CreateAPIfromCFG (refTosourceNS cfg)\n</code></pre> <p>This function creates cover functions in the API namespace for everything that is supposed to become the public interface of a package. </p> <p>These cover functions are one-line dfns that call thhe function with the same name one level above. Because they are one-liners the Tracer will ignore them: it is not possible to trace into a one-line dfn. Most of the time this is a blessing, but sometimes it is a curse.</p> <p>By default the contents of the package becomes the public interface: <code>\u2395NL 2 3 4 9</code>. However, if there is a function <code>Public</code> available, then this is expected to return a list of simple text vectors defining the public interface. <code>CreateAPIfromCFG</code> will use the result of <code>Public</code> if it finds one in the root of the given namespace.</p> <p>Alternatively, you can pass a list of names as left argument to <code>CreateAPIfromCFG</code> - that would take precedence.</p> <p>It is possible to keep <code>names</code> very simple by specifying a single name, but it can also be complex and comprehend the names of functions, operators, variables, interfaces, classes and namespace, simple and scripted. It can also use dotted syntax to define names within namespaces, though only one level deep.</p> <p>!&gt; ### Tips and hints =&gt; You may call <code>CreateAPIfromCFG</code> when initialising a package after loading it (from a function that is executed by the package's <code>lx</code> parameter, see \"Tatin's Package Configuration File\" for details). =&gt;  =&gt; Alternatively, you may call it as part of the package creation process, making the API a permanent part of the package. </p>"},{"location":"original/syntaxreference/#typical-scenarios","title":"Typical scenarios","text":"<ol> <li> <p>The package consists of a single class or a single ordinary namespace</p> </li> <li> <p>The package consists of a single function or operator</p> </li> <li> <p>The package consists of several objects: a mixture of functions, operators, classes and/or namespaces</p> </li> </ol> <p>A&gt; ### Single functions  A&gt; A&gt; You must not specify the name of a function (or an operator) as the API in any of these cases. A&gt;  A&gt; This restriction helps to avoid confusion, but there is also a technical issue: Tatin needs to establish references to the API, and although in Dyalog one can establish references (kind of) to monadic, ambivalent, and dyadic functions, this is not possible for neither operators nor niladic functions.</p>"},{"location":"original/syntaxreference/#a-single-namespace","title":"A single namespace","text":"<ul> <li>If you don't specify <code>api</code> then the name of the namespace is the API. </li> </ul> <p>For example, if the package name is <code>pkgName</code> and the namespace's name (see the <code>source</code>  parameter) is <code>foo</code> and it has a function <code>Hello</code>, then you call <code>Hello</code> with:</p> <p><code>pkgName.foo.Hello</code></p> <ul> <li>If you do specify <code>api</code> by assigning an APL name to it, then it must be the name of the namespace. In that case, the contents of the namespace becomes the API.</li> </ul> <p>For example, if the package name is <code>pkgName</code> and the namespace's name is <code>foo</code> and it has a function <code>Hello</code>, then you specify <code>api</code> as <code>foo</code> and call <code>Hello</code> with:</p> <p><code>pkgName.Hello</code></p>"},{"location":"original/syntaxreference/#a-single-scripted-namespace","title":"A single scripted namespace","text":"<p>If a package consists of a single scripted namespace then you cannot use the services of Tatin's <code>CreateAPIfromCFG</code> function. The reason is that this function tries to establish a sub-namespace (with a name defined by the package config parameter <code>api</code>) inside the target, and that works only with ordinary namespaces, but not with scripted namespaces.</p> <p>You could still create an API yourself, however. For example, if a package <code>Foo</code> consists of a scripted namspace that carries (say) about 20 variables, functions and operators of which only two should be accessible by a user (say <code>Encode</code> and <code>Decode</code>), then you could create this namespaces structure:</p> <pre><code>#.Foo\n#.Foo.Core\n  ... \u235d vars, fns and oprs\n#.Foo.API\n#.Foo.API.Encode\n#.Foo.API.Decode  \n</code></pre> <p>This is how <code>#.Foo.API.Decode</code> would look like:</p> <pre><code>Decode\u2190{\u237a ##.JWTAPL.Decode \u2375}\n</code></pre> <p>And this is how <code>#.Foo.API.Encode</code> would look like:</p> <pre><code>Encode\u2190{\u237a ##.JWTAPL.Encode \u2375}\n</code></pre> <p>You just need to establish these functions yourself.</p> <p>You don't need a function <code>Public</code> here because that function's only purpose is to be called by <code>CreateAPIfromCFG</code> in order to establish a list of public objects. Here the job is done by you, therefore there is no need for <code>Public</code>.</p>"},{"location":"original/syntaxreference/#a-single-class","title":"A single class","text":"<ul> <li>If you don't specify <code>api</code> then the name of the class is the API. </li> </ul> <p>For example, if the package name is <code>pkgName</code> and the class name is <code>foo</code> and it has a function <code>Hello</code>, then you call <code>Hello</code> with:</p> <p><code>pkgName.foo.Hello</code></p> <ul> <li>If you do specify <code>api</code> then it must be the name of the class. In that case, everything in the class with <code>:Access Public Shared</code> becomes the API.</li> </ul> <p>For example, if the package name is <code>pkgName</code> and the class name is <code>foo</code> and it has a publicly shared function <code>Hello</code>, then you call <code>Hello</code> with:</p> <p><code>pkgName.Hello</code></p>"},{"location":"original/syntaxreference/#a-single-function-or-operator","title":"A single function or operator","text":"<p>If the name of the package is <code>pkgName</code>, and the name of the function is <code>MyFns</code>, then it is called as <code>pkgName.MyFns</code>. The function may be niladic, monadic, ambivalent or dyadic.</p> <p>The same holds for an operator.</p> <p>In this particular case <code>api</code> must not be defined (remain empty).</p>"},{"location":"original/syntaxreference/#a-mixture-of-several-apl-objects","title":"A mixture of several APL objects","text":"<ul> <li> <p>If <code>api</code> is not set then all top-level objects of the package become the API: functions, operators, namespaces, classes, interfaces.</p> </li> <li> <p>If <code>api</code> is set then it must point to one of the namespaces or classes, or a sub-namespace (using dotted syntax), or a class in a sub-namespace. Then just the objects in what <code>api</code> is pointing to become the API.</p> </li> </ul>"},{"location":"original/syntaxreference/#restricting-whats-public","title":"Restricting what's \"public\"","text":"<p>The user might want to expose only a subset of functions/operators of a namespace (classes have such an interface anyway: <code>:Public Shared</code>), and in that case, the user must not only specify <code>api</code>, but also structure her code accordingly.</p> <p>If the name of the package is <code>pkgName</code>, and it is loaded into <code>#</code>, and you want to expose only the functions <code>Run</code> and <code>CreateParmSpace</code>, then the recommended way of doing this is to create a sub-namespace with the name (say) <code>MyAPI</code> and populate it with two functions:</p> <ul> <li><code>Run</code>:</li> </ul> <pre><code>Run\u2190{\u237a\u2190\u22a2 \u22c4 \u237a ##.Run \u2375}\n</code></pre> <p>(Assumes that <code>Run</code> takes an optional left argument)</p> <ul> <li><code>CreateParmSpace</code>:</li> </ul> <pre><code>CreateParmSpace\u2190{##.CreateParmSpace \u2375}\n</code></pre> <p>(Assumes that <code>CreateParmSpace</code> does not accept a left argument)</p> <p>Finally, you need to specify <code>api: \"MyAPI\"</code> in the package config file.</p> <p>Calling the function <code>Run</code> (after loading the package) would then require:</p> <pre><code>      #.PkgName.Run\n</code></pre> <p>To the outside world, only two functions are visible:</p> <pre><code>      #.PkgName.\u2395nl \u237316\n#.Foo.Run\n#.Foo.CreateParmSpace\n</code></pre> <p>Similarly, if <code>PkgName</code> consists of the two namespaces <code>Boo</code> and <code>Goo</code>, and <code>Run</code> and <code>CreateParmSpace</code> live in <code>Boo</code>, then you could also have a sub-namespace <code>Boo.API</code> that hosts <code>Run</code> and <code>CreateParmSpace</code>, and <code>api</code> would be <code>Boo.API</code>, while calls are still <code>PkgName.Run</code> and <code>PkgName.CreateParmSpace</code>.</p>"},{"location":"original/syntaxreference/#createbuildparms","title":"CreateBuildParms","text":"<pre><code>r\u2190CreateBuildParms path\n</code></pre> <p>Creates a namespace with parameters for the <code>BuildPackage</code> function.</p> <p>Contains these parameters:</p> <pre><code>dependencyFolder\nprojectPath          \u235d Set to `path`\nprojectSpace\ntargetPath\nversion\n</code></pre>"},{"location":"original/syntaxreference/#createcopyregistryparms","title":"CreateCopyRegistryParms","text":"<pre><code>parms\u2190CreateCopyRegistryParms y\n</code></pre> <p>Returns a namespace with parameters required by the <code>CopyRegistry</code> function.</p> <p><code>y</code> can either be a namespace with some or all of the parameters that might be defined in a parameter namespace for <code>CopyRegistry</code>.</p> <p>Of the parameters two MUST be specified: </p> <code>path</code> <p>Defines a local folder where the packages are going to be saved.</p> <code>url</code> <p>The url of the Tatin Registry to be copied from.</p> <p>The folllowing parameters can be used to amend the behaviour of <code>CopyRegistry</code> according to your needs:</p> <ul> <li><code>force</code></li> <li><code>latest</code></li> <li><code>group</code></li> <li><code>list=</code></li> <li><code>dry</code></li> <li><code>verbose=</code></li> </ul> <p>All these flags and options are documented as part of the <code>]CopyRegistry</code> user command, for details see there.</p> <p>There is one exception: by specifying <code>noDeps\u21901</code> one can prevent dependencies from being copied, and the documentation of the user command <code>]CopyRegistry</code> does not talk about this option. The reason is that this is only useful for test cases.</p>"},{"location":"original/syntaxreference/#createreinstallparms","title":"CreateReInstallParms","text":"<pre><code>r\u2190CreateReInstallParms\n</code></pre> <p>Creates a namespace with default parameters; it can be passed as (optional) left argument to the <code>ReInstallDependencies</code> function, in particular, <code>noBetas</code>, <code>update</code> and <code>dry</code>.</p>"},{"location":"original/syntaxreference/#deletepackages","title":"DeletePackages","text":"<pre><code>(statusCode errMsg)\u2190DeletePackages (regID packageIDs)\n</code></pre> <p>Deletes one or more packages, usually several versions of the same package.</p> <p>Whether deleting packages from a Tatin Registry is possible at all depends on the delete policy it operates, which is in turn determined by the server's INI setting <code>[CONFIG]DeletePackages</code>. See <code>GetDeletePolicy</code>. The principal Tatin server operates a \"None\" policy, meaning that you cannot delete anything from it.</p> <p>!&gt; ### Why can't I delete a package from the Tatin server? =&gt; The main design objective was to make sure that a build that includes packages from the principal Tatin Registries can always be reproduced in precisely the same way.  =&gt; =&gt; If deleting a package is allowed --- even when it is a beta version --- then this cannot be guaranteed. =&gt; =&gt; If you happen to publish a package and realize seconds later that you made a formidable mistake? Well, you increase the patch number, fix the problem and publish a new version, that's the only way.</p> <p>In order to delete a package you must identify the package precisely:</p> <pre><code>&lt;group-name&gt;-&lt;package-name&gt;-&lt;precise_version_number&gt;\n</code></pre> <p>You may delete several packages in one go by specifying several complete package IDs as a nested vector. However, all packages will be deleted from the same Registry identified by <code>regID</code>. <code>regID</code> can be a URL or a Registry alias or a Registry ID.</p> <p>The function returns an HTTP status code and a message, which will be empty in case of success.</p>"},{"location":"original/syntaxreference/#deprecatepackage","title":"DeprecatePackage","text":"<pre><code>msg\u2190DeprecatePackage y\n</code></pre> <p>Declares a package to be deprecated.</p> <p><code>y</code> must provide three pieces of information:</p> <ul> <li>A Registry URL or a Registry alias</li> <li>A comment like \"See package xyz instead\"</li> <li>A package ID that provides group name, package name and optionally a major version number</li> </ul> <p>If no major version number is provided, then the function acts on all major versions of that package.</p> <p>Note that because the Registry must be defined no scanning takes place with this function.</p>"},{"location":"original/syntaxreference/#finddependencies","title":"FindDependencies","text":"<pre><code>r\u2190{depth} FindDependencies (target pkgList [verbose])\n</code></pre> <p><code>target</code> can be any of the following:</p> <ul> <li>A Registry alias</li> <li><code>[*]</code> for all defined Registries with a priority greater than 0</li> <li>A URL pointing to a Tatin server </li> <li>A folder</li> </ul> <p>The first three options will eventually become the folder where the packages of a Registry are stored.</p> <p>Scans <code>folder</code> recursively for a file \"apl-dependencies.txt\". Folders with such a file will be searched for packages defined in <code>pkgList</code>. Useful to find out where one or more packages are used.</p> <p><code>pkgList</code> must be a simple char vector with a list of packages separated by commas.</p> <p>The packages can be specified fully or partially specified. \"Group\" and \"Version\" can be omitted while \"Name\" is mandatory. You can specify a major version, but \"minor\" and \"patch\" are ignored if specified.</p> <p>Note that the search is not case-sensitive.</p> <p>Returns a fully qualified list of all matches. </p> <p>By default only the folder containing a file \"apl-dependencies.txt\" with at least one of the defined packages is returned.</p> <p>If a 1 is passed as <code>verbose</code> (optional, defaults to 0) the actual package folders will be returned instead of the hosting folder(s), revealing the precise version(s) installed.</p> <p>The optional left argument can be used to limit the number of levels to be searched recursively. A server sets this to 1 because it knows that it only needs to search the sub folders of the Registry folder, which greatly reduces the time spent on the task.</p> <p>The user can use it in the same way if she knows exactly what is stored where.</p>"},{"location":"original/syntaxreference/#getdeletepolicy","title":"GetDeletePolicy","text":"<pre><code>r\u2190GetDeletePolicy url\n</code></pre> <p>Takes the alias or the URL of a server like https://tatin.dev or an alias and returns the delete policy operated by that server.</p> <p>Returns one of \"None\", \"Any\", \"JustBetas\":</p> <ul> <li>\"None\" means a package, once published, cannot be deleted                                </li> <li>\"Any\" means any package can be deleted                                                    </li> <li>\"JustBetas\" means that only beta versions can be deleted                                </li> </ul>"},{"location":"original/syntaxreference/#getdependencytree","title":"GetDependencyTree","text":"<pre><code>tree\u2190{append} GetDependencyTree x\n</code></pre> <p>Takes <code>identifier</code> (<code>x</code>) and returns the dependencies as a matrix.</p> <p><code>identifier</code> must be one of:</p> <ul> <li>an HTTP request</li> <li>a folder holding a package (like file://C:\\Temp{group}-{name}-{major.minor.patch}\\)</li> <li>a path to a package in a registry (like C:\\MyReg\\{packageID})</li> <li>a package ID; Tatin will then attempt to find that package in the Registries defined in the Client's config file.</li> </ul> <p>Returns a dependency tree as a matrix:</p> <p>|[;1] | Flag that indicates whether it is a principal package (1) or a dependency (0) |[;2] | PackageID of what required that dependency |[;3] | Full package ID |[;4] | The full URL (either a local path (without protocol) or http(s)://...)</p> <p>This function requires the version number to be fully specified.</p> <p>Note that the function accepts an optional left argument, but this should not be specified by a user: it is only used internally.</p>"},{"location":"original/syntaxreference/#optional-left-argument-append","title":"Optional left argument <code>append</code>","text":"<p>The optional left argument defaults to 0, meaning a saved dependency tree is replaced. By passing a 1 as the left argument one can add to the saved dependency tree.</p>"},{"location":"original/syntaxreference/#getnocachingflag","title":"GetNoCachingFlag","text":"<pre><code>flag\u2190GetNoCachingFlag uri\n</code></pre> <p>Takes a URI or an alias and tries to find that URI in the <code>MyUserSettings</code> instance. If found the value of the <code>noCaching</code> property is returned. </p> <p>If URI is unknown a 0 is returned.</p>"},{"location":"original/syntaxreference/#getpathtopackagecache","title":"GetPathToPackageCache","text":"<pre><code>r\u2190GetPathToPackageCache\n</code></pre> <p>The user settings rule:</p> <ul> <li> <p>If <code>MyUserSettings.path2cache</code> is not empty then that path is returned, otherwise:</p> </li> <li> <p>The function returns the standard path for caching which depends on the operating system</p> </li> </ul>"},{"location":"original/syntaxreference/#getuserhomefolder","title":"GetUserHomeFolder","text":"<pre><code>path\u2190{aplVersion} GetUserHomeFolder append\n</code></pre> <p>Returns the standard path for any user-specific data.</p> <p>Works on all platforms but returns different results.</p> <p><code>\u2375</code>, if not empty, is added to the resulting path.</p> <p>!&gt; ### On Windows  =&gt; It is typically: =&gt; <code>=&gt; `C:\\Users\\%USERPROFILE%\\AppData\\Roaming\\Tatin'     \u2190\u2192 GetUserHomeFolder '' =&gt; `C:\\Users\\%USERPROFILE%\\AppData\\Roaming\\Tatin\\foo' \u2190\u2192 GetUserHomeFolder 'foo' =&gt;</code> !&gt; ### On Linux =&gt; <code>=&gt; '/home/{\u2395AN}/Tatin'     \u2190\u2192 GetUserHomeFolder '' =&gt; '/home/{\u2395AN}/Tatin/foo' \u2190\u2192 GetUserHomeFolder 'foo' =&gt;</code> !&gt; ### On Mac-OS =&gt; <code>=&gt; '/Users/{\u2395AN}/Tatin'     \u2190\u2192 GetUserHomeFolder '' =&gt; '/Users/{\u2395AN}/Tatin/foo' \u2190\u2192 GetUserHomeFolder 'foo' =&gt;</code></p> <p><code>\u237a</code> is optional and only specified by test cases in order to simulate different versions of APL.</p>"},{"location":"original/syntaxreference/#initialisepackage","title":"InitialisePackage","text":"<pre><code>config\u2190{configParms} InitialisePackage folder\n</code></pre> <p>Takes a folder (<code>\u2375</code>) and initializes it so that it can be a package.</p> <p>This means in particular to create the folder (although it might already exist) and creating a package config file with default settings or what <code>\u237a</code> specifies: one can pass a config namespace as <code>\u237a</code>, typically created by a call to <code>InitPackageConfig</code>.</p> <p>There must be no config file yet, otherwise an error is thrown.</p>"},{"location":"original/syntaxreference/#initpackageconfig","title":"InitPackageConfig","text":"<pre><code>cfg\u2190{projectPath}  InitPackageConfig y\n</code></pre> <p>Returns a namespace with default values useful for the function <code>InitialisePackage</code>.</p> <p><code>\u2375</code> might be empty; then it is ignored. Alternatively, it might be a namespace with variables. If it is then the variables in that namespace overwrite the defaults.</p> <p><code>projectPath</code> is optional. It is used only in case <code>source</code> is not specified, not even as a global default in the user settings.</p>"},{"location":"original/syntaxreference/#installpackages","title":"InstallPackages","text":"<pre><code>r\u2190{noBetas} InstallPackages (identifiers targetFolder)\n</code></pre> <p>Installs one or more packages (<code>identifiers</code>) in <code>targetFolder</code>.</p> <p><code>identifiers</code> must be a simple character vector, specifying one or more comma-separated packages (items).</p> <p>Each item must be one of:</p> <ul> <li>an HTTP request for a package</li> <li>a ZIP file holding a package</li> <li>a folder holding a package (like <code>file://C:\\Temp\\group-name-version\\</code>)</li> <li>a path to a package in a registry (like <code>[RegistryAlias]{group}-{name}-{major.minor.patch}</code> or <code>C:\\MyReg\\{group}-{name}-{major.minor.patch})</code></li> <li>a package ID; Tatin will then attempt to find that package in the Registries defined in the Client's config file</li> <li>The internal alias <code>[MyUCMDs]</code> (case independent); this will then be replaced by the actual path to the <code>MyUCMDs/</code> folder followed by the name specified or, if none was specified, the name of the package</li> </ul> <p>You may omit minor+patch or even major+minor+patch in order to install the latest version.</p> <p>By default beta versions are considered in case the package ID is incomplete, but you can suppress them by passing <code>1</code> as <code>\u237a</code>.</p> <p><code>r</code> is a nested vector of character vectors with the full names of all principal packages installed. The length will match the number of packages specified as <code>identifiers</code>.</p> <p>Notes:</p> <ul> <li>The target folder will be created if it does not already exist</li> <li>The package ID(s) might use any case, meaning that if the package's name is <code>foo-Goo-1.2.3</code> then you might as well spell it <code>foo-GOO-1.2.3</code> or <code>FOO-goo-1.2.3</code>: it would not make a difference </li> </ul>"},{"location":"original/syntaxreference/#listdeprecated","title":"ListDeprecated","text":"<pre><code>r\u2190{all} ListDeprecated uri\n</code></pre> <p>Lists all packages that are deprecated but only if they are the last published version of any given major version number.</p> <p>This default behaviour can be changed with the <code>-all</code> flag: then all versions of any major version that is marked as deprecated are listed. </p> <p><code>uri</code> must be one of:</p> <ul> <li>A path to an install folder, defined by the presence of a file <code>apl-buildlist.json</code></li> <li>A path to a Registry and optionally a (possibly incomplete) package ID</li> </ul>"},{"location":"original/syntaxreference/#listcache","title":"ListCache","text":"<pre><code>r\u2190{fullpath} ListCache y\n</code></pre> <p>Lists the contents of the Tatin package cache. Refers to the <code>MyUserSettings</code> instance of the class <code>UserSettings</code>.</p> <p><code>y</code> must be one of:</p> <ul> <li>A character vector with a Registry domain name or a Registry alias or empty</li> <li>A nested vector of length 2: first item see above, second must be a Boolean that defaults to 0.</li> </ul> <p>This is interpreted as <code>principalFlag</code>.</p> <p>The optional left argument <code>fullpath</code> defaults to 0, when just domain names and package IDs are reported. If it is 1 then the full paths are reported instead.</p> <p>The result is a vector with as many items as there are domains represented in the cache with at least one package. Each item is a two-element vector:</p> <ul> <li>The first item holds the url of the domain</li> <li>The second item holds a vector of char vectors with the package names</li> </ul> <p>In case the cache is empty an empty vector is returned.</p>"},{"location":"original/syntaxreference/#listlicenses","title":"ListLicenses","text":"<pre><code>r\u2190{verbose} GetNoCachingFlag url\n</code></pre> <p><code>verbose</code> defaults to 0 but might be 1.</p> <ul> <li> <p>With <code>verbose\u21900</code> a list with the names of all licenses tolerated by the given managed Tatin Registry is returned. Might be empty.</p> </li> <li> <p>With <code>verbose\u21901</code> a matrix with two columns and zero or more rows is returned:</p> </li> <li> <p><code>[;1]</code> Names of all licenses </p> </li> <li><code>[;2]</code> URLs of all licenses</li> </ul>"},{"location":"original/syntaxreference/#listpackages","title":"ListPackages","text":"<pre><code>mat\u2190{parms} ListPackages uri\n</code></pre> <p>Lists all packages of a given Registry except when the last package of a major version number is marked as deprecated --- see <code>ListDeprecated</code> for listing those.</p> <p><code>uri</code> must be one of:</p> <ul> <li>A path to an install folder, defined by the presence of a file <code>apl-buildlist.json</code></li> <li>A path to a Registry and optionally a (possibly incomplete) package ID</li> </ul>"},{"location":"original/syntaxreference/#right-argument","title":"Right argument","text":""},{"location":"original/syntaxreference/#folder","title":"Folder","text":"<p>In case a folder was specified a two-column matrix is returned:</p> <p>|[;1] |Carries the package ID |[;2] |Carries a star for principal packages</p>"},{"location":"original/syntaxreference/#registry","title":"Registry","text":"<p>In case a Registry was specified, by default all packages saved in that Registry are returned, aggregated by major versions, as a two-column matrix.</p> <p>You may specify a package ID without version number, or only part of the version number; then only matching packages are listed.</p> <p>You may even specify just a package name, without a group name. That would not make a difference in case the name is only used once, but if it is used in several groups then all of them will be listed.</p>"},{"location":"original/syntaxreference/#left-argument","title":"Left argument","text":"<p>Optionally <code>parms</code> can be specified. If specified this must be a namespace that must contain the variables <code>group</code>, <code>tags</code> and <code>aggregate</code>. It may contain <code>date</code>, <code>since</code>, <code>project_url</code> and/or <code>userCommand</code>.</p> <p>The following parameters allow the user to select certain packages:</p> <ul> <li>Use <code>group</code> to specify the group.</li> <li>Use <code>tags</code> to specify one or more tags (simple comma-separated text vector); is case-independent.</li> <li><code>userCommand</code>, if specified, must be a Boolean. If it is 1 only packages that are user commands are returned.</li> <li>Use <code>since</code> to specify a date; all packages published before that date will be ignored.</li> </ul> <p><code>since</code> can be one of:</p> <ul> <li>A character vector in the format <code>YYYY-MM-DD</code> or <code>YYYYMMDD</code> like <code>since\u2190'2022-06-01'</code></li> <li>An integer in the format <code>YYYYMMDD</code> like <code>since\u219020220601</code></li> </ul> <p>The following parameters allow the user to influence what data is returned:</p> <ul> <li>If <code>date</code> is <code>1</code> an additional column is added to the result with the publishing date</li> <li>If <code>project_url</code> is <code>1</code> an additional column is added to the result with the <code>project_url</code>, if any</li> <li>If <code>aggregate</code> is <code>0</code> the data is not aggregated by minor and patch number; defaults to 1.</li> </ul>"},{"location":"original/syntaxreference/#packageid","title":"packageID","text":"<ul> <li><code>packageID</code> is empty and <code>aggregate</code> is 1 (the default):</li> </ul> <p>All packages are returned with the number of major versions in <code>[;2]</code></p> <ul> <li><code>packageID</code> is empty and <code>aggregate</code> is 0:</li> </ul> <p>All packages are returned; the second column carries <code>\u236c</code></p> <ul> <li><code>packageID</code> specifies {name} and <code>aggregate</code> is 0:</li> </ul> <p>All packages that match <code>name</code> are returned; they might belong to different groups</p> <ul> <li><code>packageID</code> specifies {group}-{name} and <code>aggregate</code> is 0:</li> </ul> <p>All versions of that package are returned</p> <ul> <li><code>packageID</code> specifies {group}-{name} and <code>aggregate</code> is 1:</li> </ul> <p>All major versions of that package are returned</p> <p><code>[;2]</code> carries the number of versions of each major version</p> <ul> <li><code>packageID</code> specifies {group}-{name}-{major}; in this case <code>aggregate</code> is ignored:</li> </ul> <p>All versions (minor and patch) of that package are returned</p> <ul> <li><code>packageID</code> specifies {group}-{name}-{major}-{minor}; in this case <code>aggregate</code> is ignored:</li> </ul> <p>All patch versions of that package are returned</p>"},{"location":"original/syntaxreference/#result","title":"Result","text":"<p>Returns a matrix with at least two and up to four columns. These columns are always returned:</p> <p>|[;1] | Package name | |[;2] | Carries the number of major versions |</p> <ul> <li>In case <code>date</code> was specified a column is added carrying the publishing date</li> <li>In case <code>project_url</code> was specified a column is added carrying the project URL (if any)</li> </ul>"},{"location":"original/syntaxreference/#deprecated-packages","title":"Deprecated packages","text":"<p>In case the last published version of a package carries a flag <code>deprecated</code> in its config file and that is a 1, such a package and all its predecessors with the same major version number are not listed.</p> <p>To list just deprecated packages use <code>ListDepreciated</code>.</p>"},{"location":"original/syntaxreference/#listregistries","title":"ListRegistries","text":"<pre><code>r\u2190ListRegistries type\n</code></pre> <p>Lists all registries defined in the Client's config file.</p> <p>Returns a matrix with these columns:</p> <p>|[;1] | Alias |[;2] | URL |[;3] | ID |[;4] | Port |[;5] | Priority |[;6] | No-caching flag |[;7] | Proxy |[;8] | API key</p> <p>\"type\" must be either 0 or 1 or empty:</p> <ul> <li>1 means all data is listed</li> <li>0 means the API key is not listed</li> </ul> <p>Notes:</p> <ul> <li>The result of the API function and the user command differ</li> <li>When a Tatin Server is questioned by <code>ListRegistries</code> but does not respond, an error is thrown.</li> </ul>"},{"location":"original/syntaxreference/#listtags","title":"ListTags","text":"<pre><code>list\u2190{parms} ListTags y\n</code></pre> <p>Lists all tags.</p> <p><code>y</code> might be the URL of a Tatin server or a Registry alias (embraced by <code>[]</code>).</p> <p>By default all tags of all packages are returned as a two-column matrix:</p> <ul> <li><code>[;1]</code> carries the name of the tags</li> <li><code>[;2]</code> carries the number of occurrences of that tag</li> </ul> <p>Optionally <code>\u237a</code> can be specified. Must be a namespace that might contain a variable <code>tags</code> which may specify one or more tags (simple comma-separated text vector). If that is the case only the tags shared by the packages that carry all of the specified tags will be returned.</p>"},{"location":"original/syntaxreference/#listversions","title":"ListVersions","text":"<pre><code>mat\u2190{dateFlag} ListVersions url\n</code></pre> <p>Lists all versions of a given package.</p> <p><code>url</code> must be one of:</p> <ul> <li>A package name</li> <li>A group name and a package name</li> <li>A URL pointing to a Registry together with a package name</li> <li>An alias pointing to a Registry together with a package name</li> <li>A (local) path to a Registry together with a package name</li> </ul> <p>A package name may be either just the name or the group and the name. Additionally, you may either specify a major version number, or a major and a minor version number.</p> <p>Specifying a patch number makes no sense. If it is specified anyway it is ignored.</p> <p>Therefore the following arguments are all valid:</p> <ol> <li><code>example-versions</code></li> <li><code>example-versions-1</code></li> <li><code>example-versions-1.0</code></li> <li><code>[tatin-test]versions</code></li> <li><code>[tatin-test]example-versions</code></li> <li><code>[tatin-test]example-versions-1</code></li> <li><code>[tatin-test]example-versions-1.0</code></li> <li><code>[tatin-test]example-versions-1.0.1 \u235d Same as 7.</code></li> </ol> <p>In the first three cases all defined Registries with a priority greater than zero are scanned. A matrix with two columns is returned: URL and full package ID.</p> <p>If a URL or an alias was specified the given Registry is questioned. A matrix with one column with full package IDs is returned.</p> <p>You may omit the group name; that does not make a difference when the name is used only within one group anyway, but if it is used in more than one group, then all of them are listed.</p> <p>If version precedence cannot be established from the version numbers alone (often a problem with beta versions) then the publishing date is taken into account.                        </p> <p>By default, the publishing date is not included, but you may change this by passing a 1 as <code>\u237a</code>. In that case, an additional column is added to the result.</p> <p>Note that the package ID might use any case, meaning that if the package's name is <code>foo-Goo</code> then you might as well spell it <code>foo-GOO</code> or <code>FOO-goo</code>: it would not make a difference </p>"},{"location":"original/syntaxreference/#loaddependencies","title":"LoadDependencies","text":"<pre><code>{r}\u2190{flags} LoadDependencies y\n</code></pre> <p>Loads all packages according to a build list in a folder.</p> <p>Requires one mandatory right argument and accepts up to two:</p> <ul> <li>A source folder (a folder with a build list)</li> <li>A target namespace</li> </ul> <p>If the target namespace is not specified then it defaults to <code>#</code> except when <code>[MyUCMDs]</code> is specified as source folder: in that case it defaults to <code>\u2395SE</code>.</p> <p>The optional left argument <code>flags</code> can be used to define two flags which default to 0:</p> <ul> <li><code>overwrite</code> enforces a load even if the package is already available in <code>#._tatin</code> or <code>\u2395SE._tatin</code></li> <li><code>makeHomeRelative</code> influences the result of <code>HOME</code> and <code>GetFullPath2AssetsFolder</code>: rather than returning the full path only the folder holding the packages and its parent are returned, making it a relative path</li> </ul> <p>A&gt; ### Relative <code>HOME</code> A&gt; A&gt; In case Tatin packages become part of an application that is bundled with the Dyalog runtime you cannot use absolute paths for referring to assets for obvious reasons.  A&gt; A&gt; In that case the paths must be relative, and that's what the <code>makeHomeRelative</code> flag is for.</p> <p>Returns a vector with references to the loaded packages (principal packages only, not dependencies).</p>"},{"location":"original/syntaxreference/#myucmds","title":"MyUCMDs/","text":"<p>In case a Tatin package is a Dyalog user command it can be installed into the special folder <code>MyUCMDs/</code>. Where <code>MyUCMDs/</code> lives depends on the operating system.</p> <p>Notes:</p> <ul> <li><code>MyUCMDs</code> is case independent, so specifying <code>[MYUCMDS]</code> or <code>[myucmds]</code> does not make a difference</li> <li>In case no name is specified after <code>[MyUCMDs]</code> the name of the sub-folder is derived from the package name</li> <li>If you want to install multiple user command packages in one go you must not specify a name after <code>[MyUCMDs]</code>, otherwise an error is thrown</li> </ul>"},{"location":"original/syntaxreference/#loadpackages","title":"LoadPackages","text":"<pre><code>r\u2190{noBetas} LoadPackages (identifiers targetSpace)\n</code></pre> <p>Loads packages dynamically into the workspace.</p> <p><code>identifiers</code> must be a simple character vector specifying one or more comma-separated packages (items).</p> <p>Every single item must be one of:</p> <ul> <li>An HTTP request for a package</li> <li>A ZIP file holding a package</li> <li>A folder holding a package (like <code>file://C:/Temp/group-name-version</code>)</li> <li>A path to a package in a registry (like <code>[RegistryAlias]{packageID}</code> or <code>C:\\MyReg\\{packageID}'</code>)</li> <li>A package ID; Tatin will then attempt to find that package in one of the Registries defined in the client's config file with a priority greater than 0.</li> </ul> <p>The first hit wins.</p> <p><code>targetSpace</code> must be a reference or a fully qualified name of an ordinary namespace, meaning the name must start with either <code>#</code> or <code>\u2395SE</code>.</p> <p>It might already exist, but if it doesn't it will be created. If it exists but is not an ordinary namespace an error is thrown.</p> <p>Loads the package(s) into <code>(#|\u2395SE)._tatin.{packageName}</code> and establishes a reference for every one of them in <code>targetSpace</code></p> <p>Loads all dependencies, if any, as well into <code>(#|\u2395SE)._tatin</code> but does not create references for them in <code>targetSpace</code>.</p> <p>By default beta versions are considered in case the package ID is incomplete, but you can suppress them by passing <code>1</code> as <code>\u237a</code>.</p> <p>Returns the number of principal packages loaded.</p> <p>Note that the package ID(s) might use any case, meaning that if the package's name is <code>foo-Goo-1.2.3</code> then you might as well spell it <code>foo-GOO-1.2.3</code> or <code>FOO-goo-1.2.3</code>: it would not make a difference </p>"},{"location":"original/syntaxreference/#ping","title":"Ping","text":"<pre><code>bool\u2190Ping url\n</code></pre> <p>Establishes whether the host is up and running with very little overhead. If <code>url</code> (can also be an alias) points to a folder a 1 is returned if that folder exists, otherwise 0.</p>"},{"location":"original/syntaxreference/#publishpackage","title":"PublishPackage","text":"<pre><code>{(statusCode errMsg zipFilename)}\u2190{dependencies} PublishPackage (source registry)\n</code></pre> <p>Publishes a package.</p> <ol> <li>Checks whether there is already such a package but with a different spelling in terms of case</li> <li>Creates a zip file for the package in a Temp folder if required</li> <li>Moves the zip file into the Registry, either via HTTP or directly.</li> <li>Updates the Registry index in case it's a local Registry</li> </ol> <p><code>\u2375</code> must be a two-item vector:</p> <ol> <li><code>source</code> \u2192 folder to create the package from</li> <li><code>registry</code> \u2192 registry to publish the package to (alias or url)</li> </ol> <p>Note that if <code>\u2375[1]</code> points already to a ZIP file only steps 3 and 4 are performed.</p> <p>In case a folder is specified rather than a ZIP file then <code>PublishPackage</code> tries to establish whether the package depends on other packages. This is done by the API function <code>BuildPackage</code>, which is called by <code>PublishPackage</code> internally. </p> <p>The optional left argument <code>dependencies</code> is, when specified, passed as left argument to <code>BuildPackage</code>; see there for details.</p> <p>The explicit result:</p> <ul> <li><code>statusCode</code> is an HTTP code no matter whether it is an HTTP call or not</li> <li><code>errMsg</code> is empty if <code>statusCode</code> is 200, otherwise it might carry additional information</li> <li><code>zipFilename</code> is empty in case <code>source</code> is a ZIP file, otherwise it is the name of the ZIP file created</li> </ul> <p>W&gt; Note that the API function will publish the package no matter what the delete policy operated by the server is.  W&gt; W&gt; That is different from the user command which will ask the user for confirmation in case the user attempts to publish a package that cannot be deleted once published.</p>"},{"location":"original/syntaxreference/#reinstalldependencies","title":"ReInstallDependencies","text":"<pre><code>{refs}\u2190{parms} ReInstallDependencies (dependencies installFolder [Registry])\n</code></pre> <p>Re-installs all files in a given file <code>apl-dependencies.txt</code>.</p> <p>Takes a folder that hosts a file <code>apl-dependencies.txt</code> as mandatory argument.</p> <p>Optionally a second right argument might be specified: a Registry, either as a URL or an alias. Without this all known Registries with a priority greater than <code>0</code> will be scanned.</p> <p>The file <code>apl-buildlist.json</code> as well as all directories in that folder will be deleted. Then all packages listed in the file <code>apl-dependencies.txt</code> are re-installed from scratch. Lines in <code>apl-dependencies.txt</code> that start with a lamp character (<code>\u235d</code>) are ignored.</p> <p>Note that packages with different major version numbers are considered as different packages.</p> <p>The left argument is optional and is, if specified, typically created by calling <code>CreateReInstallParms</code>.</p> <p>It may carry three parameters:</p> <ul> <li><code>noBetas</code></li> </ul> <p>By default this is 0, meaning that beta versions are considered. Set this to 1 if you want betas to be ignored.</p> <ul> <li><code>update</code></li> </ul> <p>Defaults to 0, meaning that the same version is installed again even if a later version is available. Change this to 1 to force an update.</p> <ul> <li><code>dry</code></li> </ul> <p>Defaults to 0, meaning the function does business. Set this to 1 in order to get a report of what the function would do without actually doing it.</p> <p>Notes:</p> <ul> <li>For every dependency this function performs a Registry scan, even if a Registry was specified.</li> <li>Packages that were installed from ZIP files are just re-installed from their ZIP files without further ado.</li> </ul> <p>A&gt; ### Registry scans A&gt; A&gt; Under certain circumstances Tatin performs a Registry scan: Tatin questions every Registry with a priority greater than 0 (highest priority number first) for hosting a particular package. The first hit wins.  A&gt; A&gt; For example, when <code>ReInstallDependencies</code> is called for all dependencies a Registry scan is performed. A&gt; A&gt; Note that when you installed a package from a Tatin Registry https://MyTatin.com and then later remove that Registry from your user settings, or set its priority to 0, effectively telling Tatin not to scan that Registry anymore, then <code>ReInstallDependencies</code> will not scan https://MyTatin.com  anymore, despite Tatin knowing perfectly well where the package in question was originally loaded from.</p>"},{"location":"original/syntaxreference/#readpackageconfigfile","title":"ReadPackageConfigFile","text":"<pre><code>cfg\u2190ReadPackageConfigFile path\n</code></pre> <p>Takes a path to a package and returns the config file for that package as a namespace populated with variables.</p> <p><code>path</code> may or may not carry the filename (<code>apl-package.json</code>).</p>"},{"location":"original/syntaxreference/#uninstallpackages","title":"UnInstallPackages","text":"<pre><code>(list msg)\u2190UnInstallPackage (packageID folder)\n</code></pre> <p><code>UnInstallPackage</code> attempts to un-install the package <code>packageID</code> and all its dependencies, but the latter only in case they are neither principal packages nor required by other packages.</p> <p><code>folder</code> must host a Tatin dependency file. </p> <p><code>folder</code> must be either a path or the (case independent) symbolic name <code>[MyUCMDs]</code> </p> <p><code>[MyUCMDS]</code> would translate into <code>MyUCMDs/packages/</code>.</p> <p><code>packageID</code> might be a full package ID but also <code>&lt;group&gt;-&lt;name&gt;</code> or just <code>&lt;name&gt;</code>. However, in case more than one package qualifies an error is thrown.</p> <p>Note that if <code>packageID</code> is empty a clean-up attempt is made.</p> <p><code>folder</code> may be a subfolder of an open Cider project. Tatin works out the correct one; if there are multiple Cider projects open the user is questioned.</p> <p><code>packageID</code> must be fully qualified: group + name + version.</p> <p>If a package was installed with an alias you must un-install it by specifying the alias. </p> <p>If a package is installed twice, once with an alias and once without, running <code>]UnInstallPackage</code> on either of them does not uninstall the package but removes just the reference to it. Only when the other one is uninstalled as well is the package actually removed.</p> <p>To keep things simple Tatin performs the following steps: 1. Checks whether the package ID is mentioned in the dependency file. If not an error is thrown 3. Removes <code>packagedID</code> from the dependency file 4. Re-compile the build list based on the new dependency file 5. Removes all packages that are not mentioned in the build list anymore</p> <p>Returns a two-item vector:</p> <ol> <li>List with the fully qualified names of all removed packages. Note that they might carry an alias.</li> <li>Message, ideally empty. </li> </ol> <p>Note that removing the directories hosting the packages might fail for all sorts of reasons even though the package and any dependencies were already successfully removed from both the dependency file and the build list.</p>"},{"location":"original/syntaxreference/#version","title":"Version","text":"<pre><code>r\u2190Version\n</code></pre> <p>Returns \"name\", \"version\" and \"date\".</p>"},{"location":"original/tatinandonedrive/","title":"Tatin and OneDrive","text":""},{"location":"original/tatinandonedrive/#background","title":"Background","text":"<p>OneDrive is cloud storage offered by Microsoft for backing up some of your personal folders. </p> <p>In the context of Tatin, the folder <code>Documents\\</code> is of particular interest.</p> <p>For decades, Dyalog has saved (or potentially saved) stuff in a version agnostic folder named <code>Dyalog APL Files</code> in the <code>Documents\\</code> folder, and also version specific stuff. For example, for version 19.0 there is a folder <code>Dyalog APL-64 19.0 Unicode Files</code> created in <code>Documents/</code>.</p> <p>Until version 0.114.0 Tatin  questioned the environment variable <code>USERPROFILE</code> in order to find out where to copy Tatin to. For example, for a user JohnDoe that would usually result in</p> <pre><code>C:\\Users\\JohnDoe\\Documents\\\n</code></pre> <p>This is true no matter whether OneDrive is used or not.</p> <p>This means that in case OneDrive is used and the Documents folder is managed by OneDrive (the user might use OneDrive and still decide against this!), then <code>USERPROFILE</code> is misleading.</p>"},{"location":"original/tatinandonedrive/#solution","title":"Solution","text":"<p>Tatin now uses the --- at the time of writing --- inofficial I-beam <code>4070\u23360</code> which in the second item of the result gives the location of the Dyalog files folder for the currently running version of Dyalog, for example for a user JohnDoe:</p> <pre><code>      2\u22834070\u23360\nC:\\Users\\JohnDoe\\OneDrive\\Documents\\Dyalog APL-64 19.0 Unicode Files\n</code></pre> <p>With version 0.114.0 Tatin has adopted this and can therefore deal with a <code>Documents/</code> folder that is saved in OneDrive.</p>"},{"location":"original/tatinandonedrive/#problems-when-updating-an-older-version-of-tatin","title":"Problems when updating an older version of Tatin","text":"<p>Any attempt to update an older version than 0.114.0 will appear to be successful, but after a restart you will still use the old version.</p> <p>The reason for this is that older versions were installed into</p> <pre><code>C:\\Users\\JohnDoe\\Documents\\Dyalog APL-64 19.0 Unicode Files\n</code></pre> <p>while the updated version is copied into </p> <pre><code>C:\\Users\\JohnDoe\\OneDrive\\Documents\\Dyalog APL-64 19.0 Unicode Files\n</code></pre> <p>when your are running version 19.0</p> <p>If this hits you your are advised to carry out these steps:</p> <ol> <li>Add the path</li> </ol> <pre><code>C:/Users/&lt;\u2395AN&gt;/OneDrive/Documents/Dyalog APL-64 19.0 Unicode Files/SessionExtensions/CiderTatin\n</code></pre> <p>to SALT's <code>cmddir</code> and remove the path</p> <pre><code>C:/Users/&lt;\u2395AN&gt;/Documents/Dyalog APL-64 19.0 Unicode Files/SessionExtensions/CiderTatin\n</code></pre> <p>from it. </p> <ol> <li>Remove the folder</li> </ol> <pre><code>C:/Users/JohnDoe/Documents/Dyalog APL-64 19.0 Unicode Files/SessionExtensions/CiderTatin\n</code></pre> <p>from your disk.</p> <p>This solves the problem permanently in the sense that future updates will work as expected.</p> <p>However, if you are going back to any ill-behaving version, for example by executing this command:</p> <pre><code>      ]activate -reset\n</code></pre> <p>then you are back on a version that won't work when an update is issued, until Dyalog ships a new version, when this document will change as well.</p>"},{"location":"original/tatinforcontributors/","title":"Tatin for Contributors","text":""},{"location":"original/tatinforcontributors/#scope-of-this-document","title":"Scope of this document","text":"<p>If you want to contribute to the Tatin project on GitHub or make adjustments to Tatin for an in-house project, this document will help you.</p> <p>Tatin is published under the MIT license, so everybody is welcome to contribute to the code. It is not owned by anybody; it is rather a community project.</p> <p>This document also discusses how to execute the test suite and how to build a new version of Tatin.</p> <p>Note that this is not an introduction to how to contribute to a project that is hosted on GitHub. If you are not familiar with that then google \"contribute to a GitHub project\".</p>"},{"location":"original/tatinforcontributors/#requirements","title":"Requirements","text":"<p>To work on Tatin you need at least Dyalog 18.2 Unicode (it will never run in Classic).</p> <p>You need one of: </p> <ul> <li>Windows</li> <li>Linux</li> <li>Mac OS</li> </ul> <p>AIX is not supported. The PI is not officially supported but it will probably work anyway.</p> <p>You also need to have Git installed.</p> <p>While you can develop on any operating system, building a new version is currently only supported on Windows. This restriction is likely to be lifted in a later version.</p>"},{"location":"original/tatinforcontributors/#tatin-is-managed-by-cider","title":"Tatin is managed by Cider","text":"<p>Note that Tatin is managed by the Cider project management tool. If you are not familiar with Cider you are advised to spend some time playing with it before using it for serious work. 30 minutes should suffice.</p> <p>Though it is possible making changes or adding code to Tatin without Cider, using Cider makes it significantly easier. Also, the build process requires Cider.</p> <p>Having said this, you don't neccessarily need to build a new version for creating a pull request, so you might get away without Cider, but using Cider is certainly recommended.</p>"},{"location":"original/tatinforcontributors/#how-to-work-on-tatin","title":"How to work on Tatin","text":"<p>After downloading/forking Tatin from GitHub and saving it somewhere, say in <code>C:\\Tatin</code>, you issue the command </p> <pre><code>]Cider.OpenProject C:\\Tatin\n</code></pre> <p>and you are ready to go. </p> <p>Note that there is no need to save a workspace or anything: every function, operator, class, interface or namespace script changed in <code>#.Tatin</code> will automatically be saved to disk by Link.</p>"},{"location":"original/tatinforcontributors/#prepare-either-the-client-or-the-server","title":"Prepare either the Client or the Server","text":""},{"location":"original/tatinforcontributors/#introduction","title":"Introduction","text":"<p>Note that for running the test suite you only need to prepare the client. However, because  you might want to run the test server independently from the test suite, the required preparations for the server is discussed here as well.</p>"},{"location":"original/tatinforcontributors/#preparing-the-client","title":"Preparing the client","text":"<p>If you want to run any Tatin client code execute the function</p> <pre><code>#.Tatin.Admin.Initialize_Client\n</code></pre>"},{"location":"original/tatinforcontributors/#preparing-the-server","title":"Preparing the server","text":"<p>If you want to run the Tatin Server execute the function</p> <pre><code>#.Tatin.Admin.Initialize_Server\n</code></pre> <p>Note that you cannot run both the Client and the Server in the same workspace.</p> <p>GitHub does not allow downloading certificates, therefore you must take action in this respect. Tatin comes with test certificates, and in order to get around the GitHub restriction the certificates have an \"additional extension\" <code>.RemoveMe</code> which needs, well, removing.</p> <p>Check the folder <code>TestServer/Server/Assets/Runtime/Certificates</code></p>"},{"location":"original/tatinforcontributors/#updating-tatin-packages-used-by-tatin","title":"Updating Tatin packages used by Tatin","text":"<p>Although Tatin depends on a couple of Tatin packages, it cannot be used to load those packages; the common bootstrap problem.</p> <p>For that reason, the packages installed in the <code>packages/</code> folder a need to be brought into the <code>APLSource/</code> folder by other means:</p> <ul> <li>All packages that are single class or namespace scripts can simply by copied over; an example is the <code>Tester2</code> class.</li> <li>Packages that consist of an ordinary namespace need to be copied over as a folder; an example is <code>CommTools</code>.</li> </ul>"},{"location":"original/tatinforcontributors/#do-your-thing","title":"Do your thing","text":"<p>Now that you have a working version of Tatin on your machine, you can start contributing.</p> <p>If you find parts of this document confusing, outdated, unclear or missing bits and pieces: change it; that might well be your first valuable contribution.</p> <p>Whether you improved the documentation or fixed a bug or added a feature, at the end of the day you need to create a Pull Request (PR). That will make the people in charge of the Tatin project check your contribution. At the time of writing that is Kai Jaeger, but this might (and eventually will) change in the future of course.</p> <p>But before you can create a pull request you are supposed to run the tests to make sure that you did not break anything.</p>"},{"location":"original/tatinforcontributors/#special-case-working-on-user-commands","title":"Special case: working on user commands","text":"<p>When you work on user commands, by default the code is executed in <code>\u2395SE</code> rather than <code>#</code>. This also means that changes are not saved automatically by Link. </p> <p>This is a major stumble stone, and therefore it was addressed with version 0.106.0: when the Tatin project is opened with Cider the user is asked:</p> <pre><code>Set DEVELOPMENT\u21901 in \u2395SE._Tatin? \n(Allows executing user command code in # rather than \u2395SE) \n(Y/n) \n</code></pre> <p>The variable <code>\u2395SE._Tatin.DEVELOPMENT\u21901</code> tells that the user wants to work on Tatin while calling code in <code>\u2395SE</code>, and therefore Tatin makes sure that the code in <code>#</code> is executed rather than <code>\u2395SE</code>. </p> <p>Note that if there is a variable <code>\u2395SE._Tatin.DEVELOPMENT\u21900</code> Cider won't ask the question, and code is executed in <code>\u2395SE</code>, as it is if there is no variable <code>\u2395SE._Tatin.DEVELOPMENT</code> at all.</p>"},{"location":"original/tatinforcontributors/#executing-the-test-suite","title":"Executing the test suite","text":"<p>If you just want to execute all test cases before pushing your changes to GitHub then you may ask Cider how to do that:</p> <pre><code>      ]Cider.RunTests\n#.Tatin.#.Tatin.TestCases.RunTests \u235d Execute this for running the test suite\n</code></pre> <p>Executing <code>RunTests</code> means that on Windows you will be asked whether a test server should be started. Usually, you will answer with a \"Y\", Meaning that the test suite will start another instance of Dyalog, and run a test server in that instance for you.</p> <p>On non-Windows platforms you will be be asked to start another instance of Dyalog, and you will be given a <code>)Load /path/2/test-server/RunTatinServer.dws</code> statement that you can copy over into that new instance and run it. This will load and run the server in a temporary directory.</p> <p>Developers might also run into one of two common scenarios: </p> <ol> <li>During development you might want to execute all tests or just a specific group (or groups) of tests. </li> </ol> <p>You are sitting in front of the monitor, and therefore tests can ask you to perform certain tasks, like closing an edit window etc.</p> <p>When a test fails then the test framework stops, and the developer can investigate on the spot.</p> <ol> <li>You might want to execute the test suite automatically (batch mode), meaning that the tests should not attempt to interact with a user. (That means that test cases that depend on a user won't be executed. Tatin has only a few test cases that fall into this category; more than 95% of the tests are batchable)</li> </ol> <p>This might be required by an automated build process.</p> <p>In this case, any errors are trapped, and you get just either a single line that reports success or failure in the session or <code>\u2395OFF</code> is executed, either without a code (in case of success) or the return code 123, indicating failure to the calling environment.</p> <p>Note that a single failing test case is considered as \"failure\" of the whole test suite, though the test framework will continue to execute all remaining tests.</p> <p>We discuss the two different scenarios one after the other.</p> <p>A&gt; ### Creating a new version A&gt; A&gt; Creating a new version is discussed later in this document, but there are scenarios when you need to create a new version before you execute the test cases. A&gt; A&gt; The reason for this is that one group of test cases executes user commands. If they are affected by anything you've changed then naturally you want the new version to be available in <code>\u2395SE</code> for execution, but that is only possible if you create a new version first. A&gt; A&gt; For that reason one test checks whether the version number in the workspace and in <code>\u2395SE</code> do match. If you are confident that this does not matter in your case you may just carry on. </p>"},{"location":"original/tatinforcontributors/#testing-while-developing","title":"Testing while developing","text":""},{"location":"original/tatinforcontributors/#executing-all-tests","title":"Executing all tests","text":"<p>It is recommended to start a fresh APL session and then load the Tatin project into the CLEAR WS before running any test cases.</p> <p>Use <code>]Cider.OpenProject</code> to do this. Once the project has been opened, you can ask Cider how to execute Tatin's test suite by entering:</p> <pre><code>      ]Cider.RunTests\n#.Tatin.#.Tatin.TestCases.RunTests \u235d Execute this for running the test suite\n</code></pre> <p>Note that by default the test cases use port 5001 for communication between the client and the Test Server that is part of Tatin. Change the INI files for both server and client if that does not work for you.</p> <p>When you run the test suite you will be asked whether you want to start a Tatin test server locally, and usually, you will answer with a \"Yes!\". (Windows only, elsewhere you must start the server yourself by starting a new instance of Dyalog and then copying over and executing the <code>)Load</code> statement that is provided as part of the client test suite. This means that at the moment you cannot run the test suite automatically --- batch mode --- on non-Windows platforms, a restriction that will soon be lifted.)</p> <p>A&gt; ### Starting a Tatin test server \"manually\" A&gt; A&gt; There may be scenarios when you want to start a local Tatin test server yourself. For that execute the following steps: A&gt;  A&gt; 1. Instantiate Dyalog Unicode 18.2 or later A&gt;  A&gt; 2. Execute the following two statements: A&gt;  A&gt;    <code>A&gt;    ]Cider.OpenProject /path/to/Tatin A&gt;    #.Tatin.TestCasesServer.RunTests A&gt;</code> A&gt;  A&gt; If you change any code at this stage those changes will be written back to disk, so be careful.</p> <p>The <code>RunTests</code> function performs these tasks:</p> <ul> <li>Change the current directory</li> <li>Establish all required references</li> <li>Instantiate the <code>Tester2</code> class as <code>T</code> </li> <li>Start a local Tatin test server if the user confirms (Windows) this or make the user start a test server (other platforms)</li> <li>Call the <code>T.Run</code> function</li> </ul> <p>This will run all test cases, including those that communicate with a locally running Tatin test server and the principal Tatin server available at https://tatin.dev</p>"},{"location":"original/tatinforcontributors/#quitting-tests","title":"Quitting tests","text":"<p>There are scenarios where you want to quit the test suite, for example when a test unearthed a severe bug that needs fixing straight away, before executing the remaining tests.</p> <p>It may be tempting to enter just <code>)reset</code>, but that is not how you should do this: you have to make sure that the test suite cleans up after itself. </p> <p>The easiest way to achieve this is to execute this statement:</p> <pre><code>      T.QuitTests\n</code></pre> <p>A&gt; ### Execute the client test suite multiple times in parallel A&gt; A&gt; You might come up with the idea to start the client part of the tests multiple times in parallel to put some pressure on the Tatin Server. A&gt; A&gt; In general this is a good idea, but the client test suite is not suitable for this. For example, the tests that belong to the \"Cache\" group must be executed one after the other, they rely on each other. Generally, this should be avoided, but here for technical reasons, it's a must. Running this group in parallel contradicts this, and is bound to fail.</p>"},{"location":"original/tatinforcontributors/#executing-only-particular-tests","title":"Executing only particular tests","text":"<p>The <code>Tester2</code> test framework is flexible and powerful; for example, you may execute only the tests that focus on the Tatin Client API. The names of those tests are <code>Test_API_&lt;number&gt;</code>.</p> <p>A&gt; ### Why executing only a few tests? A&gt; A&gt; The full test suite is exhaustive. Also, caching is switched off (except when caching is tested of course). For these reasons executing the full test suite takes considerable time. Therefore you might be interested in executing only certain parts of the test suite.  A&gt; A&gt; The tests are grouped, and that is reflected by the names of the test functions. For example, the names <code>Test_API_001</code> and <code>Test_UserCommand_001</code> clearly state which group they belong to.</p> <p>If you are not interested in executing only some of the test cases then skip this and carry on with \"Tests as part of an automated build\".</p> <p>Before executing any test case call this function:</p> <pre><code>#.Tatin.TestCases.Prepare\n</code></pre> <p>This changes the current directory, establishes all required references and instantiates the <code>Tester2</code> class as <code>T</code>.</p> <p>You can now list the groups:</p> <pre><code>      T.ListGroups\n Test_API             27   \n Test_Build            1   \n Test_Cache           10   \n Test_CheckVersions    6   \n Test_ClientConfig    19   \n Test_Demo             9   \n Test_HTTP             6   \n Test_InstallAndLoad  24   \n Test_InstallLatest   11   \n Test_ListPkgs        22   \n Test_ListRegistries   1   \n Test_ListTags         6   \n Test_ListVersions     8   \n Test_Load            38   \n Test_LoadBest         4   \n Test_LX               5   \n Test_Misc            19   \n Test_Pack            19   \n Test_PkgCfg           9   \n Test_Publish         15   \n Test_ReInstall        7   \n Test_ScanRegistries   4   \n Test_Server          63   \n Test_Uninstall       15   \n Test_UserCommands    42   \n Test_ZZZ              4   \n</code></pre> <p>The number tells how many tests a group comprehends, so when you execute this command on your own machine, the numbers and rows will possibly be slightly different.</p> <p>You can also list all tests, say for the group <code>ScanRegistries</code>:</p> <pre><code>      T.ListTestFunctions 'Scan*'\n Test_ScanRegistries_002  Search for a specific package without specifying a Registry...\n Test_ScanRegistries_003  Enforce a Registry scan after defining a non-existing Regis...\n Test_ScanRegistries_004  Enforce a Registry scan after defining a non-existing Regis...\n Test_ScanRegistries_005  Enforce a Registry scan. The first \"Registry\" returns HTML ...  \n</code></pre> <p>Notes:</p> <ul> <li>The wildcard character (<code>*</code>) can be used to identify a group</li> <li>The first comment line after any header lines is displayed</li> </ul> <p>You may specify <code>'view'</code> as the left argument to force the result of that function into a read-only <code>\u2395ED</code> window.</p> <p>Let's assume that you want to execute all tests of the group <code>API</code>:</p> <pre><code>T.RunThese 'API'\n</code></pre> <p>Or just the tests 8 and 20 of the group <code>API</code>:</p> <pre><code>T.RunThese 'API' (8 20)\n</code></pre> <p>Or run the groups <code>API</code> and <code>Misc</code>:</p> <pre><code>T.RunThese 'API,Misc'\n</code></pre> <p>Or run all tests but <code>UserCommand</code>:</p> <pre><code>T.RunThese '~UserCommand'\n</code></pre> <p>Last but not least you may specify a 1 as the left argument: this makes the test framework stop just before any particular test function is executed. This can be handy to hunt down a bug, or any unexpected behaviour.</p> <pre><code>1 T.RunThese 'API'\n</code></pre> <p>The test framework offers many more options and features, refer to the documentation for exploring them: go to https://github.com/aplteam/Tester2 (full picture) or execute <code>]ADOC #.Tatin.Tester2</code> (reference).</p>"},{"location":"original/tatinforcontributors/#tests-as-part-of-an-automated-build","title":"Tests as part of an automated build","text":"<p>You may wish to execute the tests that do not require a human in front of the monitor as part of an automated build process. Tatin is prepared for this.</p> <p>You can start the test suite either from APL or from the command line.</p>"},{"location":"original/tatinforcontributors/#running-the-test-suite-from-apl","title":"Running the test suite from APL","text":"<p>Call this function:</p> <pre><code>#.Tatin.TestCases.RunBatchTests 1\n</code></pre> <p>The <code>1</code> provided as the right argument is just insurance against accidental calls.</p> <p>When running the test suite with the batch flag set, as <code>RunBatchTests</code> does, is fundamentally different in several respects:</p> <ul> <li>A Tatin server that listens (by default) on port 5001 is started (and is also shut down) by the test suite itself.</li> <li>By default all errors are trapped. </li> </ul> <p>If you need to track down a bug then you don't want this: in that case, pass a <code>1</code> as the left argument: this is treated as \"debug\" flag.</p> <p>Of course <code>RunBatchTests</code> does not execute any test cases that require a human in front of the monitor, but the number of such tests is small anyway.</p> <p><code>RunBatchTests</code> checks the command line:</p> <ul> <li>In case <code>OFF2=1</code> was specified on the command line then <code>\u2395OFF</code> is executed after the last test case got executed.</li> </ul> <p>If one or more test cases failed then <code>\u2395OFF 123</code> is executed. That allows the calling environment to check whether the test suite was executed successfully in its entirety or not.</p> <ul> <li>If <code>OFF2=1</code> was not specified a message is printed to the session, indicating success or failure.</li> </ul> <p>Note that <code>OFF=1</code> would kind of also work, but it would make Plodder <code>\u2395OFF</code>, the underlying HTTP server used by Tatin. That might be too early. For example, you cannot get a code coverage report then.</p>"},{"location":"original/tatinforcontributors/#running-the-test-suite-from-a-console-or-terminal","title":"Running the test suite from a console or terminal","text":"<p>There are two scripts available in the Tatin root directory:</p> <ol> <li> <p><code>RunTests.bat</code> if you want to run the batch tests under Windows</p> </li> <li> <p><code>RunTests.sh</code> if you want to run the batch tests on a non-Windows platform</p> </li> </ol> <p>These are templates: check their contents, you might need to make amendments. </p>"},{"location":"original/tatinforcontributors/#how-to-create-a-new-version","title":"How to create a new version","text":""},{"location":"original/tatinforcontributors/#ov1","title":"Overview","text":"<p>Usually, your job is done once you've created a Pull Request (PR). However, here we document what the administrator of the Tatin project on GitHub needs to do once she has accepted at least one PR or finished her work on a branch.</p> <p>You may ask Cider how to create a new version of Tatin:</p> <pre><code>      ]Cider.Make\n#.Tatin.#.Tatin.Admin.Make 0 \u235d Execute this for creating a new version\n</code></pre> <p>Syntax:</p> <ul> <li>The right argument must be a Boolean:</li> <li><code>0</code> means that a human is sitting in front of the monitor and can be asked questions or perform actions</li> <li><code>1</code> means that no human is available; use this in case you want to create a new version automatically, for example from a batch script</li> <li>The optional left argument is a Boolean that defaults to <code>0</code>, see below for details.</li> </ul> <p>It would mean that the instances of Dyalog started to create the Client and the Server won't execute the <code>lx</code> command line parameter, allowing you to run the code in the Tracer.</p> <p>Notes:</p> <ul> <li>The build ID is always bumped when you create a new version.</li> <li>The <code>Make</code> function will fire up two instances of Dyalog APL, one for creating the client version, one for creating the server version. The optional left argument, if 1,  prevents the interpreter from running the code straight away. </li> </ul> <p>A&gt; ### The <code>load</code> and <code>lx</code> command line parameters A&gt; Despite the name of the left argument (<code>noQLX</code>) it is not associated with <code>\u2395LX</code>: for this to work the command line parameters <code>load</code> and <code>lx</code> are invoked, and <code>-x</code> is added in case <code>noQLX</code> is 1, preventing the interpreter from executing the expression noted as <code>lx.</code>  A&gt; A&gt; If this looks unfamiliar to you: the options <code>lx</code> and <code>load</code> were introduced in 18.0.</p> <p>The <code>Make</code> function performs the following steps:</p> <ol> <li> <p>It runs <code>Tatin.Admin.MakeClient</code></p> </li> <li> <p>It compiles the documentation (markdown) to HTML files and distributes the files</p> </li> <li> <p>It runs <code>#.Tatin.Admin.MakeServer</code></p> </li> </ol> <p>If the right argument was a <code>0</code> then it will also ask you whether you want to attempt an update for all packages Tatin itself depends on, and it would also ask you whether the new version of the Tatin Client should be copied to the <code>MyUCMDs/</code> folder.</p> <p>In the process, the <code>Dist/</code> folder will be recreated from scratch. The <code>.zip</code> files in <code>Dist/</code> are to be released on GitHub. The <code>Dist/</code> folder will not appear on GitHub due to <code>.gitignore</code>.</p> <p>There will be three zip files:</p> <pre><code>Tatin-Client-{major}.{minor}.{patch}.zip\nTatin-Documentation-{major}.{minor}.{patch}.zip\nTatin-Server-{major}.{minor}.{patch}.zip\n</code></pre>"},{"location":"original/tatinforcontributors/#creating-a-document-for-proofreading","title":"Creating a document for proofreading","text":"<p>There is a function that creates a single HTML file from all the Tatin markdown documentation. That makes proofreading significantly easier:</p> <pre><code>      htmlFilename\u2190#.Tatin.Admin.CreateProofReadDocument 1\n</code></pre> <p>Now open that file with the word processor of your choice and use its spell-checking capabilities.</p>"},{"location":"original/tatinsloadandupdatestrategy/","title":"Tatin's Load and Update Strategy","text":"<p>Before you read this document, you have to have a good understanding of what Semantic Versioning is. If that's the case then carry-on reading, otherwise please read SemanticVersioning first.</p>"},{"location":"original/tatinsloadandupdatestrategy/#the-strategy-problem","title":"The Strategy Problem","text":"<p>Let's imagine that you need two packages, <code>Foo</code> and <code>Goo</code>. Both rely on package <code>Zoo</code>, but while <code>Foo</code> requests 1.1.1 of <code>Zoo</code>, <code>Goo</code> insists on version 1.2.0. However, the best version of <code>Zoo</code> available is 1.3.0, and there is even a later major version available: 2.0.0.</p> <p>Now from what we've said so far it should be clear that version 2.0.0 is not an option at all because it is considered a completely different package and therefore ignored.</p> <p>Because of SemVer we know that <code>Goo</code> would crash on version 1.1.1 of <code>Zoo</code> in case it takes advantage of the new features built into version 1.2.0. (We know there are new features because of the bump of the minor part of <code>Zoo</code>'s version number)</p> <p>We can take several different approaches here:</p> <ul> <li>We could load both versions and make <code>Foo</code> use version 1.1.1 and <code>Goo</code> use version 1.2.0</li> <li>We could load the later version (1.2) and make <code>Zoo</code> and <code>Goo</code> both use that version </li> <li>We could check the server, find that there is an even later version available (1.3.0) and use that one</li> </ul> <p>(More generally, always check for the latest version and use that one)</p> <p>All these options are used by different package managers in the wild, so there is no consensus on what's best.</p> <p>To many programmers, the last option seems particularly appealing because you are always up-to-date, and you always get the latest fixes when you build your application. Great!</p> <p>But when you look at it from a different angle then things look much less appealing: </p> <ol> <li>You build your application (including updating dependencies)</li> <li>You run your test cases -- they all pass</li> <li>You build your application again (without changing anything)</li> <li>You run your test cases again, but this time they fail</li> </ol> <p>This situation can arise if the author of a package you depend on releases a new version between the first and second build. If this new version is buggy, the second build will fetch it, leading to a different outcome even though you haven't made any changes.</p> <p>As appealing as an automated update mechanism might seem, you'd want your builds to be 100% reproducible, right?!</p> <p>So, when asked to load installed packages, Tatin will just do exactly that: load the packages defined as required by the configuration files of the main packages <code>Foo</code> and <code>Goo</code>.</p> <p>Except when a package is requested more than once, and with different minor and/or patch numbers: in that case, Tatin uses the latest installed version, which might or might not be the latest one available. In our example, <code>Zoo</code> is requested and installed twice, and Tatin would load 1.2.0 just once (because it is requested by <code>Goo</code>), while 1.3.0 is ignored because it is not requested and therefore not installed.</p> <p>This means that <code>Foo</code> will also have to use version 1.2.0 of <code>Zoo</code>.</p> <p>This is called \"Minimal Version Selection\". It guarantees that when you re-build, you will get the same result, but it will grab the latest installed version. </p> <p>A&gt; ### On updating dependencies A&gt;  A&gt; Though Tatin will not assist you in updating dependencies, it will assist you in finding out whether there are later packages available. A&gt; A&gt; For that check the user command <code>]TATIN.CheckForLaterVersions</code>. Also, check the <code>-update</code> flag of the <code>]Tatin.ReInstallDependencies</code> user command or its API equivalent. A&gt;  A&gt; We will discuss this in a minute.</p> <p>A&gt; ### Forcing updates A&gt; Imagine a package of yours depends on somebody else's package <code>Foo</code> which in turn depends on <code>Goo</code> 1.1.0, and you stumble over a bug in <code>Goo</code> 1.1.0 while using <code>Foo</code>. A&gt; A&gt; You send an email to the author of <code>Foo</code>, pointing out that there is already <code>Goo</code> 1.1.1 available that fixes that very bug, but the author does not reply, or tells you that she will produce and publish a new version in two weeks time while you struggle whith a tight dealine. A&gt;  A&gt; Solution: create a package <code>Mock</code> that declares to depend on <code>Goo</code> 1.1.1 and voila! everything works.</p>"},{"location":"original/tatinsloadandupdatestrategy/#loading-dependencies","title":"Loading Dependencies","text":"<p>Imagine these packages:</p> <pre><code>    +-----------+        +-----------+\n    | Foo 1.0.0 |        | Goo 2.1.0 |\n    +-----------+        +-----------+\n          |                   |\n          |                   |\n          \u2228                   \u2228\n    +-----------+        +-----------+\n    | Zoo 1.1.1 |        | Zoo 1.2.0 |\n    +-----------+        +-----------+\n</code></pre> <p>For simplicity, we will assume that the packages are all hosted by a Tatin server known under the alias name <code>MyTatin</code></p> <p>While <code>Foo</code> relies on <code>Zoo</code> 1.1.1, <code>Goo</code> needs <code>Zoo</code> 1.2.0 --- what is Tatin doing about this?</p> <p>It depends on what you are doing. Let's first load <code>Zoo</code> and <code>Goo</code> into the workspace, the usual approach to inspect a package:</p> <pre><code>      ]TATIN.LoadPackages [MyTatin]/mygroup-Foo-1.0.0 #.MyPkgs\n#.MyPkgs.Foo\n      ]TATIN.LoadPackages [MyTatin]/mygroup-Goo-2.1.0 #.MyPkgs\n#.MyPkgs.Goo\n      #.MyPkgs.\u2395nl \u237316\nFoo\nGoo\n</code></pre> <p>A&gt; ### Getting the latest version A&gt; A&gt; Assuming that version 1.3.0 of <code>Foo</code> is the latest version available with the major number 1, then this would have been sufficient: A&gt; <code>A&gt; ]TATIN.LoadPackages [MyTatin]/mygroup-Foo-1 #.MyPkgs A&gt;</code> A&gt; Note that neither the minor nor the patch number has been specified. A&gt; A&gt; Assuming that version 2.1.0 of <code>Goo</code> is the very latest version available at all, and that's the version you want to use, A&gt; then this would have been sufficient: A&gt; A&gt; <code>A&gt; ]TATIN.LoadPackages [MyTatin]/mygroup-Goo #.MyPkgs A&gt;</code> A&gt; Note that in this case not even the major number has been specified.</p> <p>You wanted <code>Foo</code> and <code>Goo</code> to be loaded into <code>#.MyPkgs</code>, and that's exactly what Tatin did. But where are the dependencies?</p> <p>Note that <code>#.MyPkgs</code> just carries references pointing to where the packages have been loaded into, and that is the namespace <code>#._tatin</code>:</p> <pre><code>      #._tatin.\u2395nl 9\nmygroup_Foo_1_0_0   \nmygroup_Goo_2_1_3 \nmygroup_Zoo_1_1_1 \nmygroup_Zoo_1_2_0\n</code></pre> <p>Note that both versions of <code>Zoo</code> have been loaded. That's because the two Load operations are independent of each other, therefore minimal version selection cannot be applied.</p>"},{"location":"original/tatinsloadandupdatestrategy/#installing-packages","title":"Installing packages","text":"<p>To make packages a part of an application (say), they first need to be installed. In the following example, we will install two packages, <code>Foo</code> and <code>Goo</code>. Both require <code>Zoo</code>, so <code>Zoo</code> will be installed as a side effect.</p> <pre><code>      \u2395NEXISTS /myPkgs\n0\n      ]TATIN.InstallPackages [MyTatin]/mygroup-Foo-1.0.0 /myPkgs/\n/myPkgs/mygroup-Foo-1.0.0\n      ]TATIN.InstallPackages [MyTatin]/mygroup-Goo-2.1.0 /myPkgs/\n/myPkgs/mygroup-Goo-2.1.0\n      \u236a\u2283\u2395NINFO \u2360 1\u22a2'/myPkgs/*'\n/myPkgs/apl-buildlist.json  \n/myPkgs/apl-dependencies.txt\n/myPkgs/mygroup-Foo-1.0.0\n/myPkgs/mygroup-Goo-2.1.0\n/myPkgs/mygroup-Zoo-1.1.1\n/myPkgs/mygroup-Zoo-1.2.0\n</code></pre> <p>Let's check the contents of the <code>/myPkgs/apl-dependencies.txt</code> file:</p> <pre><code>      \u2283\u2395NGET '/myPkgs/apl-dependencies.txt'\nmygroup-Foo-1.0.0                          \nmygroup-Goo-2.1.0                             \n</code></pre> <p>Note that these are the principal packages that we've installed.</p> <p>Let's check the contents of the <code>/myPkgs/apl-buildlist.json</code> file:</p> <pre><code>      #.q\u2190\u2395JSON\u2360('Dialect' 'JSON5')\u22a2\u2283\u2395NGET'/myPkgs/apl-buildlist.json'\n      \u2349\u2191#.q.(depth packageID)\n1 mygroup-Foo-1.0.0\n0 mygroup-Zoo-1.1.1\n1 mygroup-Goo-2.1.0\n0 mygroup-Zoo-1.2.0\n</code></pre> <p>Note that the principal packages carry a 1 in the first column whiles dependencies carry a 0.</p> <p>The build list comprises not only the two principal packages but also all dependencies.</p>"},{"location":"original/tatinsloadandupdatestrategy/#loading-the-installed-packages","title":"Loading the installed packages","text":"<p>Though installing packages is roughly the same as loading packages except that the packages end up in the file system rather than the workspace, loading installed packages allow Tatin to optimize what's loaded, and in this respect the two differ.</p> <p>Installed packages are loaded with the Tatin user command <code>LoadDependencies</code> which takes a folder as an argument that must have a file <code>apl-dependencies.txt</code> but also a file <code>apl-buildlist.json</code> which was created when you installed your first package, and which will be extended when you install additional packages.</p> <p>You may also specify a second argument: that's where the references pointing to the principal packages are going to be created. If you do not specify this it defaults to <code>#</code> in case you are in <code>#</code>. If you are, say, in <code>#.foo</code> then Tatin will ask you whether you want to install into <code>#</code> or into <code>#.foo</code>.</p> <pre><code>      ]TATIN.LoadDependencies /myPkgs/ #.Temp\n</code></pre> <p>This is what <code>LoadDependencies</code> will do:</p> <ol> <li>It reads the file <code>apl-dependencies.txt</code>.</li> <li>It checks whether this file was changed after the file <code>apl-buildlist.json</code> was written to disk.</li> </ol> <p>If that is the case, the build list will be checked for consistency with <code>apl-dependencies.txt</code>; if it's okay then the build list is created from scratch, 3. Finally it will prune the build list and bring in the remaining packages.</p> <p>Note that the pruning is in charge of removing the package <code>Zoo</code> 1.1.1. That means that rather than loading <code>Zoo</code> twice only the latest installed version will be loaded: both <code>Foo</code> and <code>Goo</code> will use <code>Zoo</code> version 1.2.0. </p>"},{"location":"original/tatinsloadandupdatestrategy/#special-case","title":"Special case","text":""},{"location":"original/tatinsloadandupdatestrategy/#removing-a-principal-package","title":"Removing a principal package","text":"<p>Let's assume that you don't need <code>Goo</code> anymore.</p> <p>Generally, we advise to not delete stuff manually from the folder that holds all packages of an application. </p> <p>If you want to get rid of a package then you are strongly advised to use the method </p> <p><code>]TATIN.UnInstallPackage</code> </p> <p>I&gt; The API equivalent is <code>\u2395SE.Tatin.UnInstallPackage</code></p> <p>This method will make sure that it removes not only the package in question, but also all packages that are dependencies of it, but only if those packages are neither principal packages nor requested by other packages.</p> <p>Clearly, there is a danger that you remove too much when you attempt to do this manually.</p>"},{"location":"original/tatinsloadandupdatestrategy/#implicit-downgrading","title":"Implicit downgrading","text":"<p>There might be a situation when removing a principal package implies a downgrade.</p> <p>We start with these packages (indentation defines dependency):</p> <pre><code>group-foo-1.0.0\n  group-zoo-1.1.0\ngroup-boo-1.0.0\n  group-zoo-1.0.0\n</code></pre> <p>Due to MVS (minimal version selection) both <code>foo</code> and <code>boo</code> will use <code>zoo</code> version 1.1 when loaded. But what happens if you remove <code>boo</code>?!</p> <p>It can well be argued that <code>zoo</code> 1.1 should survive this, and still be used. But it can also be argued that a package that is not required anywhere shouldn't be used. </p> <p>A full implementation of MVS requires the former strategy. For the time being, we took a more pragmatic approach and settled for the latter strategy.</p> <p>It's not really obvious what's the best solution here, so we might well change the strategy depending on feedback.</p>"},{"location":"original/tatinsloadandupdatestrategy/#adding-a-package","title":"Adding a package","text":"<p>If you want to add a package that has no dependencies you might feel tempted to just add it to the file \"apl-dependencies.txt\" and copy the package over.</p> <p>That would indeed not cause a problem because when the <code>LoadDependencies</code> command is issued the next time, Tatin would check whether the file <code>apl-dependencies.txt</code> was changed after <code>apl-buildlist.json</code> was created by Tatin.</p> <p>In our case this is true, so Tatin would perform some health checks, and an error would be thrown in case they fail. This is mainly insurance against people manually changing <code>apl-dependencies.txt</code> and making mistakes.</p> <p>When the health checks pass, the build-list would be re-created.</p>"},{"location":"original/tatinsloadandupdatestrategy/#checking-and-updating","title":"Checking and updating","text":"<p>Let's assume you want to check whether there are later versions of the principal packages of your application available.</p> <p>There is a user command available that can help you with that:</p> <pre><code>      ]TATIN.CheckForLaterVersion ./\n</code></pre> <p>It requires a path to a folder that holds a file <code>apl-dependencies.txt</code>  and a file <code>apl-buildlist.json</code>. </p> <p>This user command would check whether there are any later versions of the principal packages available and report its findings to the session.</p> <p>As usual, Tatin would consider packages with different major numbers as different packages, so by default you will get only a list of packages that have the same group-name, package-name and major version number as your principal packages.</p> <p>It is then up to you to take action: you may or may not install a later package that is available.</p> <p>A&gt; ### Later major versions A&gt; When you specify the <code>-major</code> flag of the <code>CheckForLaterVersion</code> user command, the user command will report later major versions as well.</p>"},{"location":"original/tatinsloadandupdatestrategy/#downgrading","title":"Downgrading","text":"<p>There may be situations when you need to downgrade, for example when you find a particular package to be buggy, but an older version is known to be okay. Tatin does not offer help here; you need to do this yourself.</p>"},{"location":"original/tatinusersettings/","title":"Tatin User Settings","text":""},{"location":"original/tatinusersettings/#introduction","title":"Introduction","text":"<p>Tatin uses a file to remember all Tatin Registries you want to work with, and possibly other user-specific settings as well. We refer to this file as the user settings file.</p> <p>When you start using Tatin for the very first time there is no such file, and therefore Tatin will create one in a specific location. </p> <p>Once Tatin is installed, when you fire up an instance of Dyalog APL the contents of the file is used to instantiate the <code>Tatin.UserSettings</code> class. The instance is assigned to <code>\u2395SE.Tatin.MyUserSettings</code>. From then on any changes to the file with an external editor do not affect <code>\u2395SE.Tatin.MyUserSettings</code>!</p> <p><code>\u2395SE.Tatin.MyUserSettings</code> provides several properties that can be referenced as well as several methods that can be issued to manipulate the user settings.</p> <p>For example, this call:</p> <pre><code>      ]Tatin.ListRegistries\nAlias                    URL         ID  Port  Priority No-Caching Proxy\n-----------------------  ----------  --- ----  -------- ---------- -----\nhttps://tatin.dev/       tatin       ...    0       100           0\nhttps://test.tatin.dev/  tatin-test  ...    0         0           0\n</code></pre> <p>shows most of the data that is saved in the user settings for registries, except the API key(s).</p> <p>If you would like to see the API keys as well specify the <code>-full</code> flag.</p>"},{"location":"original/tatinusersettings/#the-default-file","title":"The default file","text":"<p>That default file will have two  Tatin Registries defined in it: </p> <ul> <li>The principal Tatin server, available via the URL <code>https://tatin.dev/</code></li> </ul> <p>It has an alias <code>tatin</code> assigned to it, so you can address it as <code>[tatin]</code> with all user commands that require a Registry as a parameter, though if you don't specify any server at all, they will act on the principal server by default.</p> <ul> <li>The Tatin Test server, available via the URL <code>https://test.tatin.dev/</code></li> </ul> <p>It has an alias <code>tatin-test</code> assigned to it, so you can address it as <code>[tatin-test]</code> with all user commands that require a Registry as a parameter.</p> <p>It has a priority of <code>0</code> assigned to it which means that it will not participate in Registry scans.</p> <p>Registry scans are performed by Tatin when you ask for a package but do not specify a Registry. Tatin scans all Registries in order of their priorities (highest one first) but ignores those with a priority that is <code>0</code>.</p>"},{"location":"original/tatinusersettings/#where-does-the-file-live","title":"Where does the file live?","text":"<p>This default file will be created in the user's home folder; the API function <code>\u2395SE.Tatin.GetUserHomeFolder''</code> does return that folder.</p> <p>You may also ask the user command with:</p> <pre><code>]UserSettings -home\n</code></pre>"},{"location":"original/tatinusersettings/#whats-the-name-of-the-file","title":"What's the name of the file?","text":"<p>The name of the file is <code>tatin-client.json</code>.</p>"},{"location":"original/tatinusersettings/#may-i-edit-the-file","title":"May I edit the file?","text":"<p>Of course you are free to edit that file with any editor. However, keep in mind that you are in charge of making sure that the contents of the file is valid JSON5<sup>1</sup>: if it's not, Tatin will crash.</p> <p>If you are familiar with JSON5 syntax and want to edit the file it is recommended to use:</p> <pre><code>]TATIN.UserSettings -edit\n</code></pre> <p>This will allow you to edit the file contents, but Tatin will check it afterward to make sure that nothing invalid ever goes into the file.</p> <p>Note that Dyalog 18.2 and later recognize JSON5 and highlight any syntax errors.</p>"},{"location":"original/tatinusersettings/#what-does-tatin-do-at-start-up-time","title":"What does Tatin do at start-up time?","text":"<p>When Tatin is initialized<sup>2</sup> it creates an instance of the <code>UserSettings</code> class with the name <code>MyUserSettings</code> which lives in <code>\u2395se.Tatin</code>. (Strictly speaking it lives actually in <code>\u2395SE._Tatin</code>; in <code>\u2395SE.Tatin</code> there is just a niladic function <code>MyUserSettings</code> that returns a reference to <code>\u2395SE._Tatin.MyUserSettings</code>)</p> <p>If the constructor does not get a fully qualified name of the user settings file as an argument then it performs two steps:</p> <ol> <li>It looks for a file <code>.tatin</code> in the user's home folder.</li> </ol> <p>If the file exists and is not empty then it is expected to point to a user settings file, and Tatin will go for that file.</p> <p>We will discuss soon under which circumstances such a file might be useful.</p> <ol> <li> <p>In case there is no file <code>.tatin</code> in that folder, or the file is empty, Tatin will look for a user settings file in the default folder.</p> </li> <li> <p>If that file exists then Tatin will instantiate it</p> </li> <li> <p>If the file does not exist then it will be created with default settings</p> </li> </ol>"},{"location":"original/tatinusersettings/#synchronizing-file-and-workspace","title":"Synchronizing file and workspace","text":""},{"location":"original/tatinusersettings/#changes-made-to-the-file","title":"Changes made to the file","text":"<p>If you change the file that Tatin has instantiated by editing it with an external editor, and have an APL session up and running, then your change does not have an impact on the APL session. </p> <p>However, you can force Tatin to bring the session in line with the file by executing:</p> <pre><code>      ]TATIN.Init\n</code></pre>"},{"location":"original/tatinusersettings/#changes-made-in-the-workspace","title":"Changes made in the workspace","text":"<p>If you manipulate the instance in the workspace, then the changes won't be written to disk. You need to call the monadic <code>Save</code> method (with a <code>1</code> as the right argument) to make your changes permanent.</p>"},{"location":"original/tatinusersettings/#comments","title":"Comments","text":"<p>Note that JSON5 allows two different types of comments:</p>"},{"location":"original/tatinusersettings/#block-comments","title":"Block comments","text":"<p>Everything between <code>/*</code> and <code>*/</code> is recognized as a comment, like this:</p> <pre><code>/*\n  This is a comment that...\n  stretches over several lines\n*/.\n</code></pre>"},{"location":"original/tatinusersettings/#line-comments","title":"Line comments","text":"<p>This is an example of a line that is recognized as a comment:</p> <pre><code>// This is a comment line\n</code></pre>"},{"location":"original/tatinusersettings/#summary","title":"Summary","text":"<p>In most scenarios, you will probably be happy with having just one user settings file for Tatin, and having it in its default location.</p> <p>You may however want to have your own Tatin Registries, for example for private projects.</p>"},{"location":"original/tatinusersettings/#adding-and-removing-registries","title":"Adding and removing Registries","text":"<p>You can manipulate the <code>MyUserSettings</code> instance via its methods.</p> <p>We are now going to add a registry, list all registries, and then delete that registry, getting us back to where we started.</p>"},{"location":"original/tatinusersettings/#what-have-we-got","title":"What have we got?","text":"<p>Let's list all registries currently defined:</p> <pre><code>      \u2395se.Tatin.MyUserSettings.ListRegistries 0\nAlias      URL                     Port  Priority No caching Proxy API-key\n-----      ------------------      ----  -------- ---------- ----- -------\ntatin      https://tatin.dev/         0       100          0           ***\ntatin-test https://test.tatin.dev/    0         0          0           ***\n</code></pre> <p>This is because originally Tatin only knows about the principal Tatin server and its cousin, the test server.</p> <p>Note that the API key is not listed when a zero is provided as the right argument.</p> <p>Let's add a made-up registry.</p>"},{"location":"original/tatinusersettings/#create-an-instance-of-the-defineregistry-class","title":"Create an instance of the <code>DefineRegistry</code> class.","text":"<p>Let's assume that you work for a company \"MyCompany\", and that this company entertains a Tatin Server with the URL <code>https://tatin.mycompany.com</code>.</p> <p>To add that Registry to the user settings file you must first instantiate the <code>DefineRegistry</code> class. You may specify the URL and the alias in several ways; for details on the <code>DefineRegistry</code> class execute this:</p> <pre><code>]adoc \u2395se.Tatin.DefineRegistry\n</code></pre> <p>We will pass a simple text vector that specifies the alias (between <code>[]</code>) and the URI:</p> <pre><code>      #.myReg\u2190\u2395NEW \u2395SE.Tatin.DefineRegistry (,\u2282'[myc]https://tatin.mycompany.com')\n      #.myReg.varsList\n uri  alias  port  api_key  priority \n      ]box on\n      {\u2375,\u236a#.myReg.(\u234e\u00a8\u2375)}'uri' 'alias' 'port' 'api_key' 'priority'\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502uri     \u2502https://tatin.mycompany.com/\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502alias   \u2502myc                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502port    \u25020                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502api_key \u2502                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502priority\u2502[Null]                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      ]box off\n</code></pre> <p>\"id\" is not mentioned here, because it is optional, and <code>DefineRegistry</code> will assign a freshly generated UUID to it for you. Refer to The \"id\" for details.</p>"},{"location":"original/tatinusersettings/#settings-in-the-file","title":"Settings in the file","text":"<ul> <li><code>uri</code> and <code>alias</code> are already set by the constructor.</li> <li><code>port</code> is 0 which means that it will fall back to 80 for <code>http://</code> and 443 for <code>https://</code>.</li> <li><code>priority</code> decides in which order Registries are scanned in case no Registry was provided. The Registry with the highest number is scanned first, and the first hit wins.</li> </ul> <p><code>\u2395NULL</code> will be converted once the instance is added to the user settings, see there.</p> <p>Note that a priority of <code>0</code> or less means that the registry will not participate in a Registry scan. * <code>api_key</code> must be set only when the Registry is managed by a Tatin server and you want to publish packages, or delete packages (if that is permitted by that Tatin server at all) and credentials are required for those operations.</p>"},{"location":"original/tatinusersettings/#adding-the-registry","title":"Adding the Registry","text":"<p>Adding a registry is achieved by calling the <code>AddRegistry</code> method, and providing an instance of the <code>DefineRegistry</code> class as an argument:</p> <pre><code>      \u2395se.Tatin.MyUserSettings.AddRegistry #.myReg\n</code></pre> <p>Now we would expect three Registries:</p> <pre><code>      \u2191\u2395se.Tatin.MyUserSettings.registries.(alias uri priority)\n tatin       https://tatin.dev/           100\n myc         https://tatin.mycompany.com/  90\n tatin-test  https://test.tatin.dev/        0\n</code></pre> <p>The priority is not <code>\u2395NULL</code> anymore but 90: any <code>\u2395NULL</code> is replaced by the lowest number yet minus 10.</p> <p>A&gt; ### Regarding priorities A&gt; What happens when you add a Registry with <code>priority</code> being <code>\u2395NULL</code> and the lowest Registry so far is 1? A&gt;  A&gt; In that case Tatin assigns new values to all Registries except those with a priority of zero which will remain untouched. A&gt;  A&gt; The new priorities will not change the order of the priorities, and the lowest one will be 100 or greater.</p> <p>So far we have changed the user settings in the workspace, not on file. This allows you to experiment with certain settings without making the change permanent; other sessions won't be affected.</p> <p>If you want to make your changes permanent you must call the <code>Save</code> method and provide a 1 as the right argument.</p>"},{"location":"original/tatinusersettings/#putting-the-user-config-file-elsewhere","title":"Putting the user config file elsewhere","text":"<p>There might be scenarios when the default location for the user config file is not suitable for you.</p> <ul> <li> <p>If you cannot make frequent changes to the Tatin user settings file in its default location due to, say,  company constraints, then of course it needs to go elsewhere.</p> </li> <li> <p>Your computer is used by several people, and they all (or at least two of them) need write access to the Tatin user settings file.</p> </li> </ul> <p>You could still use the default location, but because that location is user-specific, every user would require her own user settings file, which is something you might or might not want to avoid.</p> <p>In the aforementioned cases as well as other scenarios you need more freedom than what is provided by default.</p> <p>For that, you must create a user settings file in a specific location. To achieve that we re-instantiate the class <code>UserConfig</code>, and we provide a path to the folder where the file should live:</p> <pre><code>      p\u2190,\u2282'/path2/user_config_file/'\n      \u2395SE._Tatin.Client.MyUserSettings\u2190\u2395SE._Tatin.Client.\u2395NEW \u2395SE.Tatin.UserSettings p\n      \u2374\u2395\u21901 \u2395se.Tatin.ListRegistries 0\ntatin      https://tatin.dev       ... 0 100 0\ntatin-test https://test.tatin.dev  ... 0   0 0\n2 7\n      \u2374\u2395\u2190\u2395se.Tatin.MyUserSettings.ListRegistries 0\n Alias  URL                  Port  Priority No caching Proxy API-key\n -----  ------------------   ----  -------- ---------- ----- -------\n tatin  https://tatin.dev/      0       100          0           ***\n test-tatin  https://tatin.dev/ 0       100          0           ***\n2 7\n</code></pre> <p>Notes:</p> <ul> <li>We use the same name as before (<code>MyUserSettings</code>) because all Tatin user commands as well as all Tatin API functions assume the existence of an instance of the class <code>UserSettings</code> with that name.</li> <li>API keys are not shown unless you specify a <code>1</code> as the right argument to <code>ListRegistries</code></li> <li>When you fire up a new session of Dyalog APL right  now, it would still look for the user settings file in its standard location.</li> </ul>"},{"location":"original/tatinusersettings/#make-the-switch-permanent","title":"Make the switch permanent","text":"<p>To make this user settings file the default file, meaning that this file will be instantiated the next time Dyalog APL is fired up, we need to make sure that a file <code>.tatin</code> in the default folder (that's the one returned by <code>\u2395SE.Tatin.GetUserHomeFolder''</code>) contains a path pointing to that folder.</p> <p>You can do this yourself, but you can also ask the instance for doing the job for you:</p> <pre><code>      \u2395SE.Tatin.MyUserSettings.MakeDefaultFile 1\n</code></pre> <p>From now on, the file <code>MyUserSettings.path2config</code> is pointing to, will be used to determine the user settings.</p>"},{"location":"original/tatinusersettings/#other-settings","title":"Other settings","text":"<p>You can specify these pieces of information as well:</p> <code>group</code> <p>The name your packages will use.</p> <code>license</code> <p>The license you usually use to publish a package.</p> <code>maintainer</code> <p>The email address of the maintainer of your packages (most likely your email address).</p> <code>source</code> <p>The name of a folder in your package where all source files are stored.</p> <p>These define the defaults to be used when a new package is created.</p> <code>id</code> <p>A unique key that can be used to identify a Registry definition in the user settings file when neither the URL nor an alias can be used for this. </p> <p>However, because mot of the time URL or alias are sufficient for this, setting <code>id</code> is optional.</p>"},{"location":"original/tatinusersettings/#editing-the-file","title":"Editing the file","text":"<p>Editing the file with an editor is possible but has the disadvantage that you might make a mistake without noticing.</p> <p>If you find using an instance of <code>DefineRegistry</code> and the <code>Add</code> method too cumbersome but want to edit the file use this:</p> <pre><code>]UserSettings -edit\n</code></pre> <p>This checks the file and tries hard to make sure that it is valid and fulfils Tatin's needs.</p>"},{"location":"original/tatinusersettings/#the-id","title":"The \"id\"","text":"<p>Because it must be possible to define more than one set for the same URL --- for different groups! --- in the user settings, the URL does not necessarily qualify as a unique key for a Registry. Neither does the alias, because it is optional, and you may reset it to \"undefined\".</p> <p>So we need a unique key for this (though admittedly not many will be in need for this). That's why you may set \"id\". </p> <p>If you use the <code>DefineRegistry</code> class then \"id\" will be a newly created UUID. If you prefer to add a new Registry to the user settings by editing the user settings file then you should add \"id\" yourself. </p> <p>This has only an impact locally in a scenario mentioned above, and that's why this is optional.</p> <ol> <li> <p>Tatin uses JSON5 rather than JSON.\u00a0\u21a9</p> </li> <li> <p>Tatin will be initialized either explicitly or as a side effect when the first Tatin user command is issued. See \"Installing and updating the Tatin Client\" for details.\u00a0\u21a9</p> </li> </ol>"},{"location":"original/usagedata/","title":"Usage Data","text":""},{"location":"original/usagedata/#overview","title":"Overview","text":"<p>It is natural to assume that package authors would like to know how many people are interested in their packages, or how often a package was downloaded. </p> <p>Tatin tries to deliver that information, but there is an obstacle one has to be aware of:</p> <p>Tatin uses a machine-specific cache when downloading a package in order to save bandwidth and CPU resources in case a package is requested again by either the same user or a different user on the same machine.</p> <p>So a single download can testify only so much: it might just be an attempt to give a package a try and then forget about it, or it might be used in several different applications, and by multiple users, all but the first one served by the cache. You can't know.</p> <p>Tatin's test suite requests packages from both the Tatin Server and the Test server, but these requests are flagged as part of a test and ignored when the usage data is compiled.</p>"},{"location":"original/usagedata/#what-tatin-is-doing","title":"What Tatin is doing","text":"<p>With the arrival of a new month, Tatin collects all the data of the current year except the new month and saves them as a CSV file. It then compresses the file and makes it available for download.</p> <p>The name of the file is <code>usage-data-&lt;YYYY&gt;-&lt;MM&gt;</code>. For example, in May 2022 it would save <code>usage-data-2022-04</code>, and it would also delete the file <code>usage-data-2022-03</code>.</p> <p>So the filename <code>usage-data-2022-04</code> means all data from 2022 up to and including April.</p> <p>Once a year, in January, Tatin collects the data from last year and saves it in a file <code>usage-data-&lt;YYYY&gt;</code>. It also deletes any files <code>usage-data-&lt;YYYY&gt;-&lt;MM&gt;</code>.</p> <p>For example, in January 2023 it would create a file <code>usage-data-2022</code>, and it would delete all files <code>usage-data-2022-*</code>.</p>"},{"location":"original/usagedata/#how-to-retrieve-the-data","title":"How to retrieve the data","text":""},{"location":"original/usagedata/#web-interface","title":"Web interface","text":"<p>A Tatin server offers a page dedicated to the usage data. The page shows some of the data and also offers links for downloading the data.</p>"},{"location":"original/usagedata/#user-command","title":"User command","text":"<p>There is a command <code>]Tatin.UsageData</code> available for listing and downloading usage data.</p> <p>Enter <code>]Tatin.UsageData -??</code> for details.</p>"},{"location":"original/usagedata/#api","title":"API","text":"<p>There are no API functions available for retrieving usage data.</p>"}]}