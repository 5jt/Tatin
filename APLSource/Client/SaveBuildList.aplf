 {r}←{append}SaveBuildList(buildList path);filename;ns;bool;b;mat;b1;b2;new;old;b3;ind;groupNameMajor;topLevel
⍝ Takes a dependency tree (`buildlist`) and (by default) appends it to `path`.\\
⍝ The optional left arguemtn `append` defaults to 1, meaning that `buildlist` is
⍝ appended to an already existing build list. If set to 0 any existing file is replaced.
 r←⍬
 append←{0<⎕NC ⍵:⍎⍵ ⋄ 1}'append'
 buildList[;3]←RemoveFileProtocol¨buildList[;3]
 filename←path,Reg.BuildListFilename{('/',⍺)/⍨⍺≢(-≢⍺)↑⍵}path
 :If F.IsFile filename
 :AndIf append
     ns←⎕JSON⍠('Dialect' 'JSON5')⊣⊃F.NGET filename
     :If ∨/bool←~buildList[;2]∊ns.packageID
         buildList←bool⌿buildList  ⍝ Remove what we already have
     :EndIf
 :Else
     ns←⎕NS''
     ns.(depth packageID url)←⊂''
 :EndIf
 :If ~append
     F.DeleteFile path
 :EndIf

 b1←1=buildList[;1]
 b2←1=ns.depth
 new←Reg.RemoveMinorAndPatch¨b1/buildList[;2]
 old←Reg.RemoveMinorAndPatch¨b2/ns.packageID
 :If ∨/b3←old∊new
     ⍝ A top-level package has been installed, so the old version needs to be removed
     ind←((~b3)/⍸b2),⍸~b2
     ns.(depth packageID url)←(⊂⊂ind)⌷¨ns.(depth packageID url)
 :EndIf

 ns.depth,←buildList[;1]
 ns.packageID,←buildList[;2]
 ns.url,←buildList[;3]
 ns.url←{'/'@(⍸'\'=⍵)⊢⍵}¨ns.url
 mat←⍉↑ns.(depth packageID url)

 (topLevel mat)←{b←1=⍵[;1] ⋄ (b⌿⍵)((~b)⌿⍵)}mat
 mat←⊖mat[Reg.SortIndexForPackageIDs mat[;2];]
 groupNameMajor←Reg.RemoveMinorAndPatch¨mat[;2]
 b←(groupNameMajor⍳groupNameMajor)=⍳≢mat
 mat←b⌿mat
 mat←topLevel⍪mat
 ns.(depth packageID url)←↓⍉mat
 (⊂Reg.JSON ns)F.NPUT filename 1
⍝Done
